<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Retention Indices · JuChrom</title><meta name="title" content="Retention Indices · JuChrom"/><meta property="og:title" content="Retention Indices · JuChrom"/><meta property="twitter:title" content="Retention Indices · JuChrom"/><meta name="description" content="Documentation for JuChrom."/><meta property="og:description" content="Documentation for JuChrom."/><meta property="twitter:description" content="Documentation for JuChrom."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuChrom logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuChrom</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/basics/">Basics</a></li><li><a class="tocitem" href="../../man/retentionindices/">Retention Indices</a></li><li><a class="tocitem" href="../../man/massspectra/">Mass Spectra</a></li><li><a class="tocitem" href="../../man/import/">Data Import</a></li><li><a class="tocitem" href="../../man/export/">Data Export</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../internals/base/">Base</a></li><li><a class="tocitem" href="../../internals/explorer/">Explorer</a></li><li><a class="tocitem" href="../../internals/inputoutput/">InputOutput</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Retention Indices</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Calibration-Points-from-a-Delimited-File"><span>Example 1: Calibration Points from a Delimited File</span></a></li><li><a class="tocitem" href="#Example-2:-Calibration-Points-from-an-Excel-File"><span>Example 2: Calibration Points from an Excel File</span></a></li><li><a class="tocitem" href="#Example-3:-Error-in-Inferring-NaturalCubicBSpline-Interpolant"><span>Example 3: Error in Inferring NaturalCubicBSpline Interpolant</span></a></li><li><a class="tocitem" href="#Example-4:-Plotting-TIC-against-RI"><span>Example 4: Plotting TIC against RI</span></a></li><li><a class="tocitem" href="#Example-5:-Plotting-multiple-TICs-against-RI"><span>Example 5: Plotting multiple TICs against RI</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../man/register/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Retention Indices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Retention Indices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oniehuis/JuChrom.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oniehuis/JuChrom.jl/blob/main/docs/src/tutorials/retentionindices.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Retention-Indices"><a class="docs-heading-anchor" href="#Retention-Indices">Retention Indices</a><a id="Retention-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Retention-Indices" title="Permalink"></a></h1><h2 id="Example-1:-Calibration-Points-from-a-Delimited-File"><a class="docs-heading-anchor" href="#Example-1:-Calibration-Points-from-a-Delimited-File">Example 1: Calibration Points from a Delimited File</a><a id="Example-1:-Calibration-Points-from-a-Delimited-File-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Calibration-Points-from-a-Delimited-File" title="Permalink"></a></h2><p>Let&#39;s assume we have a set of calibration points for calculating the  <a href="https://en.wikipedia.org/wiki/Kovats_retention_index">Kovats retention index</a>,  stored in a delimited file. The first step is to read and format the data so it can  be passed to the <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> constructor. In this example, we are using a .CAL file  generated by the <a href="https://chemdata.nist.gov/dokuwiki/doku.php?id=chemdata:amdis">AMDIS</a>  software. The contents of the file <code>example1.CAL</code> are as follows:</p><pre><code class="nohighlight hljs">4.154 900.0 98 1478 Nonane
5.635 1000.0 100 1215 Decane
7.145 1100.0 95 1606 Undecane
8.628 1200.0 100 1762 Dodecane
10.043 1300.0 100 1782 Tridecane
  ⋮
25.435 3400.0 92 920 Tetratriacontane
27.204 3500.0 90 819 Pentatriacontane
29.366 3600.0 91 723 Hexatriacontane
32.026 3700.0 88 602 Heptatriacontane
35.273 3800.0 85 493 Octatriacontane</code></pre><p>As we can see, the file contains whitespace-separated columns, but only the first two are  relevant for our purposes. The first column lists the retention times (in minutes), while  the second column provides the corresponding retention indices.</p><p>We will use a function from the  <a href="https://github.com/JuliaData/DelimitedFiles.jl">DelimitedFiles.jl</a> package, which comes  with <a href="https://julialang.org">Julia</a>, to read the file contents. Additionally, we need to  assign the minute time unit to the time values. Since  <a href="https://github.com/oniehuis/JuChrom.jl">JuChrom.jl</a> re-exports names from the  <a href="https://painterqubits.github.io/Unitful.jl">Unitful.jl</a> package, we will also load  <a href="https://github.com/oniehuis/JuChrom.jl">JuChrom.jl</a> at this stage. To plot the inferred  mapping function, we will further load the  <a href="https://github.com/MakieOrg/Makie.jl/tree/master/CairoMakie">CairoMakie.jl</a> package from  the <a href="https://docs.makie.org">Makie</a> visualization ecosystem. If you haven&#39;t installed them  yet, you may need to do so. Additionally, we explicitly activate the CairoMakie backend to  ensure it is used, especially if another backend was previously active in the same session.</p><pre><code class="language-julia hljs">using CairoMakie, DelimitedFiles, JuChrom
CairoMakie.activate!()

filename = &quot;example1.CAL&quot;
file = joinpath(JuChrom.calibration, filename)
data_cells = readdlm(file; header=false)  # set header=true if the file contains a header</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30×5 Matrix{Any}:
  4.154   900.0   98  1478  &quot;Nonane&quot;
  5.635  1000.0  100  1215  &quot;Decane&quot;
  7.145  1100.0   95  1606  &quot;Undecane&quot;
  8.628  1200.0  100  1762  &quot;Dodecane&quot;
 10.043  1300.0  100  1782  &quot;Tridecane&quot;
 11.39   1400.0   91  1909  &quot;Tetradecane&quot;
 12.667  1500.0   96  1956  &quot;Pentadecane&quot;
 13.877  1600.0  100  1925  &quot;Hexadecane&quot;
 14.876  1700.0   99  2029  &quot;Heptadecane&quot;
 15.608  1800.0   95  2021  &quot;Octadecane&quot;
  ⋮                         
 21.026  3000.0   86  1742  &quot;Triacontane&quot;
 21.83   3100.0   93  1134  &quot;Hentriacontane&quot;
 22.807  3200.0   92  1105  &quot;Dotriacontane&quot;
 23.991  3300.0   94  1020  &quot;Tritriacontane&quot;
 25.435  3400.0   92   920  &quot;Tetratriacontane&quot;
 27.204  3500.0   90   819  &quot;Pentatriacontane&quot;
 29.366  3600.0   91   723  &quot;Hexatriacontane&quot;
 32.026  3700.0   88   602  &quot;Heptatriacontane&quot;
 35.273  3800.0   85   493  &quot;Octatriacontane&quot;</code></pre><p>The output above displays the contents of the matrix referred to by the variable  <code>data_cells</code> at this point. We will use slice notation to extract the values from the  first and second columns. Additionally, we will convert these values to <code>Float64</code> and  append the minute time unit to the retention time values. The following two lines of code  will achieve this:</p><pre><code class="language-julia hljs">rts = convert(Vector{Float64}, data_cells[:, 1]) * u&quot;minute&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:
  4.154 minute
  5.635 minute
  7.145 minute
  8.628 minute
 10.043 minute
 11.39 minute
 12.667 minute
 13.877 minute
 14.876 minute
 15.608 minute
  ⋮
 21.026 minute
 21.83 minute
 22.807 minute
 23.991 minute
 25.435 minute
 27.204 minute
 29.366 minute
 32.026 minute
 35.273 minute</code></pre><pre><code class="language-julia hljs">ris = convert(Vector{Float64}, data_cells[:, 2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30-element Vector{Float64}:
  900.0
 1000.0
 1100.0
 1200.0
 1300.0
 1400.0
 1500.0
 1600.0
 1700.0
 1800.0
    ⋮
 3000.0
 3100.0
 3200.0
 3300.0
 3400.0
 3500.0
 3600.0
 3700.0
 3800.0</code></pre><p>We can now create a <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> object by calling its constructor with the required  arguments, along with any optional ones if needed. The mandatory arguments include the  name of the retention index (in our case,  <a href="https://en.wikipedia.org/wiki/Kovats_retention_index">Kovats</a>), the retention time, and  the corresponding retention indices. In this example, we also store the name of the  calibration file as <a href="../../man/basics/#JuChrom.metadata-Tuple{AbstractChromatogram}"><code>metadata</code></a>.</p><pre><code class="language-julia hljs">ld = RiMapper(&quot;Kovats&quot;, rts, ris, metadata=Dict(:filename =&gt; filename))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RiMapper {index name: Kovats, calibration points: 30}
retention time range: 4.154 minute - 35.273 minute
retention index range: 900.0 - 3800.0
interpolation method: NaturalCubicBSpline(false)
extrapolation method: nothing
metadata: 1 entry</code></pre><p>Since we did not explicitly specify an interpolation method,  the constructor defaulted to <a href="../../man/retentionindices/#JuChrom.NaturalCubicBSpline"><code>NaturalCubicBSpline</code></a> for interpolation.</p><p>We now have a <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> object that allows us to calculate the  <a href="../../man/massspectra/#JuChrom.retentionindex-Tuple{AbstractMassSpectrum}"><code>retentionindex</code></a> for a given retention time of interest. We&#39;ll use this to plot  the mapping function. Since we will be plotting additional mapping functions, we&#39;ll  encapsulate the code for plotting the mapping function into a reusable function that can  be called multiple times.</p><pre><code class="language-julia hljs">function plotmappingfunction(ld::RiMapper, outputfile::AbstractString)
  # Create figure
  f = Figure(; size=(1200, 600))

  # Create axis in figure, including informative title and axis labels
  title = get(metadata(ld), :filename, &quot;&quot;)
  ri_name = retentionindexname(ld)
  timeunit = unit(eltype(retentiontimes(ld)))
  ax = Axis(f[1,1], title=title, xlabel=&quot;Scan time [$timeunit]&quot;,
    ylabel=&quot;$ri_name retention index&quot;)

  # Plot calibration points
  cal = scatter!(ax, retentiontimes(ld, ustripped=true), retentionindices(ld), color=:red)

  # Plot interpolated values
  xs = LinRange(minretentiontime(ld), maxretentiontime(ld), 1000)
  itp = lines!(ax, ustrip(xs), retentionindex.(ld, xs), color=:blue)

  # Add an informative legend
  axislegend(ax, [cal, itp], [&quot;calibration points&quot;, &quot;interpolation&quot;], position = :lt,
    orientation = :horizontal)

  # Save figure in svg file format
  save(outputfile, f)
end

plotmappingfunction(ld, &quot;rt2ri.svg&quot;)</code></pre><p>This will produce the following  <a href="https://en.wikipedia.org/wiki/SVG">Scalable Vector Graphics (SVG)</a> file:</p><p><img src="../rt2ri.svg" alt/></p><h2 id="Example-2:-Calibration-Points-from-an-Excel-File"><a class="docs-heading-anchor" href="#Example-2:-Calibration-Points-from-an-Excel-File">Example 2: Calibration Points from an Excel File</a><a id="Example-2:-Calibration-Points-from-an-Excel-File-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Calibration-Points-from-an-Excel-File" title="Permalink"></a></h2><p>In this example, we assume that a set of calibration points for calculating the  <a href="https://en.wikipedia.org/wiki/Kovats_retention_index">Kovats retention index</a>  has been stored in an Excel file, possibly as a result of a manual entry. The relevant  data can be found in the first sheet of the file <code>example1.xlsx</code>, named <code>Table1</code>. </p><p>We will use the <a href="https://github.com/felipenoris/XLSX.jl">XLSX.jl</a> package to read the  contents of the Excel file. As in the previous example, we need to assign the time values a  unit of minutes. To accomplish this, we will import  <a href="https://github.com/oniehuis/JuChrom.jl">JuChrom.jl</a>, which re-exports functionality from  the <a href="https://painterqubits.github.io/Unitful.jl">Unitful.jl</a> package.</p><pre><code class="language-julia hljs">using JuChrom
import XLSX

filename = &quot;example1.xlsx&quot;
file = joinpath(JuChrom.calibration, filename)
sheetname = &quot;Table1&quot;
excel_cells = &quot;A1:B30&quot;

data_cells = XLSX.readdata(file, sheetname, excel_cells)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30×2 Matrix{Any}:
  4.154   900
  5.635  1000
  7.145  1100
  8.628  1200
 10.043  1300
 11.39   1400
 12.667  1500
 13.877  1600
 14.876  1700
 15.608  1800
  ⋮      
 21.026  3000
 21.83   3100
 22.807  3200
 23.991  3300
 25.435  3400
 27.204  3500
 29.366  3600
 32.026  3700
 35.273  3800</code></pre><p>The output above shows the contents of the matrix stored in the variable <code>data_cells</code> at  this point. As in the previous example, we will use slice notation to extract the values  from the first and second columns, convert them to <code>Float64</code>, and append the minute time  unit to the retention time values.</p><pre><code class="language-julia hljs">timeunit = u&quot;minute&quot;
rts = convert(Vector{Float64}, data_cells[:, 1]) * timeunit
ris = convert(Vector{Float64}, data_cells[:, 2])
ld = RiMapper(&quot;Kovats&quot;, rts, ris, metadata=Dict(:filename =&gt; filename))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RiMapper {index name: Kovats, calibration points: 30}
retention time range: 4.154 minute - 35.273 minute
retention index range: 900.0 - 3800.0
interpolation method: NaturalCubicBSpline(false)
extrapolation method: nothing
metadata: 1 entry</code></pre><p>We could reuse the plotting function from the first example to visualize the data. However,  we will refrain from doing so here, as the values in the Excel file are identical to those  in the delimited file. Instead, we will discuss an example where the imported calibration  points result in an error when inferring a <a href="../../man/retentionindices/#JuChrom.NaturalCubicBSpline"><code>NaturalCubicBSpline</code></a> interpolant.</p><h2 id="Example-3:-Error-in-Inferring-NaturalCubicBSpline-Interpolant"><a class="docs-heading-anchor" href="#Example-3:-Error-in-Inferring-NaturalCubicBSpline-Interpolant">Example 3: Error in Inferring NaturalCubicBSpline Interpolant</a><a id="Example-3:-Error-in-Inferring-NaturalCubicBSpline-Interpolant-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Error-in-Inferring-NaturalCubicBSpline-Interpolant" title="Permalink"></a></h2><p>In the two previous examples, the computation of a natural cubic B-spline for calculating a  continuously increasing retention index worked as expected. However, this is not always  the case. If the computed B-spline contains critical points that would cause the retention  index to decrease as retention time increases, the creation of the <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> would  result in an error. Let&#39;s examine an example. The contents of the file <code>example2.CAL</code> are  as follows:</p><pre><code class="nohighlight hljs">3.394 600.0 100 742 Hexane
4.154 900.0 98 1478 Nonane
5.635 1000.0 100 1215 Decane
7.145 1100.0 95 1606 Undecane
8.628 1200.0 100 1762 Dodecane
  ⋮
25.435 3400.0 92 920 Tetratriacontane
27.204 3500.0 90 819 Pentatriacontane
29.366 3600.0 91 723 Hexatriacontane
32.026 3700.0 88 602 Heptatriacontane
35.273 3800.0 85 493 Octatriacontane</code></pre><p>The data is similar to that in <code>example1.CAL</code>, with the only difference being that  <code>example2.CAL</code> includes the retention time and retention index of Hexane as an additional  calibration point. We&#39;ll run the same commands as in the previous example, but this time,  we&#39;ll specify a different input file and wrap the <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> call in a <code>try</code>/ <code>catch</code> block to handle any exceptions.</p><pre><code class="language-julia hljs">using CairoMakie, DelimitedFiles, JuChrom
CairoMakie.activate!()

filename = &quot;example2.CAL&quot;
file = joinpath(JuChrom.calibration, filename)
data_cells = readdlm(file; header=false)

rts = convert(Vector{Float64}, data_cells[:, 1]) * u&quot;minute&quot;
ris = convert(Vector{Float64}, data_cells[:, 2])

try
  global ld = RiMapper(&quot;Kovats&quot;, rts, ris, metadata=Dict(:filename =&gt; filename))
catch e
  println(e)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ArgumentError(&quot;computed Bspline contains critical point(s): [5.128030033274248, 5.526092831780077] * minute&quot;)</code></pre><p>As shown in the output, the creation of a natural cubic B-spline that predicts  continuously increasing retention indices with increasing retention time has failed.  However, we can still force the B-spline interpolator to be returned, even if it contains  critical points. This is achieved by explicitly specifying <a href="../../man/retentionindices/#JuChrom.NaturalCubicBSpline"><code>NaturalCubicBSpline</code></a>  as interpolator method and setting the <code>force</code> option in its keyword argument to <code>true</code>.  This approach can be useful for identifying problematic or erroneous calibration points.  Let&#39;s give it a try.</p><pre><code class="language-julia hljs">ld = RiMapper(&quot;Kovats&quot;, rts, ris, metadata=Dict(:filename =&gt; filename),
  interpolationmethod=NaturalCubicBSpline(force=true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RiMapper {index name: Kovats, calibration points: 31}
retention time range: 3.394 minute - 35.273 minute
retention index range: 600.0 - 3800.0
interpolation method: NaturalCubicBSpline(true)
extrapolation method: nothing
metadata: 1 entry</code></pre><p>Let&#39;s use the returned <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> object to plot the compromised mapping function  using the code from the previous example.</p><pre><code class="language-julia hljs"># &lt;- Insert plotmappingfunction code here
plotmappingfunction(ld, &quot;rt2ri_2.svg&quot;)</code></pre><p>This will produce the following  <a href="https://en.wikipedia.org/wiki/SVG">Scalable Vector Graphics (SVG)</a> file:</p><p><img src="../rt2ri_2.svg" alt/></p><p>As observed, the sharp increase in the retention index between 3.394 and 4.154 minutes  prompted the creation of a B-spline featuring two critical points: a local maximum at  5.128 minutes and a local minimum at 5.526 minutes. This outcome is not due to Hexane  being incorrectly identified or associated with an incorrect retention time. Instead,  the pronounced disparity in the retention time–retention index relationship in the first  segment of the B-spline, compared to the following segments, causes the B-spline to  oscillate. This oscillation suggests that the available set of calibration points at the  start of the run is insufficient for reliable prediction of retention indices in this  region using the chosen interpolation method. It is entirely possible that a denser  sampling of calibration points at the beginning of the run could resolve this issue,  particularly given the large RI interval between Hexane and Nonane compared to subsequent  calibration points. </p><p>If the <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> is intended to interpolate values between, for example, minutes  10 and 30, the simplest solution might be to omit this calibration point. Alternatively,  one could choose the <a href="../../man/retentionindices/#JuChrom.PiecewiseLinear"><code>PiecewiseLinear</code></a> interpolation method, which avoids  oscillations. However, it introduces discontinuities in its derivative, making it a less  desirable interpolation method.</p><h2 id="Example-4:-Plotting-TIC-against-RI"><a class="docs-heading-anchor" href="#Example-4:-Plotting-TIC-against-RI">Example 4: Plotting TIC against RI</a><a id="Example-4:-Plotting-TIC-against-RI-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Plotting-TIC-against-RI" title="Permalink"></a></h2><p>It is often preferred to plot chromatographic intensity values against retention index  values rather than scan time. This requires chromatographic run data and corresponding  calibration data, which allow the calculation of an RiMapper for converting retention  times into retention indices. </p><p>Let&#39;s assume we wish to plot total ion chromatogram (TIC) intensities from a gas  chromatography/mass spectrometry (GCMS) run against  <a href="https://en.wikipedia.org/wiki/Kovats_retention_index">Kovats retention index</a> values.  In this example, the run file is stored in the <a href="../../man/import/#JuChrom.InputOutput.ChemStationMSReaders.ChemStationMS"><code>ChemStationMS</code></a> data format in the  folder <code>ON16150_April17_2024_I.D</code>. The corresponding calibration file,  <code>2024-04-11_C7-C40_11_APR_24_V09.CAL</code>, contains retention time and retention index value  pairs in the <a href="https://chemdata.nist.gov/dokuwiki/doku.php?id=chemdata:amdis">AMDIS</a> .CAL  file format (see Examples 1 and 3 above).</p><p>To load the calibration file data, we will again use the  <a href="https://github.com/JuliaData/DelimitedFiles.jl">DelimitedFiles.jl</a> package, which comes  with <a href="https://julialang.org">Julia</a>. We will need the  <a href="https://github.com/oniehuis/JuChrom.jl">JuChrom.jl</a> package to read the ChemStation MS  run data and to process and apply the calibration file data. Finally, we will use the  <a href="https://github.com/MakieOrg/Makie.jl/tree/master/CairoMakie">CairoMakie.jl</a> package to  generate the desired figure. Note that you may need to install these packages if  you haven&#39;t done so already.</p><p>We begin by reading and processing the calibration file data to create an  <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> object, following the general procedure outlined in Example 1.</p><pre><code class="language-julia hljs">using CairoMakie, DelimitedFiles, JuChrom
CairoMakie.activate!()

calpath = joinpath(JuChrom.calibration, &quot;empirical_data&quot;, &quot;calfiles&quot;)
calfile = joinpath(calpath, &quot;2024-04-11_C7-C40_11_APR_24_V09.CAL&quot;)

cells = readdlm(calfile; header=false)
rts = convert(Vector{Float64}, cells[:, 1]) * u&quot;minute&quot;
ris = convert(Vector{Float64}, cells[:, 2])
ld = RiMapper(&quot;Kovats&quot;, rts, ris)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RiMapper {index name: Kovats, calibration points: 30}
retention time range: 4.154 minute - 35.273 minute
retention index range: 900.0 - 3800.0
interpolation method: NaturalCubicBSpline(false)
extrapolation method: nothing
metadata: 0 entries</code></pre><p>As indicated by the output, the computation of the <a href="../../man/retentionindices/#JuChrom.RiMapper"><code>RiMapper</code></a> was successful (refer  to Example 3 for handling errors). We can now proceed with reading and processing the GCMS  run data.</p><pre><code class="language-julia hljs">runpath = joinpath(JuChrom.calibration, &quot;empirical_data&quot;, &quot;runs&quot;)
runfolder = joinpath(runpath, &quot;ON16150_April17_2024_I.D&quot;)
chrom = importdata(runfolder, ChemStationMS())
rimapper!(chrom, ld)  # stores a reference to the RiMapper in ChromMS object
tic = totalionchromatogram(chrom)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chrom {scan times: Float32, intensities: Int64}
2405 scans; scan time range: 191944.0f0 ms - 1.89905f6 ms
intensity range: 35402 - 16107576
metadata: 10 entries
retention index mapper: Kovats</code></pre><p>We now have everything set to generate the desired figure. In this specific example, we  only map intensities at retention times that fall within the range of the calibration  points, avoiding the extrapolation of retention indices. Additionally, we allow further  restriction of the retention index range to be plotted in the figure.</p><pre><code class="language-julia hljs">ri_min, ri_max = 900, 1800

f = Figure(size=(1200, 600))
ax = Axis(f[1,1], xlabel=&quot;Kovats retention index&quot;, ylabel=&quot;Abundance&quot;)
ris, ints = [], []
for i in 1:scancount(tic)
  rt = scantime(tic, i)
  if minretentiontime(ld) ≤ rt ≤ maxretentiontime(ld)
    ri = retentionindex(rimapper(tic), rt)
    ri_min ≤ ri ≤ ri_max || continue
    push!(ris, ri)
    push!(ints, intensity(tic, i))
  end
end
length(ris) ≥ 2 &amp;&amp; lines!(ax, ris, ints, color=:blue)

save(&quot;tic_against_ri.svg&quot;, f)</code></pre><p>This will produce the following <a href="https://en.wikipedia.org/wiki/SVG">SVG</a> file:</p><p><img src="../tic_against_ri.svg" alt/></p><h2 id="Example-5:-Plotting-multiple-TICs-against-RI"><a class="docs-heading-anchor" href="#Example-5:-Plotting-multiple-TICs-against-RI">Example 5: Plotting multiple TICs against RI</a><a id="Example-5:-Plotting-multiple-TICs-against-RI-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-Plotting-multiple-TICs-against-RI" title="Permalink"></a></h2><p>In some experimental designs, it is useful to plot the intensity values of different runs  against retention index values in a single figure. In this example, we assume two treatment  groups, labeled <code>I</code> and <code>R</code>, with two replicates for each group. The experimental data were  analyzed using gas chromatography/mass spectrometry (GCMS).</p><p>We aim to plot the total ion chromatogram (TIC) intensities from the corresponding GCMS  runs against Kovats retention indices. In this example, the run files are again stored in  the ChemStationMS data format. The corresponding calibration files, which contain retention  time and retention index value pairs, are in the  <a href="https://chemdata.nist.gov/dokuwiki/doku.php?id=chemdata:amdis">AMDIS</a> .CAL file format  (see Examples 1, 3, and 4 above). To automatically process this data, we need a table  indicating which calibration file is associated with each run. This information is stored  in the <code>run_calfilename_relation.xlsx</code> file in Excel format.</p><p>As in Example 4, we require functionality from the  <a href="https://github.com/MakieOrg/Makie.jl/tree/master/CairoMakie">CairoMakie.jl</a>,  <a href="https://github.com/JuliaData/DelimitedFiles.jl">DelimitedFiles.jl</a>, and  <a href="https://github.com/oniehuis/JuChrom.jl">JuChrom.jl</a> packages. Additionally, we need the  <a href="https://github.com/felipenoris/XLSX.jl">XLSX.jl</a> package to read the Excel file. Note that  you need to install these packages if they are not already installed.</p><p>The relevant data in the Excel file is located in the sheet labeled <code>Table1</code>. Column <code>A</code>  contains the names of the run folders, and column <code>B</code> contains the names of the  corresponding .CAL files. Since we have four runs and no headers, the area of interest  is A1:B4. We&#39;ll read these cells and store the data in a dictionary, using the run names  as keys to retrieve the associated .CAL file names.</p><pre><code class="language-julia hljs">using CairoMakie, DelimitedFiles, JuChrom
CairoMakie.activate!()
import XLSX

file = joinpath(JuChrom.calibration, &quot;empirical_data&quot;, &quot;run_calfilename_relation.xlsx&quot;)
data_cells = XLSX.readdata(file, &quot;Table1&quot;, &quot;A1:B4&quot;)
cal4run = Dict(data_cells[row, 1] =&gt; data_cells[row, 2] for row in axes(data_cells, 1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 4 entries:
  &quot;ON16154_May28_2024_R.D&quot;   =&gt; &quot;2024-05-28_C7-C40_28_MAY_24_V04.CAL&quot;
  &quot;ON16150_April17_2024_I.D&quot; =&gt; &quot;2024-04-11_C7-C40_11_APR_24_V09.CAL&quot;
  &quot;ON16150_April17_2024_R.D&quot; =&gt; &quot;2024-04-11_C7-C40_11_APR_24_V09.CAL&quot;
  &quot;ON16154_May28_2024_I.D&quot;   =&gt; &quot;2024-05-28_C7-C40_28_MAY_24_V04.CAL&quot;</code></pre><p>Since two runs are associated with each .CAL file, it makes sense to first process the  .CAL files and create a dictionary from which we can retrieve the <code>RiMapper</code> generated from  a given .CAL file.</p><pre><code class="language-julia hljs">mpr4cal = Dict()
for calfilename in unique(values(cal4run))
  calfile = joinpath(JuChrom.calibration, &quot;empirical_data&quot;, &quot;calfiles&quot;, calfilename)
  cells = readdlm(calfile; header=false)
  rts = convert(Vector{Float64}, cells[:, 1]) * u&quot;minute&quot;
  ris = convert(Vector{Float64}, cells[:, 2])
  mpr4cal[calfilename] = RiMapper(&quot;Kovats&quot;, rts, ris)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any} with 2 entries:
  &quot;2024-04-11_C7-C40_11_APR_24_V09.CAL&quot; =&gt; RiMapper {index name: Kovats, calibr…
  &quot;2024-05-28_C7-C40_28_MAY_24_V04.CAL&quot; =&gt; RiMapper {index name: Kovats, calibr…</code></pre><p>Next, we read the GCMS data and store a reference to the corresponding RiMapper object  in the resulting ChromMS object. The ChromMS objects are then collected in a list for  further processing.</p><pre><code class="language-julia hljs">chroms = []
for run in keys(cal4run)
  runfolder = joinpath(JuChrom.calibration, &quot;empirical_data&quot;, &quot;runs&quot;, run)
  chrom = importdata(runfolder, ChemStationMS())
  rimapper!(chrom, mpr4cal[cal4run[run]])
  push!(chroms, chrom)
end</code></pre><p>We now have all the data needed to generate a figure that plots the TIC from each run  against the <a href="https://en.wikipedia.org/wiki/Kovats_retention_index">Kovats retention index</a>.  Since the plotted lines will overlap, we will make them transparent by setting the alpha  channel to a value less than one. The treatment group is indicated by the letters <code>I</code> and  <code>R</code> at the end of the run folder name, which is stored in the <a href="../../man/basics/#JuChrom.metadata-Tuple{AbstractChromatogram}"><code>metadata</code></a>. We will  use this information to plot the TICs of the two groups in different colors.</p><pre><code class="language-julia hljs">ri_min, ri_max = 900, 1800
alpha = 0.5

f = Figure(size=(1200, 600))
ax = Axis(f[1,1], xlabel=&quot;Kovats retention index&quot;, ylabel=&quot;Abundance&quot;)
for chrom in chroms
  tic = totalionchromatogram(chrom)
  ld = rimapper(tic)
  ris, ints = [], []
  for i in 1:scancount(tic)
    rt = scantime(tic, i)
    if minretentiontime(ld) ≤ rt ≤ maxretentiontime(ld)
      ri = retentionindex(rimapper(tic), rt)
      ri_min ≤ ri ≤ ri_max || continue
      push!(ris, ri)
      push!(ints, intensity(tic, i))
    end
  end
  if length(ris) ≥ 2
    c = endswith(metadata(tic)[:sample], &quot;R&quot;) ? (:blue, alpha) : (:red, alpha)
    lines!(ax, ris, ints, color=c)
  end
end

save(&quot;tics_in_one_axis.svg&quot;, f)</code></pre><p>This will produce the following <a href="https://en.wikipedia.org/wiki/SVG">SVG</a> file:</p><p><img src="../tics_in_one_axis.svg" alt/></p><p>Although the TICs for the two treatment groups are plotted in different colors, it can  still be difficult to visually discern systematic differences between them. Furthermore,  if each treatment group contains more runs, the plot can become cluttered and overloaded.  Therefore, it may be helpful to plot the TICs for the two treatment groups on separate,  mirrored axes along the x-axis. The following lines of code generate such a figure.</p><pre><code class="language-julia hljs">ri_min, ri_max = 900, 1800
alpha = 0.5

f2 = Figure(size=(1200, 600))
ax1 = Axis(f2[1,1], limits = (nothing, nothing, 0, nothing), ylabel=&quot;Abundance&quot;)
ax2 = Axis(f2[2,1], limits = (nothing, nothing, 0, nothing),
  xlabel=&quot;Kovats retention index&quot;, ylabel=&quot;Abundance&quot;, yreversed=true)

linkxaxes!(ax1, ax2)
rowgap!(f2.layout, 0)
hidexdecorations!(ax1, grid=false)

for chrom in chroms
  tic = totalionchromatogram(chrom)
  ris, ints = [], []
  for i in 1:scancount(tic)
    rt = scantime(tic, i)
    if minretentiontime(rimapper(tic)) ≤ rt ≤ maxretentiontime(rimapper(tic))
      ri = retentionindex(rimapper(tic), rt)
      ri_min ≤ ri ≤ ri_max || continue
      push!(ris, ri)
      push!(ints, intensity(tic, i))
    end
  end
  if length(ris) ≥ 2
    if endswith(metadata(chrom)[:sample], &quot;R&quot;)
      lines!(ax1, ris, ints, color=(:blue, alpha))
    else
      lines!(ax2, ris, ints, color=(:red, alpha))
    end
  end
end

save(&quot;tics_in_two_axes.svg&quot;, f2)</code></pre><p>This will produce the following <a href="https://en.wikipedia.org/wiki/SVG">SVG</a> file:</p><p><img src="../tics_in_two_axes.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../internals/inputoutput/">« InputOutput</a><a class="docs-footer-nextpage" href="../../man/register/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 24 April 2025 07:21">Thursday 24 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
