var documenterSearchIndex = {"docs":
[{"location":"man/register/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/register/","page":"Index","title":"Index","text":"","category":"page"},{"location":"man/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/basics/#JuChrom.AbstractChromatogram","page":"Basics","title":"JuChrom.AbstractChromatogram","text":"AbstractChromatogram\n\nSupertype for all chromatogram implementations. All subtypes (e.g., Chrom, ChromMS)  include scan times and intensities and, optionally, metadata and a retention index mapper.\n\nSee also AbstractChrom, AbstractChromMS, ChromMS, Chrom,  scantimes, intensities, metadata, rimapper,.\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.AbstractChrom","page":"Basics","title":"JuChrom.AbstractChrom","text":"AbstractChrom <: AbstractChromatogram\n\nSupertype for all chromatogram implementations that have a single intensity value  associated with each scan time (e.g., Chrom). The intensities are stored in a vector, with  the index corresponding to the scan time index.\n\nSee also AbstractChromatogram, Chrom, scantimes,  intensities, metadata, rimapper, .\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.AbstractChromMS","page":"Basics","title":"JuChrom.AbstractChromMS","text":"AbstractChromMS <: AbstractChromatogram\n\nSupertype for all chromatogram implementations that include mass-charge ratio (m/z)  data (ions) and associated abundance values (intensities) (e.g., ChromMS). This type can  have one or more ion intensity values associated with a given scan time. Intensities are  stored in a matrix where the row index represents the scan time and the column index  represents the ion.\n\nSee also AbstractChromatogram, AbstractChromMS, ChromMS,  scantimes, ions, intensities, metadata,  rimapper.\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.ChromMS","page":"Basics","title":"JuChrom.ChromMS","text":"ChromMS(scantimes::AbstractVector{<:Unitful.Time}, ions::AbstractVector{<:Real}, \nintensities::AbstractMatrix{<:Real}; metadata::Dict=Dict{Any, Any}(), \nrimapper::Union{AbstractRiMapper, Nothing}=nothing) <: AbstractChromMS\n\nConstruct a ChromMS object that includes scantimes, ions, intensities, and  metadata. Ensure that both scantimes and ions are in ascending order. The scan times  must include a time unit. All time units supported by the  Unitful.jl package  (e.g., u\"s\", u\"minute\") are accepted. You can optionally use the keyword argument  rimapper to include a retention index mapper.\n\nSee also AbstractChromatogram, AbstractChromMS, scantimes,  ions, intensities, metadata.\n\nIn the following examples, the types of scantimes, ions, and intensities are  explicitely annotated to demonstrate that the ChromMS object preserves these types.\n\nExamples\n\njulia> ChromMS(Int32[1, 2, 3]u\"s\", Int64[85, 100], Int32[0 12; 34 956; 23 1])\nChromMS {scan times: Int32, ions: Int64, intensities: Int32}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> ChromMS([1.1f0, 2.1f0]u\"s\", [35.1f0, 76.2f0], Int64[0 12; 34 956], Dict(:id => 4))\nChromMS {scan times: Float32, ions: Float32, intensities: Int64}\n2 scans; scan times: 1.1f0 s, 2.1f0 s\n2 ions: m/z 35.1, 76.2\nintensity range: 0 - 956\nmetadata: 1 entry\n\njulia> ChromMS([2, 1, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nERROR: ArgumentError: scan times not in ascending order\n[...]\n\njulia> ChromMS([1, 2, 3]u\"s\", [100, 85], [0 12; 34 956; 23 1])\nERROR: ArgumentError: ions not in ascending order\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.Chrom","page":"Basics","title":"JuChrom.Chrom","text":"Chrom(scantimes::AbstractVector{<:Unitful.Time}, \nintensities::AbstractVector{<:Real}, metadata::Dict=Dict{Any, Any}; \nrimapper::Union{AbstractRiMapper, Nothing}=nothing) <: AbstractChrom\n\nConstruct a Chrom object that includes scantimes, intensities, and metadata.  Ensure that both scantimes and ions are in ascending order. The scan times must  include a time unit. All time units supported by the  Unitful.jl package (e.g., u\"s\",  u\"minute\") are accepted. You can optionally use the keyword argument rimapper to  include a retention index mapper.\n\nSee also AbstractChromatogram, AbstractChrom, scantimes,  intensities, metadata, rimapper.\n\nIn the following examples, the types of scantimes and intensities are explicitely  annotated to demonstrate that the Chrom object preserves these types.\n\nExamples\n\njulia> Chrom(Int64[1, 2, 3]u\"s\", Int32[12, 956, 1])\nChrom {scan times: Int64, intensities: Int32}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 1 - 956\nmetadata: 0 entries\n\njulia> Chrom(Int32[1, 2, 3]u\"s\", Float64[12.0, 956.0, 1.0], Dict(\"name\" => \"sample\"))\nChrom {scan times: Int32, intensities: Float64}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 1.0 - 956.0\nmetadata: 1 entry\n\njulia> Chrom([2, 1, 3]u\"s\", [12.0, 956.0, 1.0])\nERROR: ArgumentError: scan times not in ascending order\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.IonScanOrder","page":"Basics","title":"JuChrom.IonScanOrder","text":"IonScanOrder\n\nSupertype of all ion scan order implementations.\n\nSee also LinearAscending, LinearDescending, ionscantimeshift,  ionscantimes, ionscantime, ionscantimeindex.\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.LinearAscending","page":"Basics","title":"JuChrom.LinearAscending","text":"LinearAscending(; start::Real=0, stop::Real=1) <: IonScanOrder\n\nConstruct a LinearAscending ion scan order object. This object specifies that ions were  scanned in linear ascending order (i.e., smallest ion first, largest ion last) during each  scan. The time allocated to scan each ion is assumed to be equal, resulting from dividing  the total scan interval time equally among the ions. The optional start and stop  parameters allow you to limit the time interval during which ions were scanned in each  scan. These parameters specify relative points within the scan interval: 0 ≤ start < stop  ≤ 1. The default values are start=0 and stop=1, meaning the scan of the smallest ion  began at the start of the scan interval and the scan of the largest ion concluded at the  end of the interval. In contrast, setting the start value to 0.5 indicates that ions were  scanned only during the second half of the scan interval. For instance, this could occur if  the instrument switched between SIM mode and Scan mode during each scan interval, operating  in Scan mode only during the second half, which generated the data in question.\n\nSee also AbstractChromMS, LinearDescending, ionscantimeshift,  ionscantimes, ionscantime, ionscantimeindex, ions,  minion, maxion, ioncount, scanduration,  scantimes, minscantime, maxscantime.\n\nExamples\n\njulia> LinearAscending()\nLinearAscending{Int64, Int64}(0, 1)\n\njulia> LinearAscending(; start=0.5)\nLinearAscending{Float64, Int64}(0.5, 1)\n\njulia> LinearAscending(; start=0.1, stop=0.5)\nLinearAscending{Float64, Float64}(0.1, 0.5)\n\njulia> LinearAscending(; start=0.5, stop=0.5)\nERROR: ArgumentError: start=0.5 and stop=0.5 do not satisfy condition 0 ≤ start < stop ≤ 1\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.LinearDescending","page":"Basics","title":"JuChrom.LinearDescending","text":"LinearDescending(; start::Real=0, stop::Real=1) <: IonScanOrder\n\nConstruct a LinearDescending ion scan order object. This object specifies that ions were  scanned in linear descending order (i.e., largest ion first, smallest ion last) during each  scan. The time allocated to scan each ion is assumed to be equal, resulting from dividing  the total scan interval time equally among the ions. The optional start and stop  parameters allow you to limit the time interval during which ions were scanned in each  scan. These parameters specify relative points within the scan interval: 0 ≤ start < stop  ≤ 1. The default values are start=0 and stop=1, meaning the scan of the largest ion  began at the start of the scan interval and the scan of the smallest ion concluded at the  end of the interval. In contrast, setting the start value to 0.5 indicates that ions were  scanned only during the second half of the scan interval. For instance, this could occur if  the instrument switched between SIM mode and Scan mode during each scan interval, operating  in Scan mode only during the second half, which generated the data in question.\n\nSee also AbstractChromMS, LinearAscending, ionscantimeshift,  ionscantimes, ionscantime, ionscantimeindex, ions,  minion, maxion, ioncount, scanduration,  scantimes, minscantime, maxscantime.\n\nExamples\n\njulia> LinearDescending()\nLinearDescending{Int64, Int64}(0, 1)\n\njulia> LinearDescending(; start=0.5)\nLinearDescending{Float64, Int64}(0.5, 1)\n\njulia> LinearDescending(; start=0.1, stop=0.5)\nLinearDescending{Float64, Float64}(0.1, 0.5)\n\njulia> LinearDescending(; start=0.5, stop=0.5)\nERROR: ArgumentError: start=0.5 and stop=0.5 do not satisfy condition 0 ≤ start < stop ≤ 1\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.binions","page":"Basics","title":"JuChrom.binions","text":"binions(chrom::ChromMS; ionbin::Function=integer)\n\nReturn a ChromMS object in which the ions are binned according to the ionbin function (the  default is the integer function), and the intensities of the binned ions are summed.\n\nSee also AbstractChromMS, integer, intensities, ions,  ioncount.\n\nExamples\n\njulia> chrom = ChromMS((1:3)u\"s\", [84.8, 85.2, 100.9], [0 24 12; 0 0 956; 23 0 1])\nChromMS {scan times: Int64, ions: Float64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n3 ions: m/z 84.8, 85.2, 100.9\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensities(chrom)\n3×3 Matrix{Int64}:\n  0  24   12\n  0   0  956\n 23   0    1\n\njulia> chrom_binnedions = binions(chrom)\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 101\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> ions(chrom_binnedions)\n2-element Vector{Int64}:\n  85\n 101\n\njulia> intensities(chrom_binnedions)\n3×2 Matrix{Int64}:\n 24   12\n  0  956\n 23    1\n\n\njulia> custom_ionbin(ion) = integer(ion, start=0.9);\n\njulia> chrom_binnedions = binions(chrom, ionbin=custom_ionbin)\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n3 ions: m/z 84, 85, 101\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> ions(chrom_binnedions)\n3-element Vector{Int64}:\n  84\n  85\n 101\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.integer","page":"Basics","title":"JuChrom.integer","text":"integer(value::Real; start::Real=0.7) -> Int\n\nReturn the integer for the given value that satisfies the following condition:  integer - 1 + start ≤ value < integer + start, where 0 ≤ start < 1.\n\nSee also AbstractChromMS, ChromMS, binions, ions.\n\nExamples\n\njulia> integer(29.7)\n30\n\njulia> integer(30.0)\n30\n\njulia> integer(30.69)\n30\n\njulia> integer(29.7, start=0.8)\n29\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.intensities-Union{Tuple{AbstractChrom}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:Integer}","page":"Basics","title":"JuChrom.intensities","text":"intensities(chrom::AbstractChrom; scanindexrange::OrdinalRange{T, S}) where {T<:Integer, \nS<:Integer}\n\nReturn the intensities. The optional keyword argument scanindexrange lets you select a  subset of scans for which the intensities will be returned. Note that the function will  return either a reference to the intensity vector or a view into the intensity vector,  depending on whether a subset of scans is selected.\n\nSee also AbstractChrom, intensity, minintensity,  maxintensity, scancount.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> intensities(chrom)  # reference to the data structure\n3-element Vector{Int64}:\n 123\n 224\n 103\n\njulia> intensities(chrom)[:]  # a copy of these values\n3-element Vector{Int64}:\n 123\n 224\n 103\n\njulia> intensities(chrom; scanindexrange=2:3)  # view into the data structure\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 224\n 103\n\njulia> intensities(chrom; scanindexrange=2:3)[:]  # a copy of these values\n2-element Vector{Int64}:\n 224\n 103\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensities-Union{Tuple{AbstractChromMS}, Tuple{S2}, Tuple{T2}, Tuple{S1}, Tuple{T1}} where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}","page":"Basics","title":"JuChrom.intensities","text":"intensities(chrom::AbstractChromMS; scanindexrange::OrdinalRange{T1, S1}, \nionindexrange::OrdinalRange{T2, S2}) where {T1<:Integer, S1<:Integer, T2<:Integer, \nS2<:Integer}\n\nReturn the intensities. The optional keyword arguments scanindexrange and ionindexrange  allow you to select specific parts of the intensity matrix to be returned. Note that the  function returns either a reference to the matrix or a view into it, depending on whether  the keyword arguments specify subranges of the matrix.\n\nSee also AbstractChromMS, scancount, ioncount,  minintensity, maxintensity.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensities(chrom)  # reference to the data structure\n3×2 Matrix{Int64}:\n  0   12\n 34  956\n 23    1\n\njulia> intensities(chrom)[:, :]  # a copy of these values\n3×2 Matrix{Int64}:\n  0   12\n 34  956\n 23    1\n\njulia> intensities(chrom, ionindexrange=1:1)  # all intensities of the ion at index 1\n3×1 view(::Matrix{Int64}, 1:3, 1:1) with eltype Int64:\n  0\n 34\n 23\n\njulia> intensities(chrom, ionindexrange=1:1)[:]  # a copy of these values\n3-element Vector{Int64}:\n  0\n 34\n 23\n\njulia> intensities(chrom, scanindexrange=1:1)  # intensities of all ions from scan 1\n1×2 view(::Matrix{Int64}, 1:1, 1:2) with eltype Int64:\n 0  12\n\njulia> intensities(chrom, scanindexrange=1:1)[:]  # a copy of these values\n2-element Vector{Int64}:\n  0\n 12\n\njulia> intensities(chrom, scanindexrange=1:2, ionindexrange=1:2)\n2×2 view(::Matrix{Int64}, 1:2, 1:2) with eltype Int64:\n  0   12\n 34  956\n\njulia> intensities(chrom, scanindexrange=1:2, ionindexrange=1:2)[:, :]\n2×2 Matrix{Int64}:\n  0   12\n 34  956\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChrom, Integer}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChrom, scanindex::Integer)\n\nReturn the intensity for a scan by specifying its scanindex.\n\nSee also AbstractChrom, intensities, minintensity,  maxintensity.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> intensity(chrom, 1)\n123\n\njulia> intensity(chrom, 2)\n224\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChrom, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChrom, time::Unitful.Time; precisetime::Bool=false)\n\nReturn the intensity at a given time. All time units defined in the package Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. By default, the intensity associated with the scan whose timestamp is closest  to the given time is returned. In case of a tie, the intensity of the scan with the  later timestamp is used. If the optional parameter precisetime is set to true, the  specified time must exactly match a timestamp in the vector; otherwise, an error is  thrown.\n\nSee also AbstractChrom, intensities, scantimes,  minscantime, maxscantime.\n\nExamples\n\njulia> chrom = Chrom([1.0, 2.0, 3.0]u\"s\", [123, 224, 103])\nChrom {scan times: Float64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> intensity(chrom, 1.5u\"s\")\n224\n\njulia> intensity(chrom, 1u\"s\", precisetime=true)\n123\n\njulia> intensity(chrom, 1.5u\"s\", precisetime=true)\nERROR: ArgumentError: scantime 1.5 s does not exist\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChromMS, Integer, Integer}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChromMS, scanindex::Integer, ionindex::Integer)\n\nReturn the intensity of an ion in a scan, given the scanindex of the scan and the  ionindex of the ion.\n\nSee also AbstractChromMS, scancount, ions, ioncount.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensity(chrom, 2, 1)\n34\n\njulia> intensity(chrom, 1, 2)\n12\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChromMS, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Real}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChromMS, time::Unitful.Time, ion::Real; precisetime::Bool=false)\n\nReturn the intensity of an ion at a given time. All time units defined in the package Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. By default, the intensity associated with the scan whose timestamp is closest  to the given time is returned. In case of a tie, the intensity of the scan with the  later timestamp is used. If the optional parameter precisetime is set to true, the  specified time must exactly match a timestamp in the vector; otherwise, an error is  thrown.\n\nSee also AbstractChromMS, intensities, ions, scantimes.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensity(chrom, 1.9u\"s\", 85)\n34\n\njulia> intensity(chrom, 2.9u\"s\", 85, precisetime=true)\nERROR: ArgumentError: scantime 2.9 s does not exist\n[...]\n\njulia> intensity(chrom, 3u\"s\", 85, precisetime=true)\n23\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ion-Tuple{AbstractChromMS, Integer}","page":"Basics","title":"JuChrom.ion","text":"ion(chrom::AbstractChromMS, ionindex::Integer)\n\nReturn the ion at the specified ionindex.\n\nSee also AbstractChromMS, ions, ionindex, minion,  maxion, ioncount.\n\nExamples\n\njulia> chrom = ChromMS((1:3)u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> ion(chrom, 1)\n85\n\njulia> ion(chrom, 2)\n100\n\njulia> ion(chrom, 3)\nERROR: BoundsError: attempt to access 2-element Vector{Int64} at index [3]\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ioncount-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.ioncount","text":"ioncount(chrom::AbstractChromMS) -> Int\n\nReturn the number of ions.\n\nSee also AbstractChromMS, ions, ion, minion,  maxion.\n\nExample\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> ioncount(chrom)\n2\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ionindex-Tuple{AbstractChromMS, Real}","page":"Basics","title":"JuChrom.ionindex","text":"ionindex(chrom::AbstractChromMS, ion::Real) -> Int\n\nReturn the index of the specified ion. An error is thrown if the ion does not exist.\n\nSee also AbstractChromMS, ions, ioncount, ion,  minion, maxion, ionscantime, ionscantimeshift.\n\nExamples\n\njulia> chrom = ChromMS((1:3)u\"s\", [85.2f0, 100.1f0], [0 12; 34 956; 23 1]);\n\njulia> ionindex(chrom, 100.1)\n2\n\njulia> ionindex(chrom, 201.1)\nERROR: ArgumentError: ion 201.1 does not exist\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ionscantime","page":"Basics","title":"JuChrom.ionscantime","text":"ionscantime(δtᵢ::Function, chrom::AbstractChromMS, scanindex::Integer, ionindex::Integer; \ntimeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the time at which an ion was actually scanned, given the scanindex, ionindex,  and a function δtᵢ that computes the time difference between the timestamp of a scan and  the scan time of the ion from the ionindex. The optional parameter timeunit allows you  to specify the unit of the returned scan time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether the unit is  included in the returned value. Note that the timestamp of a scan is assumed to be the time  when the scanning of ion intensities associated with that scan was completed.\n\nSee also AbstractChromMS, scantimes, scantime,  scantimeindex, ions, ionindex, ionscantimeshift,  IonScanOrder, LinearAscending, LinearDescending.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> ionscantime(δtᵢ, chrom, 2, 1)\n2.0 s\n\njulia> ionscantime(δtᵢ, chrom, 2, 2)\n1.5 s\n\njulia> ionscantime(δtᵢ, chrom, 2, 2; timeunit=u\"minute\")\n0.025 minute\n\njulia> ionscantime(δtᵢ, chrom, 2, 2; timeunit=u\"minute\", ustripped=true)\n0.025\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ionscantimeindex","page":"Basics","title":"JuChrom.ionscantimeindex","text":"ionscantimeindex(δtᵢ::Function, chrom::AbstractChromMS, ionindex::Integer, \ntime::Unitful.Time; precisetime::Bool=false) -> Int\n\nReturn the index of the scan where the scan time for the ion is closest to the specified  time, given the ionindex and a function δtᵢ that computes the time difference between  the timestamp of a scan and the scan time of the ion from the ionindex. All time units  defined in the package Unitful.jl (e.g.,  u\"s\", u\"minute\") are supported. In case of a tie, the larger scan index is returned.  If the optional parameter precisetime is set to true, the ion must have been scanned  exactly at the specified time; otherwise, an error is thrown.\n\nSee also AbstractChromMS, scantimeindex, ionscantime,  ionscantimeshift, IonScanOrder, LinearAscending,  LinearDescending, scantimes, scantime, ions,  ion, ionindex.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> ionscantime(δtᵢ, chrom, 2, 2)\n1.5 s\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.5u\"s\")\n2\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.6u\"s\")\n2\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.6u\"s\", precisetime=true)\nERROR: ArgumentError: ion has not been scanned at the time 1.6 s\n[...]\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.5u\"s\", precisetime=true)\n2\n\njulia> ionscantimeindex(δtᵢ, chrom, 1, 1.4u\"s\")\n1\n\njulia> ionscantime(δtᵢ, chrom, 1, 1)\n1.0 s\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ionscantimes","page":"Basics","title":"JuChrom.ionscantimes","text":"ionscantimes(δtᵢ::Function, chrom::AbstractChromMS, ionindex::Integer; \ntimeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the times at which an ion was actually scanned, given the ionindex and a function  δtᵢ that computes the time difference between the timestamp of a scan and the scan time  of the ion from the ionindex. The optional parameter timeunit allows you to specify the  unit for the returned scan times. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value. Note that the timestamp of a scan is assumed to be the time  when the scanning of ion intensities associated with that scan was completed.\n\nSee also AbstractChromMS, ionscantime, ionscantimeshift,  IonScanOrder, LinearAscending, LinearDescending,  scantimes, scantimeindex, ions, ionindex.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> ionscantimes(δtᵢ, chrom, 1)\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 1.0 s\n 2.0 s\n 3.0 s\n\njulia> ionscantimes(δtᵢ, chrom, 2)\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 0.5 s\n 1.5 s\n 2.5 s\n\njulia> ionscantimes(δtᵢ, chrom, 2; timeunit=u\"minute\")\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 0.008333333333333333 minute\n                0.025 minute\n 0.041666666666666664 minute\n\njulia> ionscantimes(δtᵢ, chrom, 2; timeunit=u\"minute\", ustripped=true)\n3-element Vector{Float64}:\n 0.008333333333333333\n 0.025\n 0.041666666666666664\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ionscantimeshift","page":"Basics","title":"JuChrom.ionscantimeshift","text":"ionscantimeshift(chrom::AbstractChromMS, ionscanorder::IonScanOrder; error::Real=0.001)\n\nReturn a function, based on the ionscanorder, that calculates the time difference between  the timestamp of a scan and the time when an ion was actually scanned, given the ion index  as an argument. The time difference will be zero or negative, since the timestamp of a scan  is considered to be when the scanning of the last ion was completed. The returned function  assumes that the duration of each scan is consistent throughout the run. The optional  keyword argument error lets you specify the maximum allowed deviation of the scan  duration, as a fraction of the average scan time, between the timestamps of two consecutive  scans.\n\nSee also AbstractChromMS, IonScanOrder, LinearAscending,  LinearDescending, ionscantime, ions, minion,  maxion, ioncount, scanduration, scantimes,  minscantime, maxscantime.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearAscending());\n\njulia> δtᵢ(1)\n-0.5 s\n\njulia> δtᵢ(2)\n0.0 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> δtᵢ(1)\n0.0 s\n\njulia> δtᵢ(2)\n-0.5 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending(start=0.5));\n\njulia> δtᵢ(1)\n0.0 s\n\njulia> δtᵢ(2)\n-0.25 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending(stop=0.5));\n\njulia> δtᵢ(1)\n-0.5 s\n\njulia> δtᵢ(2)\n-0.75 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending(start=0.25, stop=0.75));\n\njulia> δtᵢ(1)\n-0.25 s\n\njulia> δtᵢ(2)\n-0.5 s\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ions-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.ions","text":"ions(chrom::AbstractChromMS)\n\nReturn the ions.\n\nSee also AbstractChromMS, ioncount, ion, minion,  maxion, ionindex, ionscantime, ionscantimeshift. \n\nIn the following examples, the type of ions is explicitely annotated to demonstrate that  the ChromMS object preserves this type.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", Int64[85, 100], [0 12; 34 956; 23 1]);\n\njulia> ions(chrom)\n2-element Vector{Int64}:\n  85\n 100\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", Float32[85, 100], [0 12; 34 956; 23 1]);\n\njulia> ions(chrom)\n2-element Vector{Float32}:\n  85.0\n 100.0\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxintensity-Union{Tuple{AbstractChrom}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:Integer}","page":"Basics","title":"JuChrom.maxintensity","text":"maxintensity(chrom::AbstractChrom[; scanindexrange::OrdinalRange{T, S}]) \nwhere {T<:Integer, S<:Integer})\n\nReturn the minimum intensity. The optional keyword argument scanindexrange allows you to  specify a range of scans from which the minimum intensity is determined.\n\nSee also AbstractChrom, minintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [12, 1, 956]);\n\njulia> maxintensity(chrom)\n956\n\njulia> maxintensity(chrom, scanindexrange=1:2)\n12\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxintensity-Union{Tuple{AbstractChromMS}, Tuple{S2}, Tuple{T2}, Tuple{S1}, Tuple{T1}} where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}","page":"Basics","title":"JuChrom.maxintensity","text":"maxintensity(chrom::AbstractChromMS[; scanindexrange::OrdinalRange{T1, S1}, \nionindexrange::OrdinalRange{T2, S2}]) where {T1<:Integer, S1<:Integer, \nT2<:Integer, S2<:Integer})\n\nReturn the maximum intensity. The optional keyword arguments scanindexrange and  ionindexrange allow you to select a range of scans and ions from which the minimum  intensity is determined.\n\nSee also AbstractChromMS, minintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 1; 23 956]);\n\njulia> maxintensity(chrom)\n956\n\njulia> maxintensity(chrom, scanindexrange=1:2)\n34\n\njulia> maxintensity(chrom, ionindexrange=1:1)\n34\n\njulia> maxintensity(chrom, scanindexrange=1:2, ionindexrange=2:2)\n12\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxion-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.maxion","text":"maxion(chrom::AbstractChromMS)\n\nReturn the largest ion.\n\nSee also AbstractChromMS, minion, ions, ion,  ioncount.\n\nExample\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> maxion(chrom)\n100\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxscantime","page":"Basics","title":"JuChrom.maxscantime","text":"maxscantime(chrom::AbstractChromatogram[, scanindexrange::OrdinalRange{<:Integer, \n<:Integer}]; timeunit::Unitful.TimeUnits, ustripped::Bool)\n\nReturn the maximum scan time. The optional second positional argument allows you to  specify the scan range for which the maximum scan time is returned. The optional keyword  argument timeunit lets you change the unit of the returned scan time. All time units  defined in the package Unitful.jl (e.g.,  u\"s\", u\"minute\") are supported. The optional keyword argument ustripped lets you choose  whether to include the unit in the returned value.\n\nSee also AbstractChromatogram, minscantime, scantimes,  scantime,scancount.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> maxscantime(chrom)\n3.0 s\n\njulia> maxscantime(chrom, timeunit=u\"minute\")\n0.05 minute\n\njulia> maxscantime(chrom, timeunit=u\"minute\", ustripped=true)\n0.05\n\njulia> maxscantime(chrom, 1:2)\n2.0 s\n\njulia> maxscantime(chrom, 1:2, timeunit=u\"minute\", ustripped=true)\n0.03333333333333333\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.metadata-Tuple{AbstractChromatogram}","page":"Basics","title":"JuChrom.metadata","text":"metadata(chrom::AbstractChromatogram) -> Dict{Any, Any}\n\nReturn the metadata.\n\nSee also AbstractChromatogram.\n\nExamples\n\njulia> chrom₁ = ChromMS(Int64[1, 2]u\"s\", Int64[85, 100], Int64[0 12; 34 956], Dict(:id => 4))\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 1 entry\n\njulia> metadata(chrom₁)\nDict{Any, Any} with 1 entry:\n  :id => 4\n\njulia> chrom₂ = ChromMS(Int64[1, 2]u\"s\", Int64[85, 100], Int64[0 12; 34 956])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> metadata(chrom₂)\nDict{Any, Any}()\n\njulia> metadata(chrom₂)[\"name\"] = \"sample\"\n\"sample\"\n\njulia> metadata(chrom₂)[:id] = 123\n123\n\njulia> metadata(chrom₂)\nDict{Any, Any} with 2 entries:\n  \"name\" => \"sample\"\n  :id    => 123\n\njulia> chrom₂\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 2 entries\n\njulia> delete!(metadata(chrom₂), \"name\")\nDict{Any, Any} with 1 entry:\n  :id => 123\n\njulia> chrom₂\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 1 entry\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minintensity-Union{Tuple{AbstractChrom}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:Integer}","page":"Basics","title":"JuChrom.minintensity","text":"minintensity(chrom::AbstractChrom[, greaterthan::Real; \nscanindexrange::OrdinalRange{T, S}]) where {T<:Integer, S<:Integer})\n\nReturn the minimum intensity. The optional positional argument greaterthan allows you to  specify a threshold value; the returned minimum intensity will be greater than this  threshold. If no intensity exceeds the specified value, nothing is returned. The optional  keyword argument scanindexrange allows you to specify a range of scans from which the  minimum intensity is determined.\n\nSee also AbstractChrom, maxintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [12, 956, 1]);\n\njulia> minintensity(chrom)\n1\n\njulia> minintensity(chrom, 1)\n12\n\njulia> minintensity(chrom, scanindexrange=1:2)\n12\n\njulia> minintensity(chrom, 1, scanindexrange=2:3)\n956\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minintensity-Union{Tuple{AbstractChromMS}, Tuple{S2}, Tuple{T2}, Tuple{S1}, Tuple{T1}} where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}","page":"Basics","title":"JuChrom.minintensity","text":"minintensity(chrom::AbstractChromMS[, greaterthan::Real; \nscanindexrange::OrdinalRange{T1, S1}, ionindexrange::OrdinalRange{T2, S2}]) \nwhere {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer})\n\nReturn the minimum intensity. The optional positional argument greaterthan allows you to  specify a threshold value; the returned minimum intensity will be greater than this  threshold. If no intensity exceeds the specified value, nothing is returned. The optional  keyword arguments scanindexrange and ionindexrange allow you to select a range of scans and ions from which the minimum intensity is determined.\n\nSee also AbstractChromMS, maxintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> minintensity(chrom)\n0\n\njulia> minintensity(chrom, 0)\n1\n\njulia> minintensity(chrom, scanindexrange=2:3)\n1\n\njulia> minintensity(chrom, ionindexrange=1:1)\n0\n\njulia> minintensity(chrom, scanindexrange=2:3, ionindexrange=1:1)\n23\n\njulia> minintensity(chrom, 25, scanindexrange=2:3, ionindexrange=1:1)\n34\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minion-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.minion","text":"minion(chrom::AbstractChromMS)\n\nReturn the smallest ion.\n\nSee also AbstractChromMS, maxion, ions, ion,  ioncount.\n\nExample\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> minion(chrom)\n85\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minscantime","page":"Basics","title":"JuChrom.minscantime","text":"minscantime(chrom::AbstractChromatogram[, scanindexrange::OrdinalRange{<:Integer, \n<:Integer}}]; timeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the minimum scan time. The optional second positional argument scanindexrange  allows you to specify a scan range for which the minimum scan time is returned. The  optional keyword argument timeunit lets you change the unit of the returned scan time.  All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also AbstractChromatogram, maxscantime, scantimes,  scantime, scancount.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> minscantime(chrom)\n1.0 s\n\njulia> minscantime(chrom, timeunit=u\"minute\")\n0.016666666666666666 minute\n\njulia> minscantime(chrom, timeunit=u\"minute\", ustripped=true)\n0.016666666666666666\n\njulia> minscantime(chrom, 2:3)\n2.0 s\n\njulia> minscantime(chrom, 2:3, timeunit=u\"minute\", ustripped=true)\n0.03333333333333333\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.rimapper-Tuple{AbstractChromatogram}","page":"Basics","title":"JuChrom.rimapper","text":"rimapper(chrom::AbstractChromatogram)\n\nReturn the retention index mapper object. If no object is stored, the function returns  nothing.\n\nSee also AbstractChromatogram, AbstractRiMapper, RiMapper.\n\nExample\n\njulia> chrom = Chrom([1, 2, 3, 4, 5]u\"s\", [12, 956, 23, 45, 25]);\n\njulia> rimapper(chrom) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> chrom = Chrom([1, 2, 3, 4, 5]u\"s\", [12, 956, 23, 45, 25], rimapper=ld);\n\njulia> rimapper(chrom)\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.rimapper!-Tuple{AbstractChromatogram, AbstractRiMapper}","page":"Basics","title":"JuChrom.rimapper!","text":"rimapper!(chrom::AbstractChromatogram, rim::AbstractRiMapper)\n\nAssign an retention index mapper to the AbstractChromatogram object.\n\nSee also AbstractChromatogram, AbstractRiMapper, RiMapper.\n\nExample\n\njulia> chrom = Chrom([1, 2, 3, 4, 5]u\"s\", [12, 956, 23, 45, 25]);\n\njulia> rimapper(chrom) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> rimapper!(chrom, ld);\n\njulia> rimapper(chrom)\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\njulia> retentionindex(chrom, 2.2u\"minute\") ≈ 2200.0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.runduration","page":"Basics","title":"JuChrom.runduration","text":"runduration(chrom::AbstractChromatogram; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the duration of the run. The optional keyword argument timeunit lets you specify  the unit for the returned time interval. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include  the unit in the returned value.\n\nSee also AbstractChromatogram, scantimes, minscantime,  maxscantime, scancount.\n\nExamples\n\njulia> chrom = Chrom([30.1u\"minute\", 40.8u\"minute\", 51.5u\"minute\"], [12, 956, 23])\nChrom {scan times: Float64, intensities: Int64}\n3 scans; scan times: 30.1 minute, 40.8 minute, 51.5 minute\nintensity range: 12 - 956\nmetadata: 0 entries\n\njulia> runduration(chrom)\n21.4 minute\n\njulia> runduration(chrom, timeunit=u\"s\")\n1284.0 s\n\njulia> runduration(chrom, timeunit=u\"s\", ustripped=true)\n1284.0\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scancount","page":"Basics","title":"JuChrom.scancount","text":"scancount(chrom::AbstractChromatogram) -> Int\n\nReturn the number of scans.\n\nSee also AbstractChromatogram, scantimes.\n\nExample\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [12, 956, 23]);\n\njulia> scancount(chrom)\n3\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scanduration","page":"Basics","title":"JuChrom.scanduration","text":"scanduration(chrom::AbstractChromatogram; error::Real=0.01, \ntimeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nCalculates the periodicity with which the scans were recorded over time. The optional  keyword argument error allows you to specify the maximum allowable deviation of the  time interval between consecutive scans from the average scan time, as a fraction of  the average scan time. The optional keyword argument timeunit lets you specify the unit  for the returned value. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether the unit is  include in the returned value.\n\nSee also AbstractChromatogram, scantimes, minscantime,  maxscantime, scancount, runduration.\n\nExamples\n\njulia> chrom = Chrom([1.0, 2.0, 3.0]u\"s\", [12, 956, 1]);\n\njulia> scanduration(chrom)\n1.0 s\n\njulia> scanduration(chrom, timeunit=u\"minute\")\n0.016666666666666666 minute\n\njulia> scanduration(chrom, timeunit=u\"minute\", ustripped=true)\n0.016666666666666666\n\njulia> scanduration(Chrom([1.0, 1.99, 3.0]u\"s\", [12, 956, 1]))\nERROR: ArgumentError: maximum scan duration variation above threshold: 0.010000000000000009 > 0.01\n[...]\n\njulia> scanduration(Chrom([1.0, 1.99, 3.0]u\"s\", [12, 956, 1]), error=0.02)\n1.0 s\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scantime","page":"Basics","title":"JuChrom.scantime","text":"scantime(chrom::AbstractChromatogram, scanindex::Integer; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the scan time for a given scanindex. The optional parameter timeunit lets you  specify the unit for the returned scan time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether the unit is  included in the returned value.\n\nSee also AbstractChromatogram, scantimes, minscantime,  maxscantime, scancount, ionscantime.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> scantime(chrom, 2)\n2 s\n\njulia> scantime(chrom, 2, timeunit=u\"minute\")\n1//30 minute\n\njulia> scantime(chrom, 2, timeunit=u\"minute\", ustripped=true)\n1//30\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scantimeindex","page":"Basics","title":"JuChrom.scantimeindex","text":"scantimeindex(chrom::AbstractChromatogram, time::Unitful.Time; \nprecisetime::Bool=false) -> Int\n\nReturn the index of the scan time closest to time in the scan times. All time units  defined in the package Unitful.jl (e.g.,  u\"s\", u\"minute\") are supported. In case of a tie, the larger scan time is returned. If  the optional parameter precisetime is set to true, the specified time must exactly match  a scan time value; otherwise, an error is thrown.\n\nSee also AbstractChromatogram, scantimes, scantime,  minscantime, maxscantime, scancount, ionindex.\n\nExamples\n\njulia> chrom = ChromMS([1.1f0, 2.1f0, 3.1f0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float32, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.1f0 s, 2.1f0 s, 3.1f0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> scantimeindex(chrom, 1.1f0u\"s\", precisetime=true)\n1\n\njulia> scantimeindex(chrom, 2.1u\"s\", precisetime=true)\n2\n\njulia> scantimeindex(chrom, 2.2u\"s\", precisetime=true)\nERROR: ArgumentError: scantime 2.2 s does not exist\n[...]\n\njulia> scantimeindex(chrom, 2.2u\"s\")\n2\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scantimes","page":"Basics","title":"JuChrom.scantimes","text":"scantimes(chrom::AbstractChromatogram[, scanindexrange::OrdinalRange{<:Integer, \n<:Integer}]; timeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the scan times. The optional second positional argument allows you to specify a  range of scan indices. The optional keyword argument timeunit lets you change the unit of  the returned scan times. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned values. Note: If no time unit conversion is applied and the unit is  not stripped, the function returns a reference to or a view into the data structure.\n\nSee also AbstractChromatogram, scantime, minscantime,  maxscantime, scancount.\n\nIn the following example, the type of scantimes is explicitely annotated to demonstrate  that the ChromMS object preserves this type.\n\nExample\n\njulia> chrom = ChromMS(Float32[1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> scantimes(chrom)  # reference to the data structure\n3-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 1.0f0 s\n 2.0f0 s\n 3.0f0 s\n\njulia> scantimes(chrom, timeunit=u\"minute\")\n3-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 0.016666668f0 minute\n 0.033333335f0 minute\n 0.050000004f0 minute\n\njulia> scantimes(chrom, timeunit=u\"minute\", ustripped=true)\n3-element Vector{Float32}:\n 0.016666668\n 0.033333335\n 0.050000004\n\njulia> scantimes(chrom, 2:3)  # view into the data structure\n2-element view(::Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}, 2:3) with eltype Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}:\n 2.0f0 s\n 3.0f0 s\n\njulia> scantimes(chrom, 2:3)[:]  # a copy of these values\n2-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 2.0f0 s\n 3.0f0 s\n\njulia> scantimes(chrom, 2:3, timeunit=u\"minute\", ustripped=true)\n2-element Vector{Float32}:\n 0.033333335\n 0.050000004\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.totalionchromatogram","page":"Basics","title":"JuChrom.totalionchromatogram","text":"totalionchromatogram(chrom::ChromMS)\n\nCompute the total ion chromatrogram.\n\nSee also ChromMS, scantimes, intensities, metadata.\n\nIn the following example, the type of the intensities is explicitely annotated to  demonstrate that the returned Chrom object preserves this type.\n\nExample\n\njulia> chrom = ChromMS((1.1f0:3.1f0)u\"s\", [85, 100], Int64[0 12; 34 956; 23 1])\nChromMS {scan times: Float32, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.1f0 s, 2.1f0 s, 3.1f0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> tic = totalionchromatogram(chrom)\nChrom {scan times: Float32, intensities: Int64}\n3 scans; scan times: 1.1f0 s, 2.1f0 s, 3.1f0 s\nintensity range: 12 - 990\nmetadata: 0 entries\n\njulia> intensities(tic)\n3-element Vector{Int64}:\n  12\n 990\n  24\n\n\n\n\n\n","category":"function"},{"location":"man/import/#Data-Import","page":"Data Import","title":"Data Import","text":"","category":"section"},{"location":"man/import/#JuChrom.InputOutput.FileFormat","page":"Data Import","title":"JuChrom.InputOutput.FileFormat","text":"FileFormat\n\nSupertype of all FileFormat implementations.\n\nSee also AgilentFID, ANDI, ChemStationMS,  MassHunterMS.\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.AgilentFIDReaders.AgilentFID","page":"Data Import","title":"JuChrom.InputOutput.AgilentFIDReaders.AgilentFID","text":"AgilentFID(; datafilename::AbstractString=\"FID1A.ch\")\n\nReturns an object representing the AgilentFID file format. The optional keyword argument,  datafilename, allows you to specify a different name for the data file to be read,  instead of the default FID1A.ch. Upper and lower case are not considered when specifying  the data file name. Note that when using the function importdata, the AgilentFID data  reader expects the Agilent .D folder as the source location, with the specified data file  located at the top level of the .D folder. However, you can also provide the full pathname  of the data file directly when using the function importdata, in which case the  datafilename entry in the AgilentFID object is ignored.\n\nSee also FileFormat, importdata.\n\nExamples\n\njulia> AgilentFID()\nAgilentFID{String}(\"FID1A.ch\")\n\njulia> AgilentFID(datafilename=\"fid_data_20240611.ch\")\nAgilentFID{String}(\"fid_data_20240611.ch\")\n\njulia> dfolder = joinpath(JuChrom.agilent, \"ZK_ONUBE_Mix1_11.D\");\n\njulia> chrom = importdata(dfolder, AgilentFID())\nChrom {scan times: Float32, intensities: Float64}\n4151 scans; scan time range: 0.437f0 ms - 830000.44f0 ms\nintensity range: 0.0 - 1.0738316309895832e6\nmetadata: 10 entries\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.ANDIReaders.ANDI","page":"Data Import","title":"JuChrom.InputOutput.ANDIReaders.ANDI","text":"ANDI(; scantimetype::Union{AbstractFloat, Nothing}=Nothing, iontype::Union{\nAbstractFloat, Nothing}=Nothing, intensitytype::Union{AbstractFloat, Nothing}=Nothing)\n\nReturns an object representing the ANDI file format. When using the importdata function,  the ANDI data reader expects the source location to be a netCDF file, which typically has  a .CDF file extension. The keyword arguments scantimetype, iontype, and intensitytype  are provided to address cases where ANDI files may store data as Float64 even though it  was originally collected as Float32. The default type Nothing indicates that no conversion  takes place and the type in which the data is stored is returned. Background: When decimal  numbers are converted to binary floats, they are rounded to the nearest binary fraction  rather than a decimal fraction. This rounding can cause slight changes in the values. If  the data were initially recorded as Float32 and are then converted to Float64, these  changes can become visible. However, the changes can usually be ignored. If one wishes to  convert the float types, the optional scantimetype keyword argument allows the scan times  to be converted to a specified float type. Similarly, the optional keyword arguments  iontype and intensitytype allow the conversion of mass-to-charge ratio values and  intensity values, respectively, to a desired float type. \n\nSee also FileFormat, importdata.\n\nExample\n\njulia> ANDI()\nANDI{Nothing, Nothing, Nothing}(Nothing, Nothing, Nothing)\n\njulia> cdffile = joinpath(JuChrom.andi, \"C7-C40_13_Nov_1.CDF\");\n\njulia> chrom = importdata(cdffile, ANDI())\nChromMS {scan times: Float64, ions: Float32, intensities: Float32}\n5221 scans; scan time range: 191.942 s - 3898.719 s\n5248 ions; range: m/z 29.0 - 562.9\nintensity range: 0.0 - 1.051136e6\nmetadata: 2 entries\n\njulia> scantimes(chrom)[9:11]\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 197.623 s\n 198.33300000000003 s\n 199.043 s\n\njulia> chrom = importdata(cdffile, ANDI(scantimetype=Float32))\nChromMS {scan times: Float32, ions: Float32, intensities: Float32}\n5221 scans; scan time range: 191.942f0 s - 3898.719f0 s\n5248 ions; range: m/z 29.0 - 562.9\nintensity range: 0.0 - 1.051136e6\nmetadata: 2 entries\n\njulia> scantimes(chrom)[9:11]\n3-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 197.623f0 s\n 198.333f0 s\n 199.043f0 s\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.ChemStationMSReaders.ChemStationMS","page":"Data Import","title":"JuChrom.InputOutput.ChemStationMSReaders.ChemStationMS","text":"ChemStationMS(; datafilename::AbstractString=\"data.ms\")\n\nReturns an object representing the ChemStationMS file format. The optional keyword  argument, datafilename, allows you to specify a different name for the data file to be  read, instead of the default data.ms (e.g., datasim.ms). Upper and lower case are not  considered when specifying the data file name. Note that when using the function  importdata, the ChemStationMS data reader expects the Agilent .D folder as the source  location, with the specified data file located at the top level of the .D folder.  However, you can also provide the full pathname of the data file directly when using  the function importdata, in which case the datafilename entry in the ChemStationMS  object is ignored.\n\nSee also FileFormat, importdata.\n\nExamples\n\njulia> ChemStationMS()\nChemStationMS{String}(\"data.ms\")\n\njulia> ChemStationMS(datafilename=\"DATASIM.MS\")\nChemStationMS{String}(\"DATASIM.MS\")\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D\");\n\njulia> chrom = importdata(dfolder, ChemStationMS())\nChromMS {scan times: Float32, ions: Float32, intensities: Int32}\n2405 scans; scan time range: 191941.0f0 ms - 1.899047f6 ms\n5176 ions; range: m/z 29.0 - 562.9\nintensity range: 0 - 1186816\nmetadata: 10 entries\n\njulia> datafile = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D/data.ms\");\n\njulia> chrom = importdata(datafile, ChemStationMS())\nChromMS {scan times: Float32, ions: Float32, intensities: Int32}\n2405 scans; scan time range: 191941.0f0 ms - 1.899047f6 ms\n5176 ions; range: m/z 29.0 - 562.9\nintensity range: 0 - 1186816\nmetadata: 10 entries\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.MassHunterMSReaders.MassHunterMS","page":"Data Import","title":"JuChrom.InputOutput.MassHunterMSReaders.MassHunterMS","text":"MassHunterMS(; scanmethodid::Integer=1, \nscantimetype::Union{AbstractFloat, Nothing}=Nothing, \niontype::Union{AbstractFloat, Nothing}=Nothing, \nintensitytype::Union{AbstractFloat, Nothing}=Nothing\n\nReturn an object representing the MassHunterMS file format. When using the importdata  function, the MassHunterMS data reader expects the source location to be the Agilent .D  folder. The optional scanmethodid keyword argument allows you to specify which scan  method ID data to read, which is particularly useful when multiple scan methods have been  applied simultaneously. The :ScanMethodID and :ScanMethodIDs metadata entries indicate  which scan method ID data was extracted and which scan method IDs are available for a given  run. The keyword arguments scantimetype, iontype, and intensitytype are provided to  address cases where MassHunter files may store data as Float64 even though it was  originally collected as Float32. The default type Nothing indicates that no conversion  takes place and the type in which the data is stored is returned. Background: When decimal  numbers are converted to binary floats, they are rounded to the nearest binary fraction  rather than a decimal fraction. This rounding can cause slight changes in the values. If  the data were initially recorded as Float32 and are then converted to Float64, these  changes can become visible. However, the changes can usually be ignored. If one wishes to  convert the float types, the optional scantimetype keyword argument allows the scan times  to be converted to a specified float type. Similarly, the optional keyword arguments  iontype and intensitytype allow the conversion of mass-to-charge ratio values and  intensity values, respectively, to a desired float type.\n\nSee also FileFormat, importdata, JuChrom.binions.\n\nExamples\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_MassHunterMS.D\");\n\njulia> chrom = importdata(dfolder, MassHunterMS())\nChromMS {scan times: Float64, ions: Float64, intensities: Float64}\n2405 scans; scan time range: 191.941 s - 1899.047 s\n50275 ions; range: m/z 29.020000457763672 - 562.8900146484375\nintensity range: 0.0 - 1.1872475e6\nmetadata: 2 entries\n\njulia> ions(chrom)[1:3]  # ion decimal digits suggest Float32\n3-element Vector{Float64}:\n 29.020000457763672\n 29.030000686645508\n 29.040000915527344\n\njulia> chrom = importdata(dfolder, MassHunterMS(; iontype=Float32))\nChromMS {scan times: Float64, ions: Float32, intensities: Float64}\n2405 scans; scan time range: 191.941 s - 1899.047 s\n50275 ions; range: m/z 29.02 - 562.89\nintensity range: 0.0 - 1.1872475e6\nmetadata: 2 entries\n\njulia> ions(chrom)[1:3]\n3-element Vector{Float32}:\n 29.02\n 29.03\n 29.04\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.ShimadzuMSReaders.ShimadzuMS","page":"Data Import","title":"JuChrom.InputOutput.ShimadzuMSReaders.ShimadzuMS","text":"ShimadzuMS()\n\nReturns an object representing the ShimadzuMS file format. When using the importdata function, the ShimadzuMS data reader expects the source to be a .qgd file.\n\nSee also FileFormat, importdata.\n\nExample\n\njulia> ShimadzuMS()\nShimadzuMS()\n\njulia> qgdfile = joinpath(JuChrom.shimadzu, \"AR190311.qgd\");\n\njulia> chrom = importdata(qgdfile, ShimadzuMS())\nChromMS {scan times: Int32, ions: Float64, intensities: UInt32}\n9210 scans; scan time range: 183000 ms - 2024800 ms\n3620 ions; range: m/z 34.9 - 600.4\nintensity range: 0 - 924954\nmetadata: 0 entries\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.importdata","page":"Data Import","title":"JuChrom.InputOutput.importdata","text":"importdata(source::AbstractString, fileformat::FileFormat)\n\nRead data from the specified source using the appropriate file format reader. The source  may be a file or a directory path, depending on the requirements of the chosen file format  reader.\n\nSee also AgilentFID, ANDI, ChemStationMS,  MassHunterMS.\n\nExamples\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D\");\n\njulia> chrom = importdata(dfolder, ChemStationMS())\nChromMS {scan times: Float32, ions: Float32, intensities: Int32}\n2405 scans; scan time range: 191941.0f0 ms - 1.899047f6 ms\n5176 ions; range: m/z 29.0 - 562.9\nintensity range: 0 - 1186816\nmetadata: 10 entries\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#Mass-Spectra","page":"Mass Spectra","title":"Mass Spectra","text":"","category":"section"},{"location":"man/massspectra/#JuChrom.AbstractMassSpectrum","page":"Mass Spectra","title":"JuChrom.AbstractMassSpectrum","text":"AbstractMassSpectrum\n\nSupertype for all mass spectrum implementations. All subtypes (e.g., MassSpectrum)  include fields to store ions, their associated intensities, and optionally, retention time,  retention index, and metadata.\n\nSee also MassSpectrum.\n\n\n\n\n\n","category":"type"},{"location":"man/massspectra/#JuChrom.MassSpectrum","page":"Mass Spectra","title":"JuChrom.MassSpectrum","text":"MassSpectrum(ions::AbstractVector{<:Real}, intensities::AbstractVector{<:Real};\nretentiontime::Union{Unitful.Time, Nothing}=nothing,\nretentionindexname::Union{AbstractString, Nothing}=nothing,\nretentionindex::Union{<:Real, Nothing}=nothing, metadata::Dict=Dict())\n\nConstruct a ChromMS object that includes scantimes, ions, intensities, and  metadata. Note that scantimes and ions must be in ascending order, and intensities  must not contain any values less than zero. The retentiontime must include a time unit.  All time units supported by the  Unitful.jl package(e.g., u\"s\", u\"minute\")  are accepted.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum),  retentiontime(::AbstractMassSpectrum; ::Unitful.TimeUnits, ::Bool),  retentionindexname(::AbstractMassSpectrum),  retentionindex(::AbstractMassSpectrum),  metadata(::AbstractMassSpectrum),  sharedions,  similarity.\n\nExamples\n\njulia> MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67])\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67], retentiontime=3.2u\"minute\")\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nretention time: 3.2 minute\nmetadata: 0 entries\n\njulia> MassSpectrum([1.2, 2.1], [1.1, 8.1], retentionindex=131, retentionindexname=\"Kovats\")\nMassSpectrum {ions: Float64, intensities: Float64}\n2 ions: m/z 1.2, 2.1\nintensity range: 1.1 - 8.1\nretention index: 131 (Kovats)\nmetadata: 0 entries\n\njulia> MassSpectrum([85.1, 112.2, 124.1], [13.0, 0.0, 67.0], metadata=Dict(:name=>\"Hexane\"))\nMassSpectrum {ions: Float64, intensities: Float64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0.0 - 67.0\nmetadata: 1 entry\n\n\n\n\n\n","category":"type"},{"location":"man/massspectra/#JuChrom.cosine","page":"Mass Spectra","title":"JuChrom.cosine","text":"cosine(x::AbstractVector{<:Real}, y::AbstractVector{<:Real})\n\nReturn the angle between two non-zero vectors, which can be considered a measure of the similarity (i.e., cosine similarity) between the two vectors.\n\nSee also similarity.\n\nExamples\n\njulia> cosine([100, 500, 250], [200, 1000, 0]) ≈ 0.8978872704229618\ntrue\n\njulia> cosine([100, 0, 50], [0, 20, 0]) ≈ 0.0\ntrue\n\njulia> cosine([10, 50, 25], [100, 500, 250]) ≈ 1.0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.intensities-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.intensities","text":"intensities(ms::AbstractMassSpectrum)\n\nReturn the intensities.\n\nSee also AbstractMassSpectrum,  intensity(::AbstractMassSpectrum, ::Integer),  maxintensity(::AbstractMassSpectrum),  minintensity(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> intensities(ms)\n3-element Vector{Int64}:\n 13\n  0\n 67\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.intensity-Tuple{AbstractMassSpectrum, Integer}","page":"Mass Spectra","title":"JuChrom.intensity","text":"intensity(ms::AbstractMassSpectrum, ionindex::Integer)\n\nReturn the intensity for an ion by specifying its index.\n\nSee also AbstractMassSpectrum, intensities(::AbstractMassSpectrum),  maxintensity(::AbstractMassSpectrum),  minintensity(::AbstractMassSpectrum).\n\nExamples\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> intensity(ms, 1)\n13\n\njulia> intensity(ms, 2)\n0\n\njulia> intensity(ms, 4)\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.intensitydifferences","page":"Mass Spectra","title":"JuChrom.intensitydifferences","text":"intensitydifferences(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum)\n\nReturn the intensity difference for each ion in ms₁ and ms₂, with any negative results set  to zero. This function assumes both mass spectra contain data for the same set of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum), intensitysums,  meanintensities.\n\nExamples\n\njulia> ms₁ = MassSpectrum([80, 85, 90], [10, 80, 5]);\n\njulia> ms₂ = MassSpectrum([80, 85, 90], [0, 10, 0]);\n\njulia> intensitydifferences(ms₁, ms₂)\n3-element Vector{Int64}:\n 10\n 70\n  5\n\njulia> intensitydifferences(ms₂, ms₁)\n3-element Vector{Int64}:\n 0\n 0\n 0\n\njulia> ms₃ = MassSpectrum([80, 85, 90], [5.5, 20.1, 5]);\n\njulia> intensitydifferences(ms₁, ms₃) ≈ [4.5, 59.9, 0.0]\ntrue\n\njulia> intensitydifferences(MassSpectrum([80], [5]), MassSpectrum([81], [5]))\nERROR: ArgumentError: mass spectra differ in ions\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.intensitysums","page":"Mass Spectra","title":"JuChrom.intensitysums","text":"intensitysums(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum)\n\nReturn the intensity sums for each ion in ms₁ and ms₂. This function assumes that both mass  spectra contain data for the same set of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum), meanintensities.\n\nExamples\n\njulia> ms₁ = MassSpectrum([80, 85, 90], Int64[0, 10, 0]);\n\njulia> ms₂ = MassSpectrum([80, 85, 90], Int64[10, 80, 5]);\n\njulia> intensitysums(ms₁, ms₂)\n3-element Vector{Int64}:\n 10\n 90\n  5\n\njulia> ms₃ = MassSpectrum([80, 85, 90], Float64[10, 80, 5]);\n\njulia> intensitysums(ms₁, ms₃) ≈ [10.0, 90.0, 5.0]\ntrue\n\njulia> intensitysums(MassSpectrum([80], [5]), MassSpectrum([81], [5]))\nERROR: ArgumentError: mass spectra differ in ions\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.ion-Tuple{AbstractMassSpectrum, Integer}","page":"Mass Spectra","title":"JuChrom.ion","text":"ion(ms::AbstractMassSpectrum, ionindex::Integer)\n\nReturn the ion at the specified ionindex.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), minion(::AbstractMassSpectrum),  ioncount(::AbstractMassSpectrum), ionindex(::AbstractMassSpectrum, ::Real),  sharedions.\n\nExamples\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ion(ms, 1)\n85\n\njulia> ion(ms, 2)\n112\n\njulia> ion(ms, 3)\n124\n\njulia> ion(ms, 4)\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\n[...]\n\njulia> ion.(ms, 1:2)  # broadcasting across multiple ion indices\n2-element Vector{Int64}:\n  85\n 112\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  ionindex(::AbstractMassSpectrum, ::Real),  minion(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum).\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.ionindex-Tuple{AbstractMassSpectrum, Real}","page":"Mass Spectra","title":"JuChrom.ionindex","text":"ionindex(ms::AbstractMassSpectrum, ion::Real) -> Int\n\nReturn the index of the ion. If the ion is not present in the mass spectrum, an error  is raised.\n\nSee also AbstractMassSpectrum, ion(::AbstractMassSpectrum, ::Integer),  ions(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), minion(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum([85.1, 112.0, 124.2], Int64[13, 0, 67])\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.0, 124.2\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ionindex(ms, 124.2)\n3\n\njulia> ionindex(ms, 124)\nERROR: ArgumentError: ion 124 does not exist\n[...]\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer), minion(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum).\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.ions-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.ions","text":"ions(ms::AbstractMassSpectrum)\n\nReturn the ions.\n\nSee also AbstractMassSpectrum, ion(::AbstractMassSpectrum, ::Integer),  maxion(::AbstractMassSpectrum), minion(::AbstractMassSpectrum),  ioncount(::AbstractMassSpectrum),  ionindex(::AbstractMassSpectrum, ::Real),  sharedions.\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ions(ms)\n3-element Vector{Int64}:\n  85\n 112\n 124\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.ioncount-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.ioncount","text":"ioncount(ms::AbstractMassSpectrum) -> Int\n\nReturn the number of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer), ionindex(::AbstractMassSpectrum, ::Real),  minion(::AbstractMassSpectrum), maxion(::AbstractMassSpectrum), sharedions.\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ioncount(ms)\n3\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.massspectrum","page":"Mass Spectra","title":"JuChrom.massspectrum","text":"massspectrum(chrom::AbstractChromMS, scanindex::Integer; \nretentionindexname::Union{AbstractString, Nothing}=nothing,\nretentionindex::Union{Real, Nothing}=nothing, metadata::Dict=Dict())\n\nReturns a MassSpectrum containing the intensity values for all ions at the specified  scan index. The optional keyword arguments, retentionindexname and retentionindex,  allow the mass spectrum to be associated with a retention index. Note that both  retentionindexname and retentionindex must always be provided together. The optional  keyword argument metadata allows the mass spectrum to be associated with additional  metadata.\n\nSee also AbstractChromMS, MassSpectrum,  ions(::AbstractMassSpectrum), intensities(::AbstractMassSpectrum),  retentiontime(::AbstractMassSpectrum; ::Unitful.TimeUnits, ::Bool).\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2)\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2, retentionindexname=\"Kovats\", retentionindex=123.21)\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nretention index: 123.21 (Kovats)\nmetadata: 0 entries\n\njulia> ms = massspectrum(chrom, 2, metadata=Dict(:compound => \"hexane\"))\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nmetadata: 1 entry\n\njulia> metadata(ms)\nDict{Any, Any} with 1 entry:\n  :compound => \"hexane\"\n\n\n\n\n\nmassspectrum(chrom::AbstractChromMS, time::Unitful.Time; precisetime::Bool=false, \nretentionindexname::Union{AbstractString, Nothing}=nothing,\nretentionindex::Union{Real, Nothing}=nothing, metadata::Dict=Dict())\n\nReturn a MassSpectrum containing the intensity values for all ions in the scan with a  scan time closest to the specified time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. In case of a tie, the larger scan time is selected. If the optional parameter  precisetime is set to true, the specified time must match exactly, otherwise an error  will be thrown. The optional keyword arguments, retentionindexname and retentionindex,  allow the mass spectrum to be associated with a retention index. Note that both  retentionindexname and retentionindex must always be provided together. The optional  keyword argument metadata allows the mass spectrum to be associated with additional  metadata.\n\nSee also AbstractChromMS, MassSpectrum,  ions(::AbstractMassSpectrum), intensities(::AbstractMassSpectrum),  retentiontime(::AbstractMassSpectrum; ::Unitful.TimeUnits, ::Bool).\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2u\"s\")\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2.5u\"s\")\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 3.5u\"s\")\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2.1u\"s\", precisetime=true)\nERROR: ArgumentError: scantime 2.1 s does not exist\n[...]\n\njulia> massspectrum(chrom, 2.5u\"s\", retentionindexname=\"Kovats\", retentionindex=123.21)\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nretention index: 123.21 (Kovats)\nmetadata: 0 entries\n\njulia> ms = massspectrum(chrom, 2.5u\"s\", metadata=Dict(:compound => \"hexane\"))\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nmetadata: 1 entry\n\njulia> metadata(ms)\nDict{Any, Any} with 1 entry:\n  :compound => \"hexane\"\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.maxintensity-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.maxintensity","text":"maxintensity(ms::AbstractMassSpectrum)\n\nReturn the maximum intensity.\n\nSee also AbstractMassSpectrum, minintensity(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum),  intensity(::AbstractMassSpectrum, ::Integer)`](@ref).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> maxintensity(ms)\n67\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.maxion-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.maxion","text":"maxion(ms::AbstractMassSpectrum)\n\nReturn the largest ion.\n\nSee also AbstractMassSpectrum, minion(::AbstractMassSpectrum),  ions(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer),  ionindex(::AbstractMassSpectrum, ::Real).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> maxion(ms)\n124\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.meanintensities","page":"Mass Spectra","title":"JuChrom.meanintensities","text":"meanintensities(mss::AbstractVector{<:AbstractMassSpectrum}) -> Vector{Float64}\n\nReturn a vector of the average intensities for all ions in the provided mass spectra. This  function assumes that each mass spectrum contains data for the same set of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum), intensitydifferences,  intensitysums.\n\nExample\n\njulia> ms₁ = MassSpectrum([80, 85, 90], [0, 10, 0]);\n\njulia> ms₂ = MassSpectrum([80, 85, 90], [10, 80, 5]);\n\njulia> meanintensities([ms₁, ms₂]) ≈ Float64[5.0, 45.0, 2.5]\ntrue\n\njulia> meanintensities([MassSpectrum([80], [5]), MassSpectrum([81], [5])])\nERROR: ArgumentError: mass spectra differ in ions\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.metadata-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.metadata","text":"metadata(ms::AbstractMassSpectrum) -> Dict{Any, Any}\n\nReturn the metadata.\n\nSee also AbstractMassSpectrum.\n\nExamples\n\njulia> ms = MassSpectrum([85.1], [13.0], metadata=Dict(:name=>\"unknown\"))\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 1 entry\n\njulia> metadata(ms)\nDict{Any, Any} with 1 entry:\n  :name => \"unknown\"\n\njulia> ms = MassSpectrum([85.1], [13.0])\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 0 entries\n\njulia> metadata(ms)\nDict{Any, Any}()\n\njulia> metadata(ms)[:species] = \"Polistes dominula\"\n\"Polistes dominula\"\n\njulia> metadata(ms)[:id] = 123\n123\n\njulia> metadata(ms)\nDict{Any, Any} with 2 entries:\n  :species => \"Polistes dominula\"\n  :id      => 123\n\njulia> ms\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 2 entries\n\njulia> delete!(metadata(ms), :species)\nDict{Any, Any} with 1 entry:\n  :id => 123\n\njulia> ms\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 1 entry\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.minintensity-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.minintensity","text":"minintensity(ms::AbstractMassSpectrum)\n\nReturn the minimum intensity.\n\nSee also AbstractMassSpectrum, maxintensity(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum),  intensity(::AbstractMassSpectrum, ::Integer)`](@ref).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> minintensity(ms)\n0\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.minion-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.minion","text":"minion(ms::AbstractMassSpectrum)\n\nReturn the smallest ion.\n\nSee also AbstractMassSpectrum, maxion(::AbstractMassSpectrum),  ions(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer),  ionindex(::AbstractMassSpectrum, ::Real).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> minion(ms)\n85\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.retentionindex-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.retentionindex","text":"retentionindex(ms::AbstractMassSpectrum)\n\nReturn the retention index. If no retention index is associated with the mass spectrum, the  function returns the value nothing.\n\nSee also AbstractMassSpectrum,  retentionindexname(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum([1.2], [1.1], retentionindex=131.1, retentionindexname=\"Kovats\")\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 1.2\nintensity: 1.1\nretention index: 131.1 (Kovats)\nmetadata: 0 entries\n\njulia> retentionindex(ms) ≈ 131.1\ntrue\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> retentionindex(ms) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.retentionindexname-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.retentionindexname","text":"retentionindexname(ms::AbstractMassSpectrum)\n\nReturn the retention index name. If the mass spectrum has no associated retention index,  the function returns the value nothing.\n\nSee also AbstractMassSpectrum, retentionindex(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum([1.2], [1.1], retentionindex=131.1, retentionindexname=\"Kovats\")\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 1.2\nintensity: 1.1\nretention index: 131.1 (Kovats)\nmetadata: 0 entries\n\njulia> retentionindexname(ms)\n\"Kovats\"\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> retentionindexname(ms) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.retentiontime","page":"Mass Spectra","title":"JuChrom.retentiontime","text":"retentiontime(ms::AbstractMassSpectrum; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the retention time. If no retention time is associated with the mass spectrum, the  function returns the value nothing. The optional keyword argument timeunit lets you  change the unit of the returned scan time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also AbstractMassSpectrum, massspectrum.\n\nExamples\n\njulia> ms = MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67], retentiontime=3.2u\"minute\")\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nretention time: 3.2 minute\nmetadata: 0 entries\n\njulia> retentiontime(ms) ≈ 3.2u\"minute\"\ntrue\n\njulia> retentiontime(ms, timeunit=u\"s\") ≈ 192.0u\"s\"\ntrue\n\njulia> retentiontime(ms, timeunit=u\"s\", ustripped=true) ≈ 192.0\ntrue\n\njulia> retentiontime(ms, ustripped=true) ≈ 3.2\ntrue\n\njulia> ms = MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67])\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> retentiontime(ms) === nothing\ntrue\n\njulia> retentiontime(ms, timeunit=u\"ms\", ustripped=true) === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.sharedions","page":"Mass Spectra","title":"JuChrom.sharedions","text":"sharedions(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum)\n\nReturn the ions present in both mass spectra.\n\nSee also MassSpectrum, ions(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer),  ioncount(::AbstractMassSpectrum).\n\nExample\n\njulia> ms₁ = MassSpectrum([80, 85, 90], [100, 500, 250])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 80, 85, 90\nintensity range: 100 - 500\nmetadata: 0 entries\n\njulia> ms₂ = MassSpectrum([80, 85], [100, 500])\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 80, 85\nintensity range: 100 - 500\nmetadata: 0 entries\n\njulia> sharedions(ms₁, ms₂)\n2-element Vector{Int64}:\n 80\n 85\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.similarity","page":"Mass Spectra","title":"JuChrom.similarity","text":"similarity(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum, f::Function)\n\nCompute the similarity between the two mass spectra by applying the similarity function f  (e.g., cosine) to the intensity values of the ions shared between ms₁ and ms₂.\n\nSee also AbstractMassSpectrum, cosine,  sharedions,  ions(::AbstractMassSpectrum), intensities(::AbstractMassSpectrum).\n\nExamples\n\njulia> ms₁ = MassSpectrum(Int64[80, 85, 90], Int64[100, 500, 250]);\n\njulia> ms₂ = MassSpectrum(Int32[80, 85], Int32[200, 1000]);\n\njulia> similarity(ms₁, ms₂, cosine) ≈ 1.0\ntrue\n\njulia> ms₁ = MassSpectrum(Float64[80, 85, 90], Float32[100, 500, 250]);\n\njulia> ms₂ = MassSpectrum(Int64[80, 85, 90], Int32[200, 1000, 0]);\n\njulia> similarity(ms₁, ms₂, cosine) ≈ 0.8978873122816586\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#Base","page":"Base","title":"Base","text":"","category":"section"},{"location":"internals/base/#JuChrom.bsplineinterpolation","page":"Base","title":"JuChrom.bsplineinterpolation","text":"bsplineinterpolation(retentiontimes::AbstractVector{<:Unitful.Time}, \nretentionindices::AbstractVector{<:Real}; extrapolation::Bool=false, force::Bool=false)\n\nReturn a function that maps retention time to a retention index. The function uses a  B-spline for interpolation calculated from a vector of retention times and a corresponding  vector of retention indices. For retention time values outside the range used to  compute the B-spline, the function employs linear extrapolation to estimate a retention  index. However, an optional keyword argument, extrapolation, can be used to disable  extrapolation, in which case the function returns nothing for values outside the retention  time range. The function will raise an error if the resulting mapping function does not  produce continuously increasing values. However, by setting the force keyword argument to  true, the function will return a mapping function even if it does not yield continuously  increasing values. This can be useful for identifying problematic or erroneous calibration  points.\n\nSee also scantimes, retentionindices.\n\nExamples\n\njulia> rts, ris = (1:8)*u\"s\", [1000, 1800, 3050, 3800, 5500, 6600, 6900, 7400];\n\njulia> rt2ri, jacobian_rt2ri = JuChrom.bsplineinterpolation(rts, ris);\n\njulia> rt2ri(1u\"s\") ≈ 1000.0\ntrue\n\njulia> rt2ri(1.5u\"s\") ≈ 1333.7469941600825\ntrue\n\njulia> rt2ri((1//30)u\"minute\") ≈ 1800.0\ntrue\n\njulia> rt2ri(9.1u\"s\") ≈ 7950.0\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> rt2ri, jacobian_rt2ri = JuChrom.bsplineinterpolation(rts, ris; extrapolation=true);\n\njulia> rt2ri(9.1u\"s\") ≈ 8053.1226382686355\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.piecewiselinearinterpolation","page":"Base","title":"JuChrom.piecewiselinearinterpolation","text":"piecewiselinearinterpolation(retentiontimes::AbstractVector{<:Unitful.Time}, \nretentionindices::AbstractVector{<:Real}; extrapolation::Bool=false) -> Float64\n\nReturn a function that maps retention time to retention index using piecewise linear  interpolation based on a vector of retention times and a corresponding vector of retention  indices. For retention time values outside the interpolation range, the function applies  linear extrapolation to estimate the retention index. However, an optional extrapolation  keyword can disable extrapolation, in which case the function will raise an error for  values outside the retention time range.\n\nSee also scantimes, retentionindices.\n\nExamples\n\njulia> rts, ris = (1:8)*u\"s\", [1000, 1800, 3050, 3800, 5500, 6600, 6900, 7400];\n\njulia> rt2ri = JuChrom.piecewiselinearinterpolation(rts, ris);\n\njulia> rt2ri(1u\"s\") ≈ 1000.0\ntrue\n\njulia> rt2ri(1.5u\"s\") ≈ 1400.0\ntrue\n\njulia> rt2ri((1//30)u\"minute\") ≈ 1800.0\ntrue\n\njulia> rt2ri(9.1u\"s\")\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> rt2ri = JuChrom.piecewiselinearinterpolation(rts, ris; extrapolation=true);\n\njulia> rt2ri(9.1u\"s\") ≈ 7950.0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.copy_with_eltype","page":"Base","title":"JuChrom.copy_with_eltype","text":"JuChrom.copy_with_eltype(array::AbstractArray, elementtype::Type)\n\nCreate a mutable copy of the array with the type of its elements converted to  elementtype.\n\nExamples\n\njulia> JuChrom.copy_with_eltype(Int[1, 2, 3, 4, 5, 6], Float64)\n6-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n 5.0\n 6.0\n\njulia> JuChrom.copy_with_eltype(Float64[1, 2, 3, 4, 5, 6], Int32)\n6-element Vector{Int32}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> JuChrom.copy_with_eltype(Float64[1.1, 2, 3, 4, 5, 6], Int32)\nERROR: InexactError: Int32(1.1)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.findclosest","page":"Base","title":"JuChrom.findclosest","text":"JuChrom.findclosest(A::AbstractVector{<:Number}, x::Number) -> Int\n\nReturn the index of the number closest to x in a list A of numbers sorted in ascending  order. If case of a tie, the index of the larger number is returned.\n\nExamples\n\njulia> JuChrom.findclosest([-2, -1, 0, 1, 2, 3, 4, 5], 0)\n3\n\njulia> JuChrom.findclosest([-2, -1, 0, 1, 2, 3, 4, 5], 1.5)\n5\n\njulia> JuChrom.findclosest([-2, -1, 0, 1, 2, 3, 4, 5], -1.5)\n2\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.invert","page":"Base","title":"JuChrom.invert","text":"JuChrom.invert(dictionary::Dict)\n\nReturn a dictionary where the values from the input dictionary become the keys. Each key  in the returned dictionary maps to a list of all original keys from dictionary that were  associated with that value.\n\nExample\n\njulia> d = Dict(:a => 1.0, :b => 2.0, :c => 2.0, :d => 1.0)\nDict{Symbol, Float64} with 4 entries:\n  :a => 1.0\n  :b => 2.0\n  :d => 1.0\n  :c => 2.0\n\njulia> JuChrom.invert(d)\nDict{Float64, Vector{Symbol}} with 2 entries:\n  2.0 => [:b, :c]\n  1.0 => [:a, :d]\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.name","page":"Base","title":"JuChrom.name","text":"JuChrom.name(::Type)\n\nReturn the name of the type.\n\nExample\n\njulia> chrom = ChromMS(Int32[1, 2, 3]u\"s\", Int64[85, 100], Int32[0 12; 34 956; 23 1]);\n\njulia> JuChrom.name(typeof(chrom))\nChromMS\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.rt2ri","page":"Base","title":"JuChrom.rt2ri","text":"JuChrom.rt2ri(mapper::RiMapper)\n\nReturn the function that maps a retention time to its corresponding retention index.  Note that direct use of this function is discouraged; users are encouraged to use the  more versatile function retentionindex instead.\n\nSee also RiMapper, retentionindex.\n\nExample\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> JuChrom.rt2ri(ld)(1.5u\"minute\") ≈ 1260.5733082706768\ntrue\n\njulia> JuChrom.rt2ri(ld)(1u\"minute\") ≈ 821.4487832484438\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.jacobian_rt2ri","page":"Base","title":"JuChrom.jacobian_rt2ri","text":"jacobian_rt2ri(mapper::RiMapper)\n\nReturn the derivative function of the applied interpolation method, if it exists.\n\nSee also RiMapper, retentionindex.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> jacobian_rt2ri(ld)(1.9u\"minute\") ≈ 999.9999999999998\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#Retention-Indices","page":"Retention Indices","title":"Retention Indices","text":"","category":"section"},{"location":"man/retentionindices/#JuChrom.PolationMethod","page":"Retention Indices","title":"JuChrom.PolationMethod","text":"PolationMethod\n\nSupertype for all data interpolation and extrapolation methods implemented for mapping  retention times to retention indices, and potentially vice versa.\n\nSee also Linear, NaturalCubicBSpline, RiMapper.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.Linear","page":"Retention Indices","title":"JuChrom.Linear","text":"Linear() <: PolationMethod\n\nPolationMethod type that specifies data is linearly extrapolated using the slope  calculated by the applied interpolator at the nearest retention time–retention index  calibration point.\n\nSee also PolationMethod, NaturalCubicBSpline, RiMapper.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.PiecewiseLinear","page":"Retention Indices","title":"JuChrom.PiecewiseLinear","text":"PiecewiseLinear() <: PolationMethod\n\nPolationMethod type that specifies data is interpolated using a piecewise linear approach.\n\nSee also PolationMethod, NaturalCubicBSpline, RiMapper.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.NaturalCubicBSpline","page":"Retention Indices","title":"JuChrom.NaturalCubicBSpline","text":"NaturalCubicBSpline(; force::Bool=false) <: PolationMethod\n\nPolationMethod type that specifies data is interpolated using a natural cubic B-spline.  Application of this type will raise an error if the resulting mapping function does not  produce continuously increasing values. However, by setting the force keyword argument to  true, a mapping function will be returned even if it does not yield continuously increasing  values. This can be useful for identifying problematic or erroneous calibration points.\n\nSee also PolationMethod, NaturalCubicBSpline, RiMapper.\n\nExamples\n\njulia> NaturalCubicBSpline()\nNaturalCubicBSpline(false)\n\njulia> NaturalCubicBSpline(; force=true)\nNaturalCubicBSpline(true)\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.AbstractRiMapper","page":"Retention Indices","title":"JuChrom.AbstractRiMapper","text":"AbstractRiMapper\n\nSupertype for all retention index mapper implementations. All subtypes (e.g., RiMapper)  have fields to store the retention index name and metadata.\n\nSee also RiMapper, retentionindexname, metadata.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.RiMapper","page":"Retention Indices","title":"JuChrom.RiMapper","text":"RiMapper(retentionindexname::AbstractString, \nretentiontimes::AbstractVector{<:Unitful.Time},\nretentionindices::AbstractVector{<:Real};\ninterpolationmethod::PolationMethod=NaturalCubicBSpline(), \nextrapolationmethod::Union{Nothing, <:PolationMethod}=nothing,\nmetadata::Dict=Dict())\n\nCreate an RiMapper object to map retention times to retention indices using  interpolation, and extrapolation by default. The optional keyword arguments  interpolationmethod and extrapolationmethod allow you to explicitly specify the  methods used. Currently, the available interpolators are NaturalCubicBSpline() (default)  and PiecewiseLinear(). The only available extrapolator is Linear(). If  extrapolationmethod is set to nothing (default), the function will raise an error for  retention time values outside the calibration range. Note that both retention times and  retention indices must be provided in ascending order. Additionally, the optional  metadata keyword argument allows you to associate metadata with the mapper.\n\nSee also AbstractRiMapper, retentionindexname, Linear,  NaturalCubicBSpline, PiecewiseLinear, retentionindices,  retentiontimes, interpolationmethod, extrapolationmethod,  rt2ri, metadata, retentionindex.\n\nExamples\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000)\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\njulia> retentionindex(ld, 1u\"minute\") ≈ 1000.0\ntrue\n\njulia> retentionindex(ld, 1.5u\"minute\") ≈ 1500.0\ntrue\n\njulia> retentionindex(ld, 11u\"minute\") ≈ 11000.0\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> retentionindices(ld)\n1000:1000:5000\n\njulia> retentiontimes(ld)\n(1:5) minute\n\njulia> interpolationmethod(ld)\nNaturalCubicBSpline(false)\n\njulia> extrapolationmethod(ld) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000, extrapolationmethod=Linear())\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: Linear()\nmetadata: 0 entries\n\njulia> retentionindex(ld, 11u\"minute\") === 11000.000000000011\ntrue\n\njulia> extrapolationmethod(ld)\nLinear()\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"s\", 10:10:50, interpolationmethod=PiecewiseLinear())\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 s, 2 s, 3 s, 4 s, 5 s\nretention indices: 10, 20, 30, 40, 50\ninterpolation method: PiecewiseLinear()\nextrapolation method: nothing\nmetadata: 0 entries\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.extrapolationmethod","page":"Retention Indices","title":"JuChrom.extrapolationmethod","text":"extrapolationmethod(mapper::RiMapper)\n\nReturn the name of the extrapolation method. If no extrapolation is applied, the function  returns nothing.\n\nSee also RiMapper, interpolationmethod, retentionindex.\n\nExample\n\njulia> rts, ris = (1:5)u\"minute\", 1000:1000:5000;\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> extrapolationmethod(ld) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", rts, ris, extrapolationmethod=Linear());\n\njulia> extrapolationmethod(ld)\nLinear()\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.interpolationmethod","page":"Retention Indices","title":"JuChrom.interpolationmethod","text":"interpolationmethod(mapper::RiMapper)\n\nReturn the name of the applied interpolation method.\n\nSee also RiMapper, extrapolationmethod, retentionindex.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> interpolationmethod(ld)\nNaturalCubicBSpline(false)\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.maxretentionindex","page":"Retention Indices","title":"JuChrom.maxretentionindex","text":"maxretentionindex(mapper::RiMapper)\n\nReturn the highest retention index used to construct the retention index mapper.\n\nSee also RiMapper, minretentionindex, retentionindices.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> maxretentionindex(ld)\n5000\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.maxretentiontime","page":"Retention Indices","title":"JuChrom.maxretentiontime","text":"maxretentiontime(chrom::AbstractChromatogram; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the highest retention time used to construct the retention index mapper. The  optional keyword argument timeunit lets you change the unit of the returned retention  time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also RiMapper, maxretentiontime, retentiontimes.\n\nExamples\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> maxretentiontime(ld) ≈ 5u\"minute\"\ntrue\n\njulia> maxretentiontime(ld, timeunit=u\"s\") ≈ 300u\"s\"\ntrue\n\njulia> maxretentiontime(ld, timeunit=u\"s\", ustripped=true) ≈ 300\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.metadata-Tuple{AbstractRiMapper}","page":"Retention Indices","title":"JuChrom.metadata","text":"metadata(mapper::AbstractRiMapper)\n\nReturn the metadata.\n\nSee also AbstractRiMapper, RiMapper.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000, metadata=Dict(:id => 7))\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 1 entry\n\njulia> metadata(ld)\nDict{Any, Any} with 1 entry:\n  :id => 7\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.minretentionindex","page":"Retention Indices","title":"JuChrom.minretentionindex","text":"minretentionindex(mapper::RiMapper)\n\nReturn the lowest retention index used to construct the retention index mapper.\n\nSee also RiMapper, maxretentionindex, retentionindices.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> maxretentionindex(ld)\n5000\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.minretentiontime","page":"Retention Indices","title":"JuChrom.minretentiontime","text":"minretentiontime(chrom::AbstractChromatogram; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the lowest retention time used to construct the retention index mapper. The optional  keyword argument timeunit lets you change the unit of the returned retention time. All  time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also RiMapper, maxretentiontime, retentiontimes.\n\nExamples\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> minretentiontime(ld) ≈ 1u\"minute\"\ntrue\n\njulia> minretentiontime(ld, timeunit=u\"s\") ≈ 60u\"s\"\ntrue\n\njulia> minretentiontime(ld, timeunit=u\"s\", ustripped=true) ≈ 60\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.retentionindex-Tuple{RiMapper, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Retention Indices","title":"JuChrom.retentionindex","text":"retentionindex(mapper::RiMapper, retentiontime::Unitful.Time)\n\nReturn the retention index associated with a given retention time.\n\nSee also RiMapper, retentionindices, maxretentionindex,  minretentionindex.\n\nExamples\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris)\nRiMapper {index name: Kovats, calibration points: 4}\nretention times: 1.2 minute, 2.4 minute, 3.8 minute, 5.0 minute\nretention indices: 1000, 2000, 3000, 4000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\njulia> retentionindex(ld, 1.8u\"minute\") ≈ 1516.9172932330828\ntrue\n\njulia> retentionindex(ld, 1.1u\"minute\") ≈ 913.9194139194141\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> ris = retentionindex.(ld, [2, 3]u\"minute\");  # broadcasting across multiple RT values\n\njulia> ris ≈ [1683.3751044277362, 2430.719656283566]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.retentionindex-Tuple{AbstractChromatogram, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Retention Indices","title":"JuChrom.retentionindex","text":"retentionindex(chrom::AbstractChromatogram, retentiontime::Unitful.Time; \ninfo::Bool=false)\n\nReturn the retention index corresponding to a given retention time.\n\nSee also RiMapper, retentionindices, maxretentionindex,  minretentionindex.\n\nExamples\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> chrom = Chrom(Int64[1, 2, 3]u\"s\", Int32[12, 956, 1], rimapper=ld);\n\njulia> retentionindex(chrom, 1.8u\"minute\") ≈ 1516.9172932330828\ntrue\n\njulia> retentionindex(chrom, 1.1u\"minute\") ≈ 913.9194139194141\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> ris = retentionindex.(chrom, [2, 3]u\"minute\");  # broadcasting across multiple RT values\n\njulia> ris ≈ [1683.3751044277362, 2430.719656283566]\ntrue\n\njulia> chrom = Chrom(Int64[1, 2, 3]u\"s\", Int32[12, 956, 1]);\n\njulia> retentionindex(chrom, 120u\"s\")\nERROR: ArgumentError: no retention index mapper implemented\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.retentionindexname-Tuple{RiMapper}","page":"Retention Indices","title":"JuChrom.retentionindexname","text":"retentionindexname(mapper::RiMapper)\n\nReturn the retention index name.\n\nSee also AbstractRiMapper, RiMapper.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:10)u\"minute\", 1000:1000:10000);\n\njulia> retentionindexname(ld)\n\"Kovats\"\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.retentionindices","page":"Retention Indices","title":"JuChrom.retentionindices","text":"retentionindices(mapper::RiMapper)\n\nReturn the retention indices used to construct the retention index mapper. Note: the  function returns a reference to the data structure.\n\nSee also RiMapper, maxretentionindex, minretentionindex,  retentiontimes.\n\nExample\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> retentionindices(ld)  # reference to the data structure\n4-element Vector{Int64}:\n 1000\n 2000\n 3000\n 4000\n\njulia> retentionindices(ld)[:]  # a copy of these values\n4-element Vector{Int64}:\n 1000\n 2000\n 3000\n 4000\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.retentiontimes","page":"Retention Indices","title":"JuChrom.retentiontimes","text":"retentiontimes(mapper::RiMapper; timeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the retention times used to construct the retention index mapper. The optional  keyword argument timeunit lets you change the unit of the returned retention times. All  time units defined in the package Unitful.jl  (e.g., u\"s\", u\"minute\") are supported. The optional keyword argument ustripped lets  you choose whether to include the unit in the returned values. Note: If no time unit  conversion is applied and the unit is not stripped, the function returns a reference to the  data structure.\n\nSee also RiMapper, maxretentiontime, minretentiontime,  retentionindices.\n\nExample\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> retentiontimes(ld)  # reference to the data structure\n4-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 1.2 minute\n 2.4 minute\n 3.8 minute\n 5.0 minute\n\njulia> retentiontimes(ld)[:]  # a copy of these values\n4-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 1.2 minute\n 2.4 minute\n 3.8 minute\n 5.0 minute\n\njulia> retentiontimes(ld, timeunit=u\"s\")\n4-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n  72.0 s\n 144.0 s\n 228.0 s\n 300.0 s\n\njulia> retentiontimes(ld, timeunit=u\"s\", ustripped=true)\n4-element Vector{Float64}:\n  72.0\n 144.0\n 228.0\n 300.0\n\n\n\n\n\n","category":"function"},{"location":"tutorials/retentionindices/#Retention-Indices","page":"Retention Indices","title":"Retention Indices","text":"","category":"section"},{"location":"tutorials/retentionindices/#Example-1:-Calibration-Points-from-a-Delimited-File","page":"Retention Indices","title":"Example 1: Calibration Points from a Delimited File","text":"","category":"section"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Let's assume we have a set of calibration points for calculating the  Kovats retention index,  stored in a delimited file. The first step is to read and format the data so it can  be passed to the RiMapper constructor. In this example, we are using a .CAL file  generated by the AMDIS  software. The contents of the file example1.CAL are as follows:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"4.154 900.0 98 1478 Nonane\n5.635 1000.0 100 1215 Decane\n7.145 1100.0 95 1606 Undecane\n8.628 1200.0 100 1762 Dodecane\n10.043 1300.0 100 1782 Tridecane\n  ⋮\n25.435 3400.0 92 920 Tetratriacontane\n27.204 3500.0 90 819 Pentatriacontane\n29.366 3600.0 91 723 Hexatriacontane\n32.026 3700.0 88 602 Heptatriacontane\n35.273 3800.0 85 493 Octatriacontane","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"As we can see, the file contains whitespace-separated columns, but only the first two are  relevant for our purposes. The first column lists the retention times (in minutes), while  the second column provides the corresponding retention indices.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We will use a function from the  DelimitedFiles.jl package, which comes  with Julia, to read the file contents. Additionally, we need to  assign the minute time unit to the time values. Since  JuChrom.jl re-exports names from the  Unitful.jl package, we will also load  JuChrom.jl at this stage. To plot the inferred  mapping function, we will further load the  CairoMakie.jl package from  the Makie visualization ecosystem. If you haven't installed them  yet, you may need to do so. Additionally, we explicitly activate the CairoMakie backend to  ensure it is used, especially if another backend was previously active in the same session.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"using CairoMakie, DelimitedFiles, JuChrom\nCairoMakie.activate!()\n\nfilename = \"example1.CAL\"\nfile = joinpath(JuChrom.calibration, filename)\ndata_cells = readdlm(file; header=false)  # set header=true if the file contains a header","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"The output above displays the contents of the matrix referred to by the variable  data_cells at this point. We will use slice notation to extract the values from the  first and second columns. Additionally, we will convert these values to Float64 and  append the minute time unit to the retention time values. The following two lines of code  will achieve this:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"rts = convert(Vector{Float64}, data_cells[:, 1]) * u\"minute\"","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"ris = convert(Vector{Float64}, data_cells[:, 2])","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We can now create a RiMapper object by calling its constructor with the required  arguments, along with any optional ones if needed. The mandatory arguments include the  name of the retention index (in our case,  Kovats), the retention time, and  the corresponding retention indices. In this example, we also store the name of the  calibration file as metadata.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"ld = RiMapper(\"Kovats\", rts, ris, metadata=Dict(:filename => filename))","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Since we did not explicitly specify an interpolation method,  the constructor defaulted to NaturalCubicBSpline for interpolation.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We now have a RiMapper object that allows us to calculate the  retentionindex for a given retention time of interest. We'll use this to plot  the mapping function. Since we will be plotting additional mapping functions, we'll  encapsulate the code for plotting the mapping function into a reusable function that can  be called multiple times.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"function plotmappingfunction(ld::RiMapper, outputfile::AbstractString)\n  # Create figure\n  f = Figure(; size=(1200, 600))\n\n  # Create axis in figure, including informative title and axis labels\n  title = get(metadata(ld), :filename, \"\")\n  ri_name = retentionindexname(ld)\n  timeunit = unit(eltype(retentiontimes(ld)))\n  ax = Axis(f[1,1], title=title, xlabel=\"Scan time [$timeunit]\", \n    ylabel=\"$ri_name retention index\")\n\n  # Plot calibration points\n  cal = scatter!(ax, retentiontimes(ld, ustripped=true), retentionindices(ld), color=:red)\n\n  # Plot interpolated values\n  xs = LinRange(minretentiontime(ld), maxretentiontime(ld), 1000)\n  itp = lines!(ax, ustrip(xs), retentionindex.(ld, xs), color=:blue)\n\n  # Add an informative legend\n  axislegend(ax, [cal, itp], [\"calibration points\", \"interpolation\"], position = :lt, \n    orientation = :horizontal)\n\n  # Save figure in svg file format\n  save(outputfile, f)\nend\n\nplotmappingfunction(ld, \"rt2ri.svg\")\nnothing # hide","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"This will produce the following  Scalable Vector Graphics (SVG) file:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"(Image: )","category":"page"},{"location":"tutorials/retentionindices/#Example-2:-Calibration-Points-from-an-Excel-File","page":"Retention Indices","title":"Example 2: Calibration Points from an Excel File","text":"","category":"section"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"In this example, we assume that a set of calibration points for calculating the  Kovats retention index  has been stored in an Excel file, possibly as a result of a manual entry. The relevant  data can be found in the first sheet of the file example1.xlsx, named Table1. ","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We will use the XLSX.jl package to read the  contents of the Excel file. As in the previous example, we need to assign the time values a  unit of minutes. To accomplish this, we will import  JuChrom.jl, which re-exports functionality from  the Unitful.jl package.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"using JuChrom\nimport XLSX\n\nfilename = \"example1.xlsx\"\nfile = joinpath(JuChrom.calibration, filename)\nsheetname = \"Table1\"\nexcel_cells = \"A1:B30\"\n\ndata_cells = XLSX.readdata(file, sheetname, excel_cells)","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"The output above shows the contents of the matrix stored in the variable data_cells at  this point. As in the previous example, we will use slice notation to extract the values  from the first and second columns, convert them to Float64, and append the minute time  unit to the retention time values.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"timeunit = u\"minute\"\nrts = convert(Vector{Float64}, data_cells[:, 1]) * timeunit\nris = convert(Vector{Float64}, data_cells[:, 2])\nld = RiMapper(\"Kovats\", rts, ris, metadata=Dict(:filename => filename))","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We could reuse the plotting function from the first example to visualize the data. However,  we will refrain from doing so here, as the values in the Excel file are identical to those  in the delimited file. Instead, we will discuss an example where the imported calibration  points result in an error when inferring a NaturalCubicBSpline interpolant.","category":"page"},{"location":"tutorials/retentionindices/#Example-3:-Error-in-Inferring-NaturalCubicBSpline-Interpolant","page":"Retention Indices","title":"Example 3: Error in Inferring NaturalCubicBSpline Interpolant","text":"","category":"section"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"In the two previous examples, the computation of a natural cubic B-spline for calculating a  continuously increasing retention index worked as expected. However, this is not always  the case. If the computed B-spline contains critical points that would cause the retention  index to decrease as retention time increases, the creation of the RiMapper would  result in an error. Let's examine an example. The contents of the file example2.CAL are  as follows:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"3.394 600.0 100 742 Hexane\n4.154 900.0 98 1478 Nonane\n5.635 1000.0 100 1215 Decane\n7.145 1100.0 95 1606 Undecane\n8.628 1200.0 100 1762 Dodecane\n  ⋮\n25.435 3400.0 92 920 Tetratriacontane\n27.204 3500.0 90 819 Pentatriacontane\n29.366 3600.0 91 723 Hexatriacontane\n32.026 3700.0 88 602 Heptatriacontane\n35.273 3800.0 85 493 Octatriacontane","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"The data is similar to that in example1.CAL, with the only difference being that  example2.CAL includes the retention time and retention index of Hexane as an additional  calibration point. We'll run the same commands as in the previous example, but this time,  we'll specify a different input file and wrap the RiMapper call in a try/ catch block to handle any exceptions.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"using CairoMakie, DelimitedFiles, JuChrom\nCairoMakie.activate!()\n\nfilename = \"example2.CAL\"\nfile = joinpath(JuChrom.calibration, filename)\ndata_cells = readdlm(file; header=false)\n\nrts = convert(Vector{Float64}, data_cells[:, 1]) * u\"minute\"\nris = convert(Vector{Float64}, data_cells[:, 2])\n\ntry\n  global ld = RiMapper(\"Kovats\", rts, ris, metadata=Dict(:filename => filename))\ncatch e\n  println(e)\nend","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"As shown in the output, the creation of a natural cubic B-spline that predicts  continuously increasing retention indices with increasing retention time has failed.  However, we can still force the B-spline interpolator to be returned, even if it contains  critical points. This is achieved by explicitly specifying NaturalCubicBSpline  as interpolator method and setting the force option in its keyword argument to true.  This approach can be useful for identifying problematic or erroneous calibration points.  Let's give it a try.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"ld = RiMapper(\"Kovats\", rts, ris, metadata=Dict(:filename => filename), \n  interpolationmethod=NaturalCubicBSpline(force=true))","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Let's use the returned RiMapper object to plot the compromised mapping function  using the code from the previous example.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"# <- Insert plotmappingfunction code here\nplotmappingfunction(ld, \"rt2ri_2.svg\")\nnothing # hide","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"This will produce the following  Scalable Vector Graphics (SVG) file:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"(Image: )","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"As observed, the sharp increase in the retention index between 3.394 and 4.154 minutes  prompted the creation of a B-spline featuring two critical points: a local maximum at  5.128 minutes and a local minimum at 5.526 minutes. This outcome is not due to Hexane  being incorrectly identified or associated with an incorrect retention time. Instead,  the pronounced disparity in the retention time–retention index relationship in the first  segment of the B-spline, compared to the following segments, causes the B-spline to  oscillate. This oscillation suggests that the available set of calibration points at the  start of the run is insufficient for reliable prediction of retention indices in this  region using the chosen interpolation method. It is entirely possible that a denser  sampling of calibration points at the beginning of the run could resolve this issue,  particularly given the large RI interval between Hexane and Nonane compared to subsequent  calibration points. ","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"If the RiMapper is intended to interpolate values between, for example, minutes  10 and 30, the simplest solution might be to omit this calibration point. Alternatively,  one could choose the PiecewiseLinear interpolation method, which avoids  oscillations. However, it introduces discontinuities in its derivative, making it a less  desirable interpolation method.","category":"page"},{"location":"tutorials/retentionindices/#Example-4:-Plotting-TIC-against-RI","page":"Retention Indices","title":"Example 4: Plotting TIC against RI","text":"","category":"section"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"It is often preferred to plot chromatographic intensity values against retention index  values rather than scan time. This requires chromatographic run data and corresponding  calibration data, which allow the calculation of an RiMapper for converting retention  times into retention indices. ","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Let's assume we wish to plot total ion chromatogram (TIC) intensities from a gas  chromatography/mass spectrometry (GCMS) run against  Kovats retention index values.  In this example, the run file is stored in the ChemStationMS data format in the  folder ON16150_April17_2024_I.D. The corresponding calibration file,  2024-04-11_C7-C40_11_APR_24_V09.CAL, contains retention time and retention index value  pairs in the AMDIS .CAL  file format (see Examples 1 and 3 above).","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"To load the calibration file data, we will again use the  DelimitedFiles.jl package, which comes  with Julia. We will need the  JuChrom.jl package to read the ChemStation MS  run data and to process and apply the calibration file data. Finally, we will use the  CairoMakie.jl package to  generate the desired figure. Note that you may need to install these packages if  you haven't done so already.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We begin by reading and processing the calibration file data to create an  RiMapper object, following the general procedure outlined in Example 1.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"using CairoMakie, DelimitedFiles, JuChrom\nCairoMakie.activate!()\n\ncalpath = joinpath(JuChrom.calibration, \"empirical_data\", \"calfiles\")\ncalfile = joinpath(calpath, \"2024-04-11_C7-C40_11_APR_24_V09.CAL\")\n\ncells = readdlm(calfile; header=false)\nrts = convert(Vector{Float64}, cells[:, 1]) * u\"minute\"\nris = convert(Vector{Float64}, cells[:, 2])\nld = RiMapper(\"Kovats\", rts, ris)","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"As indicated by the output, the computation of the RiMapper was successful (refer  to Example 3 for handling errors). We can now proceed with reading and processing the GCMS  run data.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"runpath = joinpath(JuChrom.calibration, \"empirical_data\", \"runs\")\nrunfolder = joinpath(runpath, \"ON16150_April17_2024_I.D\")\nchrom = importdata(runfolder, ChemStationMS())\nrimapper!(chrom, ld)  # stores a reference to the RiMapper in ChromMS object\ntic = totalionchromatogram(chrom)","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We now have everything set to generate the desired figure. In this specific example, we  only map intensities at retention times that fall within the range of the calibration  points, avoiding the extrapolation of retention indices. Additionally, we allow further  restriction of the retention index range to be plotted in the figure.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"ri_min, ri_max = 900, 1800\n\nf = Figure(size=(1200, 600))\nax = Axis(f[1,1], xlabel=\"Kovats retention index\", ylabel=\"Abundance\")\nris, ints = [], []\nfor i in 1:scancount(tic)\n  rt = scantime(tic, i)\n  if minretentiontime(ld) ≤ rt ≤ maxretentiontime(ld)\n    ri = retentionindex(rimapper(tic), rt)\n    ri_min ≤ ri ≤ ri_max || continue\n    push!(ris, ri)\n    push!(ints, intensity(tic, i))\n  end\nend\nlength(ris) ≥ 2 && lines!(ax, ris, ints, color=:blue)\n\nsave(\"tic_against_ri.svg\", f)\nnothing # hide","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"This will produce the following SVG file:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"(Image: )","category":"page"},{"location":"tutorials/retentionindices/#Example-5:-Plotting-multiple-TICs-against-RI","page":"Retention Indices","title":"Example 5: Plotting multiple TICs against RI","text":"","category":"section"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"In some experimental designs, it is useful to plot the intensity values of different runs  against retention index values in a single figure. In this example, we assume two treatment  groups, labeled I and R, with two replicates for each group. The experimental data were  analyzed using gas chromatography/mass spectrometry (GCMS).","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We aim to plot the total ion chromatogram (TIC) intensities from the corresponding GCMS  runs against Kovats retention indices. In this example, the run files are again stored in  the ChemStationMS data format. The corresponding calibration files, which contain retention  time and retention index value pairs, are in the  AMDIS .CAL file format  (see Examples 1, 3, and 4 above). To automatically process this data, we need a table  indicating which calibration file is associated with each run. This information is stored  in the run_calfilename_relation.xlsx file in Excel format.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"As in Example 4, we require functionality from the  CairoMakie.jl,  DelimitedFiles.jl, and  JuChrom.jl packages. Additionally, we need the  XLSX.jl package to read the Excel file. Note that  you need to install these packages if they are not already installed.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"The relevant data in the Excel file is located in the sheet labeled Table1. Column A  contains the names of the run folders, and column B contains the names of the  corresponding .CAL files. Since we have four runs and no headers, the area of interest  is A1:B4. We'll read these cells and store the data in a dictionary, using the run names  as keys to retrieve the associated .CAL file names.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"using CairoMakie, DelimitedFiles, JuChrom\nCairoMakie.activate!()\nimport XLSX\n\nfile = joinpath(JuChrom.calibration, \"empirical_data\", \"run_calfilename_relation.xlsx\")\ndata_cells = XLSX.readdata(file, \"Table1\", \"A1:B4\")\ncal4run = Dict(data_cells[row, 1] => data_cells[row, 2] for row in axes(data_cells, 1))","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Since two runs are associated with each .CAL file, it makes sense to first process the  .CAL files and create a dictionary from which we can retrieve the RiMapper generated from  a given .CAL file.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"mpr4cal = Dict()\nfor calfilename in unique(values(cal4run))\n  calfile = joinpath(JuChrom.calibration, \"empirical_data\", \"calfiles\", calfilename)\n  cells = readdlm(calfile; header=false)\n  rts = convert(Vector{Float64}, cells[:, 1]) * u\"minute\"\n  ris = convert(Vector{Float64}, cells[:, 2])\n  mpr4cal[calfilename] = RiMapper(\"Kovats\", rts, ris)\nend","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"mpr4cal # hide","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Next, we read the GCMS data and store a reference to the corresponding RiMapper object  in the resulting ChromMS object. The ChromMS objects are then collected in a list for  further processing.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"chroms = []\nfor run in keys(cal4run)\n  runfolder = joinpath(JuChrom.calibration, \"empirical_data\", \"runs\", run)\n  chrom = importdata(runfolder, ChemStationMS())\n  rimapper!(chrom, mpr4cal[cal4run[run]])\n  push!(chroms, chrom)\nend","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"We now have all the data needed to generate a figure that plots the TIC from each run  against the Kovats retention index.  Since the plotted lines will overlap, we will make them transparent by setting the alpha  channel to a value less than one. The treatment group is indicated by the letters I and  R at the end of the run folder name, which is stored in the metadata. We will  use this information to plot the TICs of the two groups in different colors.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"ri_min, ri_max = 900, 1800\nalpha = 0.5\n\nf = Figure(size=(1200, 600))\nax = Axis(f[1,1], xlabel=\"Kovats retention index\", ylabel=\"Abundance\")\nfor chrom in chroms\n  tic = totalionchromatogram(chrom)\n  ld = rimapper(tic)\n  ris, ints = [], []\n  for i in 1:scancount(tic)\n    rt = scantime(tic, i)\n    if minretentiontime(ld) ≤ rt ≤ maxretentiontime(ld)\n      ri = retentionindex(rimapper(tic), rt)\n      ri_min ≤ ri ≤ ri_max || continue\n      push!(ris, ri)\n      push!(ints, intensity(tic, i))\n    end\n  end\n  if length(ris) ≥ 2\n    c = endswith(metadata(tic)[:sample], \"R\") ? (:blue, alpha) : (:red, alpha)\n    lines!(ax, ris, ints, color=c)\n  end\nend\n\nsave(\"tics_in_one_axis.svg\", f)\nnothing # hide","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"This will produce the following SVG file:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"(Image: )","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"Although the TICs for the two treatment groups are plotted in different colors, it can  still be difficult to visually discern systematic differences between them. Furthermore,  if each treatment group contains more runs, the plot can become cluttered and overloaded.  Therefore, it may be helpful to plot the TICs for the two treatment groups on separate,  mirrored axes along the x-axis. The following lines of code generate such a figure.","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"ri_min, ri_max = 900, 1800\nalpha = 0.5\n\nf2 = Figure(size=(1200, 600))\nax1 = Axis(f2[1,1], limits = (nothing, nothing, 0, nothing), ylabel=\"Abundance\")\nax2 = Axis(f2[2,1], limits = (nothing, nothing, 0, nothing), \n  xlabel=\"Kovats retention index\", ylabel=\"Abundance\", yreversed=true)\n\nlinkxaxes!(ax1, ax2)\nrowgap!(f2.layout, 0)\nhidexdecorations!(ax1, grid=false)\n\nfor chrom in chroms\n  tic = totalionchromatogram(chrom)\n  ris, ints = [], []\n  for i in 1:scancount(tic)\n    rt = scantime(tic, i)\n    if minretentiontime(rimapper(tic)) ≤ rt ≤ maxretentiontime(rimapper(tic))\n      ri = retentionindex(rimapper(tic), rt)\n      ri_min ≤ ri ≤ ri_max || continue\n      push!(ris, ri)\n      push!(ints, intensity(tic, i))\n    end\n  end\n  if length(ris) ≥ 2\n    if endswith(metadata(chrom)[:sample], \"R\")\n      lines!(ax1, ris, ints, color=(:blue, alpha))\n    else\n      lines!(ax2, ris, ints, color=(:red, alpha))\n    end\n  end\nend\n\nsave(\"tics_in_two_axes.svg\", f2)\nnothing # hide","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"This will produce the following SVG file:","category":"page"},{"location":"tutorials/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"(Image: )","category":"page"},{"location":"internals/inputoutput/#InputOutput","page":"InputOutput","title":"InputOutput","text":"","category":"section"},{"location":"internals/inputoutput/#JuChrom.InputOutput.FileExistsError","page":"InputOutput","title":"JuChrom.InputOutput.FileExistsError","text":"JuChrom.InputOutput.FileExistsError([msg::AbstractString]) <: Exception\n\nFile already exists. msg is an optional descriptive error message.\n\nSee also IOError.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.IOError","page":"InputOutput","title":"JuChrom.InputOutput.IOError","text":"JuChrom.InputOutput.IOError([msg::AbstractString]) <: Exception\n\nThere was a problem reading or writing a file. msg is an optional descriptive error  message.\n\nSee also FileExistsError.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.Source","page":"InputOutput","title":"JuChrom.InputOutput.Source","text":"JuChrom.InputOutput.Source\n\nSupertype for all data sources.\n\nSee also File, Path.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.File","page":"InputOutput","title":"JuChrom.InputOutput.File","text":"JuChrom.InputOutput.File() <: Source\n\nType that indicates a source is a file.\n\nSee also Source, Path.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.Path","page":"InputOutput","title":"JuChrom.InputOutput.Path","text":"JuChrom.InputOutput.Path() <: Source\n\nType that indicates a source is a path.\n\nSee also Source, File.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.buildxic","page":"InputOutput","title":"JuChrom.InputOutput.buildxic","text":"JuChrom.InputOutput.buildxic(pointcounts::AbstractVector{<:Integer}, \nionvec::AbstractVector{<:Real}, intsvec::AbstractVector{<:Real})\n\nReturn a sorted list of ions and an intensity matrix with the number of columns equal to  the number of ions in the sorted list and the number of rows equal to the number of scans.  This is based on a vector that stores the number of ion-intensity pairs per scan  (pointcounts), a vector of continuously recorded ions throughout the run (ionvec), and  a vector of intensity values associated with those ions (intsvec).\n\nExamples\n\njulia> pointcounts = [2, 3, 2];\n\njulia> ionvec = [85.1, 100.2, 85.2, 99.9, 112.1, 84.9, 100.6];\n\njulia> intsvec = Int64[12, 234, 23, 324, 45422, 21, 523];\n\njulia> mzs, xic = JuChrom.InputOutput.buildxic(pointcounts, ionvec, intsvec);\n\njulia> mzs\n7-element Vector{Float64}:\n  84.9\n  85.1\n  85.2\n  99.9\n 100.2\n 100.6\n 112.1\n\njulia> xic\n3×7 Matrix{Int64}:\n  0  12   0    0  234    0      0\n  0   0  23  324    0    0  45422\n 21   0   0    0    0  523      0\n\n\n\n\n\n","category":"function"},{"location":"man/export/#Data-Export","page":"Data Export","title":"Data Export","text":"","category":"section"},{"location":"man/export/#JuChrom.InputOutput.DelimitedTextWriter.DelimitedText","page":"Data Export","title":"JuChrom.InputOutput.DelimitedTextWriter.DelimitedText","text":"DelimitedText(; delim::Union{AbstractChar, AbstractString}=\"\\t\") <: Fileformat\n\nReturn a DelimitedText file format object. The optional delim keyword argument allows  you to specify the column delimiter, which can be either a single character or a string.  If the provided filename lacks a suffix, an appropriate one will be automatically appended.\n\nSee also FileFormat, exportdata.\n\nExamples\n\njulia> DelimitedText()\nDelimitedText{String}(\"\t\")\n\njulia> DelimitedText(delim=';')\nDelimitedText{Char}(';')\n\n\n\n\n\n","category":"type"},{"location":"man/export/#JuChrom.InputOutput.ExcelWriter.Excel","page":"Data Export","title":"JuChrom.InputOutput.ExcelWriter.Excel","text":"Excel(; sheetname::AbstractString) <: FileFormat\n\nReturns an Excel file format object. The optional keyword argument sheetname allows you  to specify the name of the sheet to operate on.\n\nSee also FileFormat, exportdata.\n\nExamples\n\njulia> Excel()\nExcel{Nothing}(nothing)\n\njulia> Excel(sheetname=\"TIC\")\nExcel{String}(\"TIC\")\n\n\n\n\n\n","category":"type"},{"location":"man/export/#JuChrom.InputOutput.exportdata-Tuple{AbstractChrom, AbstractString, FileFormat}","page":"Data Export","title":"JuChrom.InputOutput.exportdata","text":"exportdata(chrom::AbstractChrom, file::AbstractString, fileformat::FileFormat; \ntimeunit::Unitful.TimeUnits, overwrite::Bool=false)\n\nExport the scan times and corresponding intensity values from the AbstractChrom object to a  file in the specified format. If the AbstractChrom object includes a RiMapper, it will also  export retention indices to the file. The optional timeunit parameter allows you to  define the unit of measurement for the scan times in the output. All time units supported  by the package Unitful.jl (e.g., u\"s\",  u\"minute\") can be used. Additionally, the optional overwrite keyword argument specifies  whether an existing target file should be overwritten.\n\nSee also AbstractChrom, DelimitedText, Excel.\n\nExamples\n\njulia> chrom = Chrom((1:3)u\"minute\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 minute, 2 minute, 3 minute\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> exportdata(chrom, \"./delimtest\", DelimitedText());\n\njulia> exportdata(chrom, \"./exceltest\", Excel(sheetname=\"TIC\"));\n\n\n\n\n\n\n","category":"method"},{"location":"man/export/#JuChrom.InputOutput.exportdata-Tuple{AbstractChromMS, AbstractString, FileFormat}","page":"Data Export","title":"JuChrom.InputOutput.exportdata","text":"exportdata(chrom::AbstractChromMS, file::AbstractString, fileformat::FileFormat; \ntimeunit::Unitful.TimeUnits, overwrite::Bool=false)\n\nExport the scan times, ions, and corresponding intensity values from the AbstractChromMS  object to a file in the specified format. If the AbstractChromMS object includes a  RiMapper, it will also export retention indices to the file. The optional timeunit  parameter allows you to define the unit of measurement for the scan times in the output.  All time units supported by the package  Unitful.jl (e.g., u\"s\", u\"minute\") can be  used. Additionally, the optional overwrite keyword argument specifies whether an existing  target file should be overwritten.\n\nSee also AbstractChromMS, DelimitedText, Excel.\n\nExamples\n\njulia> chrom = Chrom((1:3)u\"minute\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 minute, 2 minute, 3 minute\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> exportdata(chrom, \"./delimtest\", DelimitedText());\n\njulia> exportdata(chrom, \"./exceltest\", Excel(sheetname=\"GCMS\"));\n\n\n\n\n\n\n","category":"method"},{"location":"internals/deconvolution/#Deconvolution","page":"Deconvolution","title":"Deconvolution","text":"","category":"section"},{"location":"internals/deconvolution/#JuChrom.Deconvolution.LocalMaxima","page":"Deconvolution","title":"JuChrom.Deconvolution.LocalMaxima","text":"JuChrom.LocalMaxima(values::AbstractVector{<:Real}; \nstartindex::Integer=firstindex(values), stopindex::Integer=lastindex(values))\n\nReturn an iterator that yields the index range of each local maximum until no more local  maxima are found. If the maximum is a single peak, the range will have a length of 1; if a  plateau maximum is found, the range will have a length greater than 1. The optional keyword  arguments startindex and stopindex allow you to restrict the search range for the  maximum. Note that startindex and stopindex must be at least two indices apart (e.g.,  startindex=1, stopindex=3).\n\nSee also nextlocalmaximum.\n\nExamples\n\njulia> values = [4, 3, 5, 3, 6, 6, 6, 4, 7];\n\njulia> for lm in JuChrom.LocalMaxima(values); println(lm); end\n3:3\n5:7\n\njulia> for lm in JuChrom.LocalMaxima(values, startindex=3); println(lm); end\n5:7\n\njulia> for lm in JuChrom.LocalMaxima(values, stopindex=7); println(lm); end\n3:3\n\njulia> for lm in JuChrom.LocalMaxima(values, startindex=4, stopindex=8); println(lm); end\n5:7\n\njulia> for lm in JuChrom.LocalMaxima(values, startindex=4, stopindex=5); println(lm); end\nERROR: ArgumentError: stopindex not greater than startindex + 1: 4 5\n[...]\n\njulia> length(values)\n9\n\njulia> for lm in JuChrom.LocalMaxima(values, startindex=8); println(lm); end\nERROR: ArgumentError: stopindex not greater than startindex + 1: 8 9\n[...]\n\n\n\n\n\n","category":"type"},{"location":"internals/deconvolution/#JuChrom.Deconvolution.lsfit","page":"Deconvolution","title":"JuChrom.Deconvolution.lsfit","text":"JuChrom.lsfit(xs::AbstractVector{<:Union{Real, Unitful.Quantity{<:Real}}}, \nys::AbstractVector{<:Union{Real, Unitful.Quantity{<:Real}}})\n\nReturn the intercept and slope from a simple linear regression, fitting the line of best  fit (in the form y = mx + b) for the given data points xs and ys using the least  squares method. The function expects two arguments: a vector of x-coordinates (independent  variable), xs, and a vector of y-coordinates (dependent variable), ys. Both vectors  must have the same length and contain at least two values. The function throws an  ArgumentError if the lengths of xs and ys differ or if either vector contains fewer  than two values.\n\nThe function calculates the slope (m) and intercept (b) for the line of best fit using  the formulas\n\nm = Σ((xᵢ - x̄)(yᵢ - ȳ)) / Σ((xᵢ - x̄)²)\nb = ȳ - m * x̄\n\nwhere x̄ and ȳ are the means of the xs and ys vectors, respectively.\n\nExamples\n\njulia> xs, ys = [1.0, 2.0, 3.0, 4.0, 5.0], [1.0, 2.0, 3.0, 4.0, 5.0];\n\njulia> JuChrom.lsfit(xs, ys) .≈ (0.0, 1.0)\n(true, true)\n\n\n\n\n\n","category":"function"},{"location":"internals/deconvolution/#JuChrom.Deconvolution.nextlocalmaximum","page":"Deconvolution","title":"JuChrom.Deconvolution.nextlocalmaximum","text":"JuChrom.nextlocalmaximum(values::AbstractVector{<:Real}; \nstartindex::Integer=firstindex(values), stopindex::Integer=lastindex(values))\n\nReturn the index range of the next local maximum. If the maximum is a single peak, the  range will have a length of 1; if a plateau maximum is found, the range will have a  length greater than 1. If no maximum is found, nothing is returned. The optional keyword  arguments startindex and startindex allow you to restrict the search range for the  maximum. Note that startindex and startindex must be at least two indices apart (e.g.,  startindex=1, stopindex=3).\n\nSee also LocalMaxima.\n\nExamples\n\njulia> values = [4, 3, 5, 3, 6, 6, 6, 4, 7];\n\njulia> JuChrom.nextlocalmaximum(values)  # finds 5\n3:3\n\njulia> JuChrom.nextlocalmaximum(values, startindex=4)  # finds pleateau maximum 6, 6, 6\n5:7\n\njulia> JuChrom.nextlocalmaximum(values, startindex=4, stopindex=7)  # finds nothing\n\njulia> length(values)\n9\n\njulia> JuChrom.nextlocalmaximum(values, startindex=8)  # implicit stopindex=9\nERROR: ArgumentError: stopindex not greater than startindex + 1: 8 9\n[...]\n\njulia> JuChrom.nextlocalmaximum(values, startindex=1, stopindex=2)\nERROR: ArgumentError: stopindex not greater than startindex + 1: 1 2\n[...]\n\n\n\n\n\n","category":"function"},{"location":"internals/deconvolution/#JuChrom.Deconvolution.stddev","page":"Deconvolution","title":"JuChrom.Deconvolution.stddev","text":"JuChrom.stddev(chrom::AbstractChromMS; windowsize::Integer=13, threshold::Real=0,\nnthreads::Integer=Threads.nthreads())::Tuple{Union{Float64, Nothing}, Int}\n\nReturn an estimate of the standard deviation (σ) in the intensity measurements of the  instrument used to infer the chromatographic data by analyzing intensity fluctuations  within user-defined scan windows (default: 13 scans). The function also returns the number  of windows considered in the computation as a second output. This approach is based on the  method described by Stein (1999) for estimating noise levels in chromatographic data, with  some modifications. In brief, only windows with intensity values above the specified  threshold (default: 0) are included. Additionally, the total number of transitions must  exceed half the window's scan count, and no more than two consecutive intensity values can  fall on the same side of the mean intensity within any given window. For windows that meet  these criteria, the absolute differences between intensity values and the median intensity  are used to calculate the median absolute deviation (MAD). Since intensity fluctuations are  proportional to the square root of the measured intensity, the MAD is normalized by  dividing it by the square root of the median intensity. The MAD is calculated for all  possible non-overlapping windows across the intensity values for all ions. The median of  the MAD values is then multiplied by 1.4826 to estimate σ, assuming that the  intensity-normalized fluctuations follow a normal distribution. If no suitable windows are  found for calculating σ, the function returns (nothing, 0).\n\nReference\n\nStein SE (1999): An integrated method for spectrum extraction and compound identification  from gas chromatography/mass spectrometry data. J. Am. Soc. Mass. Spectrom. 10: 770–781.\n\nExamples\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D\");\n\njulia> chrom = binions(importdata(dfolder, ChemStationMS()));\n\njulia> JuChrom.stddev(chrom) .≈ (1.989116630064713, 9874)\n(true, true)\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_MassHunterMS.D\");\n\njulia> chrom = binions(importdata(dfolder, MassHunterMS()));\n\njulia> JuChrom.stddev(chrom) .≈ (1.951017182665152, 10979)\n(true, true)\n\n\n\n\n\n","category":"function"},{"location":"#JuChrom.jl","page":"Home","title":"JuChrom.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for JuChrom.jl","category":"page"}]
}
