var documenterSearchIndex = {"docs":
[{"location":"man/register/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/ScanSeries/#ScansSeries","page":"ScansSeries","title":"ScansSeries","text":"","category":"section"},{"location":"man/ScanSeries/#JuChrom.AbstractScanSeries","page":"ScansSeries","title":"JuChrom.AbstractScanSeries","text":"abstract type AbstractScanSeries{S, R, M, I} <: Any\n\nAbstract supertype for objects representing a series of scan measurements, such as  chromatograms or mass spectra.\n\nThis type is parameterized as follows:\n\nS: Concrete scan type (a subtype of AbstractScan)\nR: Type of the separation (retention) unit (Unitful.Units subtype or Nothing)\nM: Type of the m/z unit (Unitful.Units subtype or Nothing)\nI: Type of the signal intensity unit (Unitful.Units subtype or Nothing)\n\nConcrete subtypes must provide at minimum:\n\nscans::AbstractVector{S}: ordered collection of scan objects\ninstrument, acquisition, sample, user: structured metadata as NamedTuples\nextras: optional unstructured metadata (Dict{String, Any})\n\nSubtypes may define additional fields as needed to support specific applications.\n\n\n\n\n\n","category":"type"},{"location":"man/ScanSeries/#JuChrom.AbstractChromScanSeries","page":"ScansSeries","title":"JuChrom.AbstractChromScanSeries","text":"abstract type AbstractChromScanSeries{S<:AbstractChromScan, R, I} <: AbstractScanSeries{S, R, Nothing, I}\n\nAbstract supertype for a series of chromatographic scans.\n\nThis type represents a sequence of AbstractChromScan objects, along with associated  metadata. It specializes AbstractScanSeries by setting the m/z unit type parameter M  to Nothing, as chromatographic scans do not include m/z values.\n\nType Parameters\n\nS: Concrete scan type, a subtype of AbstractChromScan\nR: Type of the separation (retention time) unit (Unitful.Units or Nothing)\nI: Type of the signal intensity unit (Unitful.Units or Nothing)\n\nConcrete subtypes must define at least:\n\nscans::AbstractVector{S}\ninstrument, acquisition, sample, user as NamedTuples\nextras::Dict{String, Any}\n\nSupports generic operations on chromatographic scan series.\n\n\n\n\n\n","category":"type"},{"location":"man/ScanSeries/#JuChrom.ChromScanSeries","page":"ScansSeries","title":"JuChrom.ChromScanSeries","text":"ChromScanSeries(\n    scans::Vector{<:AbstractChromScan};\n    instrument::NamedTuple=NamedTuple(),\n    acquisition::NamedTuple=NamedTuple(),\n    user::NamedTuple=NamedTuple(),\n    sample::NamedTuple=NamedTuple(),\n    extras::Dict{<:AbstractString, <:Any}=Dict()\n) -> ChromScanSeries\n\nConstructs a ChromScanSeries, representing an ordered collection of scans (subtypes of  AbstractChromScan) with associated metadata.\n\nArguments\n\nscans: A non-empty vector of chromatographic scan objects. All elements must be of the  same concrete subtype of AbstractChromScan.\ninstrument: (optional) Structured instrument metadata as a NamedTuple.\nacquisition: (optional) Acquisition parameters as a NamedTuple.\nuser: (optional) User-related metadata as a NamedTuple.\nsample: (optional) Sample-related metadata as a NamedTuple.\nextras: (optional) Unstructured metadata stored as a Dict{String, Any}.\n\nReturns\n\nA ChromScanSeries containing the scans and their associated metadata.\n\nThrows\n\nArgumentError if scans is empty.\nArgumentError if the element type of scans is not concrete.\n\nSee also AbstractScanSeries, AbstractChromScanSeries, scans.\n\nExamples\n\njulia> cs1 = ChromScan(1.0u\"minute\", 5.0u\"pA\");\n\njulia> cs2 = ChromScan(2.0u\"minute\", 8.0u\"pA\");\n\njulia> css = ChromScanSeries([cs1, cs2]; instrument=(detector=\"DAD\",));\n\njulia> scans(css) == [ChromScan(1.0u\"minute\", 5.0u\"pA\"), ChromScan(2.0u\"minute\", 8.0u\"pA\")]\ntrue\n\njulia> css.instrument\n(detector = \"DAD\",)\n\njulia> length(css)\n2\n\n\n\n\n\n","category":"type"},{"location":"man/ScanSeries/#JuChrom.AbstractMassScanSeries","page":"ScansSeries","title":"JuChrom.AbstractMassScanSeries","text":"abstract type AbstractMassScanSeries{S<:AbstractMassScan, R, M, I} <: AbstractScanSeries{S, R, M, I}\n\nAbstract supertype for a series of mass spectrometry scans.\n\nThis type represents a sequence of AbstractMassScan objects along with associated  metadata. It specializes AbstractScanSeries by including the m/z unit type parameter M,  which is relevant for mass spectrometry data.\n\nType Parameters\n\nS: Concrete scan type, a subtype of AbstractMassScan\nR: Type of the separation (retention time) unit (Unitful.Units or Nothing)\nM: Type of the m/z unit (Unitful.Units)\nI: Type of the signal intensity unit (Unitful.Units or Nothing)\n\nConcrete subtypes must define at least:\n\nscans::AbstractVector{S}\ninstrument, acquisition, sample, user as NamedTuples\nextras::Dict{String, Any}\n\nSupports generic operations on mass spectrometry scan series. ```\n\n\n\n\n\n","category":"type"},{"location":"man/ScanSeries/#JuChrom.MassScanSeries","page":"ScansSeries","title":"JuChrom.MassScanSeries","text":"MassScanSeries(\n    scans::Vector{<:AbstractMassScan};\n    instrument::NamedTuple=NamedTuple(),\n    acquisition::NamedTuple=NamedTuple(),\n    user::NamedTuple=NamedTuple(),\n    sample::NamedTuple=NamedTuple(),\n    extras::Dict{<:AbstractString, <:Any}=Dict()\n) -> MassScanSeries\n\nConstructs a MassScanSeries, representing an ordered collection of scans (subtypes of  AbstractMassScan) with associated metadata.\n\nArguments\n\nscans: A non-empty vector of mass scan objects. All elements must be of the same  concrete subtype of AbstractMassScan.\ninstrument: (optional) Structured instrument metadata as a NamedTuple.\nacquisition: (optional) Acquisition parameters as a NamedTuple.\nuser: (optional) User-related metadata as a NamedTuple.\nsample: (optional) Sample-related metadata as a NamedTuple.\nextras: (optional) Unstructured metadata stored as a Dict{String, Any}.\n\nReturns\n\nA MassScanSeries containing the scans and their associated metadata.\n\nThrows\n\nArgumentError if scans is empty.\nArgumentError if the element type of scans is not concrete.\n\nSee also\n\nAbstractScanSeries, AbstractMassScanSeries, scans\n\nExamples\n\njulia> ms1 = MassScan(1.0u\"s\", [100.0, 150.0], [10.0, 20.0]);\n\njulia> ms2 = MassScan(2.0u\"s\", [100.0, 150.0], [12.0, 22.0]);\n\njulia> mss = MassScanSeries([ms1, ms2]; acquisition=(mode=\"FullScan\",));\n\njulia> mss.acquisition.mode\n\"FullScan\"\n\njulia> length(mss)\n2\n\n\n\n\n\n","category":"type"},{"location":"man/ScanSeries/#JuChrom.acquisition-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.acquisition","text":"acquisition(series::AbstractScanSeries) -> NamedTuple\n\nReturns the acquisition metadata associated with the scan series.\n\nThe acquisition metadata typically includes details such as scan mode, method parameters,  instrument configuration, or other context relevant to how the data was acquired.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nA NamedTuple containing acquisition-related metadata.\n\nSee also AbstractScanSeries, instrument, user,  sample.\n\nExamples\n\njulia> s = [ChromScan(0.0u\"s\", 12.3), ChromScan(1.0u\"s\", 45.6)];\n\njulia> series = ChromScanSeries(s; acquisition=(mode=\"gradient\", method=\"HPLC-QC-42\"));\n\njulia> acquisition(series)\n(mode = \"gradient\", method = \"HPLC-QC-42\")\n\njulia> acquisition(series).method\n\"HPLC-QC-42\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.extras-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.extras","text":"extras(series::AbstractScanSeries) -> Dict{String, Any}\n\nReturns the unstructured extras associated with the scan series.\n\nThis dictionary may contain arbitrary key-value pairs that are not captured by the  structured fields such as instrument, acquisition, user, or sample.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nA Dict{String, Any} containing unstructured metadata.\n\nSee also instrument, acquisition, user, sample.\n\nExamples\n\njulia> s = [ChromScan(1.0u\"s\", 10.0u\"V\"), ChromScan(2.0u\"s\", 200.0u\"V\")];\n\njulia> series = ChromScanSeries(s, extras=Dict(\"run\"=>42, \"comment\"=>\"Baseline drift\"));\n\njulia> extras(series)\nDict{String, Any} with 2 entries:\n  \"run\"     => 42\n  \"comment\" => \"Baseline drift\"\n\njulia> extras(series)[\"qc_passed\"] = true;\n\njulia> extras(series)\nDict{String, Any} with 3 entries:\n  \"qc_passed\" => true\n  \"run\"       => 42\n  \"comment\"   => \"Baseline drift\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.intensities-Tuple{AbstractChromScanSeries}","page":"ScansSeries","title":"JuChrom.intensities","text":"intensities(series::AbstractChromScanSeries;\nunit::Union{Nothing, Unitful.Units}=nothing) -> Vector{<:Real} or Vector{<:Quantity}\n\nReturn the intensity values from each scan in a chromatographic scan series.   If the scan series stores unitful intensities and a unit is specified, the values are  converted accordingly.\n\nArguments\n\nseries: A concrete subtype of AbstractChromScanSeries containing chromatographic  scans.\nunit: (optional) A Unitful.Units object to convert intensities to. If omitted or  nothing, intensities are returned as stored.\n\nReturns\n\nA vector of intensity values, either as plain numbers or Quantitys, depending on the  stored data.\n\nThrows\n\nArgumentError if the scan series stores unitless intensities but a unit conversion is  requested.\nAssertionError if the series contains no scans.\n\nSee also AbstractChromScanSeries, scans, scancount.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 1.0u\"pA\");\n\njulia> s2 = ChromScan(2.0u\"s\", 2.0u\"pA\");\n\njulia> series = ChromScanSeries([s1, s2]);\n\njulia> intensities(series) == [1.0, 2.0]u\"pA\"\ntrue\n\njulia> intensities(series; unit=u\"fA\") == [1e3, 2e3]u\"fA\"\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.intensities-Tuple{AbstractMassScanSeries, Integer}","page":"ScansSeries","title":"JuChrom.intensities","text":"intensities(series::AbstractMassScanSeries, scanindex::Integer; \n            unit::Union{Nothing, Unitful.Units}=nothing) -> AbstractVector\n\nReturns the intensity values for the scan at the specified index within the given mass scan  series.\n\nArguments\n\nseries::AbstractMassScanSeries: The series of mass scans.\nscanindex::Integer: The index of the scan to extract intensities from.\nunit::Union{Nothing, Unitful.Units}: Optional unit to convert the returned  intensities into. If nothing, the scan's native unit is used.\n\nReturns\n\nAn AbstractVector of intensity values (possibly unitful) corresponding to the scan at  the specified index.\n\nThrows\n\nBoundsError if scanindex is outside the valid range of the scan series.\n\nExamples\n\njulia> ms1 = MassScan(1.0u\"s\", [100.0, 150.0], [10.0, 20.0]u\"pA\");\n\njulia> ms2 = MassScan(2.0u\"s\", [100.0, 150.0], [12.0, 22.0]u\"pA\");\n\njulia> mss = MassScanSeries([ms1, ms2]; acquisition=(mode=\"FullScan\",));\n\njulia> intensities(mss, 1) == [10.0, 20.0]u\"pA\"\ntrue\n\njulia> intensities(mss, 2; unit=u\"fA\") == [12e3, 22e3]u\"fA\"\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.intensity-Tuple{AbstractChromScanSeries, Integer}","page":"ScansSeries","title":"JuChrom.intensity","text":"intensity(series::AbstractChromScanSeries, scanindex::Integer; \n          unit::Union{Nothing, Unitful.Units}=nothing) -> Real\n\nReturns the intensity value for the chromatographic scan at the specified index within the  given chromatogram scan series.\n\nArguments\n\nseries::AbstractChromScanSeries: The series of chromatographic scans.\nscanindex::Integer: The index of the scan to extract the intensity from.\nunit::Union{Nothing, Unitful.Units}: Optional unit to convert the returned intensity  into. If nothing, the scan's native unit is used.\n\nReturns\n\nA scalar Real (possibly unitful) representing the intensity of the scan at the  specified index.\n\nThrows\n\nBoundsError if scanindex is outside the valid range of the scan series.\n\nExamples\n\njulia> cs1 = ChromScan(1.0u\"s\", 1.5u\"nA\");\n\njulia> cs2 = ChromScan(2.0u\"s\", 2.5u\"nA\");\n\njulia> css = ChromScanSeries([cs1, cs2]; acquisition=(mode=\"TIC\",));\n\njulia> intensity(css, 1)\n1.5 nA\n\njulia> intensity(css, 2; unit=u\"pA\")\n2500.0 pA\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.intensityunit-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.intensityunit","text":"intensityunit(series::AbstractScanSeries) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the intensity values of a scan series.\n\nThis function retrieves the intensity unit from the first scan in the series, assuming all scans have consistent units.\n\nArguments\n\nseries: A subtype of AbstractScanSeries.\n\nReturns\n\nA Unitful.Units subtype representing the intensity unit, or nothing if unspecified.\n\nExamples\n\njulia> ms = MassScan(1.0u\"s\", [100.0], [10.0]u\"pA\")\n       series = MassScanSeries([ms]);\n\njulia> intensityunit(series)\npA\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.instrument-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.instrument","text":"instrument(series::AbstractScanSeries) -> NamedTuple\n\nReturns the instrument metadata associated with the scan series.\n\nThis typically includes information about the hardware used for data acquisition, such as  detector type, manufacturer, model, or configuration parameters.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nA NamedTuple containing instrument-specific metadata.\n\nSee also AbstractScanSeries, acquisition, user,  sample.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 10.0);\n\njulia> s2 = ChromScan(2.0u\"s\", 200.0);\n\njulia> series = ChromScanSeries([s1, s2], instrument=(detector=\"UV-DAD\",));\n\njulia> instrument(series)\n(detector = \"UV-DAD\",)\n\njulia> instrument(series).detector\n\"UV-DAD\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.levels-Tuple{AbstractMassScanSeries}","page":"ScansSeries","title":"JuChrom.levels","text":"levels(series::AbstractMassScanSeries) -> Vector{<:Integer}\n\nReturns a sorted list of unique scan levels present in the given mass scan series.\n\nScan levels typically indicate the stage of mass spectrometry (e.g. MS¹, MS²). This  function extracts the level from each scan, filters duplicates, and returns them in ascending order.\n\nArguments\n\nseries::AbstractMassScanSeries: The series of mass scans to analyze.\n\nReturns\n\nA sorted vector of unique scan levels.\n\nExamples\n\njulia> ms1 = MassScan(1.0u\"s\", [100.0], [10.0]u\"pA\"; level=1);\n\njulia> ms2 = MassScan(2.0u\"s\", [150.0], [20.0]u\"pA\"; level=2);\n\njulia> ms3 = MassScan(3.0u\"s\", [200.0], [30.0]u\"pA\"; level=1);\n\njulia> mss = MassScanSeries([ms1, ms2, ms3]; acquisition=(mode=\"DDA\",));\n\njulia> levels(mss) == [1, 2]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.mscanmatrix","page":"ScansSeries","title":"JuChrom.mscanmatrix","text":"mscanmatrix(series::MassScanSeries, format::AbstractMatrixFormat; \n            target_level::Integer=1, threshold::Real=0.0)\n\nConvert a MassScanSeries to a MassScanMatrix with the specified matrix format.\n\nArguments\n\nseries: The input MassScanSeries\nformat: Matrix format - DENSE or SPARSE (or DenseMatrix(), SparseMatrix());  default is DENSE\ntarget_level: Scan level to filter for (default: 1)\nthreshold: Minimum intensity threshold for inclusion (default: 0.0)\n\nExamples\n\njulia> scan1 = MassScan(1.0u\"s\", [101.2, 101.6, 102.1], [10, 20, 30])\n       scan2 = MassScan(2.0u\"s\", [100.9, 101.2, 102.6], [20, 5, 30])\n       series = MassScanSeries([scan1, scan2]);\n\njulia> matrix_dense = mscanmatrix(series);  # Create dense matrix (default)\n\njulia> intensities(matrix_dense) isa Matrix\ntrue\n\njulia> matrix_sparse = mscanmatrix(series, SPARSE);  # Create sparse matrix\n\njulia> intensities(matrix_sparse) isa SparseArrays.SparseMatrixCSC\ntrue\n\njulia> intensities(matrix_dense) ≈ [0 10 20 30 0; 20 5 0 0 30]\ntrue\n\njulia> intensities(matrix_dense) ≈ intensities(matrix_sparse)\ntrue\n\njulia> retentions(matrix_dense) ≈ [1.0, 2.0]u\"s\"\ntrue\n\njulia> retentionunit(matrix_dense)\ns\n\njulia> mzvalues(matrix_dense) ≈ [100.9, 101.2, 101.6, 102.1, 102.6]\ntrue\n\njulia> mzunit(matrix_dense) === nothing\ntrue\n\njulia> matrix_filtered = mscanmatrix(series, threshold=7.5);  # Apply intensity threshold\n\njulia> intensities(matrix_filtered) ≈ [0 10 20 30 0; 20 0 0 0 30]\ntrue\n\njulia> scan1 = MassScan(1.0u\"s\", [101.2, 101.6, 102.1], [10, 20, 30], level=1)\n       scan2 = MassScan(2.0u\"s\", [100.9, 101.2, 102.6], [20, 5, 30], level=2)\n       series = MassScanSeries([scan1, scan2]);\n\njulia> matrix_level_2 = mscanmatrix(series, target_level=2);\n\njulia> level(matrix_level_2)\n2\n\njulia> intensities(matrix_level_2) ≈ [20 5 30]\ntrue\n\njulia> series_annotated = MassScanSeries([scan1, scan2];\n                          instrument=(detector=\"Orbitrap\", manufacturer=\"Thermo\"),\n                          acquisition=(mode=\"FullScan\", method=\"DDA\", polarity=\"positive\"),\n                          user=(operator=\"Alice\", project=\"QC-2025\"),\n                          sample=(ID=\"sample_001\", matrix=\"plasma\", prep=\"SPE\"),\n                          extras=Dict(\"injection_volume\" => 5.0, \"comment\" => \"QC run\"));\n\n\njulia> matrix_annotated = mscanmatrix(series_annotated);\n\njulia> instrument(matrix_annotated)\n(detector = \"Orbitrap\", manufacturer = \"Thermo\")\n\njulia> acquisition(matrix_annotated)\n(mode = \"FullScan\", method = \"DDA\", polarity = \"positive\")\n\njulia> user(matrix_annotated)\n(operator = \"Alice\", project = \"QC-2025\")\n\njulia> sample(matrix_annotated)\n(ID = \"sample_001\", matrix = \"plasma\", prep = \"SPE\")\n\njulia> extras(matrix_annotated)\nDict{String, Any} with 2 entries:\n  \"injection_volume\" => 5.0\n  \"comment\"          => \"QC run\"\n\n\n\n\n\n","category":"function"},{"location":"man/ScanSeries/#JuChrom.mzchrom-Tuple{MassScanSeries}","page":"ScansSeries","title":"JuChrom.mzchrom","text":"mzchrom(series::MassScanSeries,\n        selection::Union{Nothing, <:Number, AbstractVector{<:Number}}=nothing;\n        tol::Number=3e-4,\n        warning::Bool=true)\n\nExtract a chromatogram scan series from a MassScanSeries.\n\nselection: either nothing (TIC) or a scalar/collection of m/z targets. When a scalar or vector is given, intensities at the selected m/z are summed per scan (XIC).  \ntol: the absolute tolerance used when matching selection m/z values to each scan’s discrete m/z grid. The nearest m/z value within tol is chosen for each target. tol  may be numeric or unitful. If the series’ m/z are unitless, tol must be unitless  (unitful tol errors). If the series’ m/z have a unit, numeric tol is interpreted in  that unit; unitful tol is converted to the m/z unit; incompatible units error.\nwarning: whether to emit warnings if m/z values are not found or indices are out of bounds.\n\nReturns a ChromScanSeries with retention time and intensity units preserved.\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.mzunit-Tuple{AbstractMassScanSeries}","page":"ScansSeries","title":"JuChrom.mzunit","text":"mzunit(series::AbstractMassScanSeries) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the m/z values of a mass scan series.\n\nThis function retrieves the m/z unit from the first scan in the series, assuming all scans have consistent units.\n\nArguments\n\nseries: A subtype of AbstractMassScanSeries.\n\nReturns\n\nA Unitful.Units subtype representing the m/z unit, or nothing if unspecified.\n\nExamples\n\njulia> ms = MassScan(1.0u\"s\", [100.0]u\"Th\", [10.0])\n       series = MassScanSeries([ms]);\n\njulia> mzunit(series)\nTh\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.mzvalues-Tuple{AbstractMassScanSeries, Integer}","page":"ScansSeries","title":"JuChrom.mzvalues","text":"mzvalues(series::AbstractMassScanSeries, scanindex::Integer; \n         unit::Union{Nothing, Unitful.Units}=nothing) -> AbstractVector{<:Real}\n\nReturns the m/z (mass-to-charge ratio) values for the scan at the specified index in the  given mass scan series.\n\nIf the scan stores unitful m/z values, they are optionally converted to the specified unit. If no unit is specified, the scan's native unit is used. If the m/z values are unitless,  they are returned as-is.\n\nArguments\n\nseries: A mass scan series (AbstractMassScanSeries) to index into.\nscanindex: The index of the scan to retrieve m/z values from.\nunit: (optional) Unit to which m/z values should be converted. Must be nothing for  scans with unitless m/z values.\n\nReturns\n\nAn AbstractVector{<:Real} or AbstractVector{<:Quantity} containing the m/z values of  the specified scan.\n\nThrows\n\nBoundsError if the index is out of range.\nArgumentError if a unit is requested for a scan with unitless m/z values.\n\nExamples\n\njulia> s1 = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]u\"pA\");\n\njulia> series = MassScanSeries([s1]);\n\njulia> mzvalues(series, 1) == [100.0, 200.0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.rawintensities-Tuple{AbstractChromScanSeries}","page":"ScansSeries","title":"JuChrom.rawintensities","text":"rawintensities(series::AbstractChromScanSeries;\nunit::Union{Nothing, Unitful.Units}=nothing) -> Vector\n\nReturn the numeric (unitless) intensity values from all scans in a chromatographic scan  series.\n\nIf the scan’s intensity_unit is not nothing, the intensity values are optionally  converted to the user-specified unit using uconvert, then stripped of units. If no  unit is specified, the stored unit is used for stripping.\n\nArguments\n\nseries: A concrete subtype of AbstractChromScanSeries.\nunit: (optional) A Unitful.Units object to which raw intensities should be  converted. If the scan series does not define intensity units, this must remain nothing.\n\nReturns\n\nA vector of raw intensity values, one per scan, with optional unit conversion.\n\nThrows\n\nArgumentError if a unit is requested but the scan series has no defined intensity unit.\n\nSee also AbstractChromScanSeries, intensities, rawintensity,  scans.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 1.0u\"pA\");\n\njulia> s2 = ChromScan(2.0u\"s\", 2.0u\"pA\");\n\njulia> series = ChromScanSeries([s1, s2]);\n\njulia> rawintensities(series) == [1.0, 2.0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.rawintensities-Tuple{AbstractMassScanSeries, Integer}","page":"ScansSeries","title":"JuChrom.rawintensities","text":"rawintensities(series::AbstractMassScanSeries, scanindex::Integer; \n               unit::Union{Nothing, Unitful.Units}=nothing) -> AbstractVector{<:Real}\n\nReturns the numeric (unitless) intensity values for the scan at the specified index within the given mass scan series.\n\nIf the scan stores unitful intensities, the values are optionally converted to the  specified unit and then stripped of units. If the intensities are already unitless,  no conversion is performed.\n\nArguments\n\nseries::AbstractMassScanSeries: The series of mass scans.\nscanindex::Integer: The index of the scan to extract raw intensities from.\nunit::Union{Nothing, Unitful.Units}: Optional unit to convert the intensities into  before stripping. If nothing, the stored unit (if any) is used. If intensities are  already unitless, unit must also be nothing.\n\nReturns\n\nAn AbstractVector{<:Real} of unitless intensity values from the specified scan.\n\nThrows\n\nBoundsError if scanindex is outside the valid range of the scan series.\nArgumentError if a unit is requested for a scan that stores unitless intensities.\nAssertionError if the scan claims to have a unit but intensity_unit is nothing.\n\nExamples\n\njulia> ms1 = MassScan(1.0u\"s\", [100.0, 150.0], [10.0, 20.0]u\"pA\");\n\njulia> ms2 = MassScan(2.0u\"s\", [100.0, 150.0], [12.0, 22.0]u\"pA\");\n\njulia> mss = MassScanSeries([ms1, ms2]; acquisition=(mode=\"FullScan\",));\n\njulia> rawintensities(mss, 1) == [10.0, 20.0]\ntrue\n\njulia> rawintensities(mss, 2; unit=u\"nA\") == [0.012, 0.022]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.rawretentions-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.rawretentions","text":"rawretentions(series::AbstractScanSeries; \n              unit::Union{Nothing, Unitful.Units}=nothing) -> Vector{<:Real}\n\nReturns the raw (unitless) retention values for all scans in the given scan series.\n\nIf the scan stores unitful retention values, they are optionally converted to the specified  unit and then stripped of units. If retention values are already unitless, no conversion is  performed.\n\nArguments\n\nseries: A subtype of AbstractScanSeries whose scans define retention values.\nunit: (optional) A Unitful.Units object to which each scan's retention value should  be converted before stripping. Must be nothing for scans with unitless retention.\n\nReturns\n\nA Vector{<:Real} of raw, unitless retention values — one per scan in the series.\n\nThrows\n\nArgumentError if a unit is requested for a scan that does not define a retention unit.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 1.0);\n\njulia> s2 = ChromScan(2.0u\"s\", 2.0);\n\njulia> series = ChromScanSeries([s1, s2]);\n\njulia> rawretentions(series) == [1.0, 2.0]\ntrue\n\njulia> rawretentions(series; unit=u\"ms\") == [1e3, 2e3]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.retentions-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.retentions","text":"retentions(series::AbstractScanSeries; \n           unit::Union{Nothing, Unitful.Units}=nothing) -> Vector{<:Real}\n\nReturns the retention values for all scans in the given scan series, preserving units.\n\nIf the scan stores unitful retention values, the values are optionally converted to the  specified unit. If no unit is specified, the scan's stored unit is used. If the retention  values are unitless, no conversion is performed and the values are returned as-is.\n\nArguments\n\nseries: A subtype of AbstractScanSeries whose scans define retention values.\nunit: (optional) A Unitful.Units object to which each scan's retention value should  be converted. Must be nothing for scans with unitless retention.\n\nReturns\n\nA Vector{<:Real} or Vector{<:Quantity} of retention values, one per scan.\n\nThrows\n\nArgumentError if a unit is requested for a scan that does not define a retention unit.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 100.0);\n\njulia> s2 = ChromScan(2.0u\"s\", 200.0);\n\njulia> series = ChromScanSeries([s1, s2]);\n\njulia> retentions(series) == [1.0, 2.0]u\"s\"\ntrue\n\njulia> retentions(series; unit=u\"ms\") == [1000.0, 2000.0]u\"ms\"\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.retentionunit-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.retentionunit","text":"retentionunit(series::AbstractScanSeries) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the retention values of a scan series.\n\nThis function retrieves the retention unit from the first scan in the series, assuming all scans have consistent units (which should be enforced by the series constructor).\n\nArguments\n\nseries: A subtype of AbstractScanSeries, such as MassScanSeries or ChromScanSeries.\n\nReturns\n\nA Unitful.Units subtype representing the retention unit, or nothing if unspecified.\n\nExamples\n\njulia> ms = MassScan(1.0u\"s\", [100.0], [10.0])\n       series = MassScanSeries([ms]);\n\njulia> retentionunit(series)\ns\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.sample-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.sample","text":"sample(series::AbstractScanSeries) -> NamedTuple\n\nReturns the sample metadata associated with the scan series.\n\nThis typically includes information about the analyzed sample, such as sample ID, origin,  preparation details, or treatment conditions.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nA NamedTuple containing sample-related metadata.\n\nSee also AbstractScanSeries, instrument, acquisition,  user.\n\nExamples\n\n```jldoctest julia> s = [ChromScan(1.0u\"s\", 10.0), ChromScan(2.0u\"s\", 200.0)];\n\njulia> series = ChromScanSeries(s, sample=(ID=\"Polistes dominula\", locality=\"Germany\"));\n\njulia> sample(series) (ID = \"Polistes dominula\", locality = \"Germany\")\n\njulia> sample(series).ID \"Polistes dominula\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.scan-Tuple{AbstractScanSeries, Integer}","page":"ScansSeries","title":"JuChrom.scan","text":"scan(series::AbstractScanSeries, scanindex::Integer) -> AbstractScan\n\nReturns the scan at the specified index from the given scan series.\n\nThis is a direct accessor for individual scans, supporting bounds-checked indexed access.\n\nArguments\n\nseries::AbstractScanSeries: The scan series to index into.\nscanindex::Integer: The index of the scan to retrieve.\n\nReturns\n\nAn AbstractScan object corresponding to the requested index.\n\nThrows\n\nBoundsError if scanindex is outside the valid range of the scan series.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 2.0u\"nA\");\n\njulia> s2 = ChromScan(2.0u\"s\", 2.5u\"nA\");\n\njulia> css = ChromScanSeries([s1, s2]; acquisition=(mode=\"TIC\",));\n\njulia> scan(css, 2) == s2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.scancount-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.scancount","text":"scancount(series::AbstractScanSeries) -> Int\n\nReturns the number of individual scan entries in the scan series.\n\nThis is equivalent to length(series), and reflects the total number of scan measurements  stored in the series.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nAn Int representing the number of scan elements.\n\nSee also AbstractScanSeries, scans.\n\nExamples\n\njulia> series = ChromScanSeries([ChromScan(1.0u\"s\", 10.0), ChromScan(2.0u\"s\", 200.0)]);\n\njulia> scancount(series)\n2\n\njulia> scancount(series) == length(series)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.scans-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.scans","text":"scans(series::AbstractScanSeries) -> AbstractVector{<:AbstractScan}\n\nReturn the collection of scans contained in the given scan series.\n\nArguments\n\nseries: A subtype of AbstractScanSeries, such as ChromScanSeries or  MassScanSeries.\n\nReturns\n\nA vector of scan objects in acquisition order.\n\nExamples\n\njulia> s1 = ChromScan(1.0u\"s\", 5.0u\"pA\");\n\njulia> s2 = ChromScan(2.0u\"s\", 7.5u\"pA\");\n\njulia> series = ChromScanSeries([s1, s2]);\n\njulia> length(scans(series)) == scancount(series)\ntrue\n\njulia> all(retention.(scans(series)) .== [1.0u\"s\", 2.0u\"s\"])\ntrue\n\njulia> all(intensity.(scans(series)) .== [5.0u\"pA\", 7.5u\"pA\"])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.uniquemzvalues-Tuple{AbstractMassScanSeries, Integer}","page":"ScansSeries","title":"JuChrom.uniquemzvalues","text":"uniquemzvalues(series::AbstractMassScanSeries, target_level::Integer=1; \n               unit::Union{Nothing, Unitful.Units}=nothing) -> Vector{<:Real}\n\nReturns a sorted vector of unique m/z values (ions) found in scans at the specified MS  level within the given mass scan series.\n\nIf the scans store unitful m/z values, they are optionally converted to the specified  unit. If no unit is provided, the scan's native unit is used. If m/z values are unitless,  no  conversion is performed and values are returned as-is.\n\nArguments\n\nseries: The mass scan series to extract m/z values from.\ntarget_level: (optional) The MS level to filter scans by (default: 1).\nunit: (optional) Unit to which m/z values should be converted before deduplication.  Must be nothing for unitless scans.\n\nReturns\n\nA sorted vector of unique m/z values (Real or Quantity), depending on unit usage.\n\nThrows\n\nArgumentError if no scans exist at the specified level.\nArgumentError if a unit is requested for a scan with unitless m/z values.\n\nExamples\n\njulia> s1 = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]; level=1);\n\njulia> s2 = MassScan(2.0u\"s\", [150.0, 200.0], [15.0, 25.0]; level=2);\n\njulia> mss = MassScanSeries([s1, s2]);\n\njulia> uniquemzvalues(mss) == [100.0, 200.0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanSeries/#JuChrom.user-Tuple{AbstractScanSeries}","page":"ScansSeries","title":"JuChrom.user","text":"user(series::AbstractScanSeries) -> NamedTuple\n\nReturns the user metadata associated with the scan series.\n\nThis typically includes information about the operator, analyst, or laboratory personnel  involved in the acquisition or processing of the scan data.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nA NamedTuple containing user-related metadata.\n\nSee also AbstractScanSeries, acquisition, instrument,  sample.\n\nExamples\n\njulia> vec = [ChromScan(1.0u\"s\", 10.0), ChromScan(2.0u\"s\", 200.0)];\n\njulia> series = ChromScanSeries(vec, user=(name=\"Alice\", email=\"\"));\n\njulia> user(series).name\n\"Alice\"\n\n\n\n\n\n","category":"method"},{"location":"man/transform/#Transform","page":"Transform","title":"Transform","text":"","category":"section"},{"location":"man/transform/#JuChrom.binmzvalues-Tuple{MassScanSeries, Function}","page":"Transform","title":"JuChrom.binmzvalues","text":"binmzvalues(series::MassScanSeries, mzbin_fn::Function=integer) -> MassScanSeries\n\nReturn a new MassScanSeries where m/z values in each scan are grouped using mzbin_fn, and intensities within each bin are summed.\n\nThis method is fully type-stable and constructs a concrete MassScanSeries whose element  types reflect the output of mzbin_fn.\n\nArguments\n\nseries::MassScanSeries: The input mass scan series.\nmzbin_fn::Function: Function used to assign m/z values to bins (default: integer).\n\nReturns\n\nA new MassScanSeries with binned m/z values and aggregated intensities.\n\nThrows\n\nAssertionError if the input series is empty.\n\nSee also MassScanSeries, integer, mzvalues, mzunit,  intensities, intensityunit, scans, scan.\n\nExamples\n\njulia> scan1 = MassScan(1.0u\"s\", [101.2, 101.6, 102.1], [10, 20, 30])\n       scan2 = MassScan(1.0u\"s\", [100.9, 101.2, 102.6], [20, 5, 30])\n       series = MassScanSeries([scan1, scan2]);\n\njulia> binned = binmzvalues(series);\n\njulia> mzvalues(binned, 1) == [101, 102]\ntrue\n\njulia> intensities(binned, 1) == [30, 30]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/transform/#JuChrom.binretentions-Tuple{MassScanMatrix, AbstractVector{<:Number}, Union{QuadVarParams, AbstractVector{<:QuadVarParams}}, Union{Real, AbstractVector{<:Real}}}","page":"Transform","title":"JuChrom.binretentions","text":"binretentions(msm::MassScanMatrix, bin_edges, quadvar_params, rho_lag1;\n              jacobian_scale=nothing, zero_threshold=1e-8, rho_max=0.8)\n\nBin every m/z column of a MassScanMatrix into retention bins while propagating heteroscedastic variance models (via varpredbias) and optional Jacobian scaling. If the matrix stores unitful intensities, both the per-scan variances and the output bin variances retain the corresponding squared intensity units while msm_binned continues to store stripped (unitless) numeric intensities plus metadata.\n\nFor each m/z trace this method:\n\nPredicts per-scan variances with varpredbias using the supplied QuadVarParams.\nApplies an optional Jacobian scaling factor (f'(t))⁻² supplied via jacobian_scale (either a per-scan vector or a callable).\nCalls the scalar binretentions helper with the matching lag-1 correlation from rho_lag1 to obtain inverse-variance weighted bin means and inflated variances.\n\nArguments\n\nmsm::MassScanMatrix: Input data cube (retentions × m/z × intensities).\nbin_edges::AbstractVector: Edges defining the retention bins (unitful or unitless).\nquadvar_params: Vector of QuadVarParams (one per m/z) or a single QuadVarParams reused for every column.\nrho_lag1: Lag-1 residual correlations per m/z (vector or scalar broadcast).\n\nKeyword Arguments\n\njacobian_scale: nothing, a vector of f'(t) values (length = scans),  or a callable t -> f'(t).\nzero_threshold: Minimum variance after clamping (supports unitful values when msm carries intensity units; otherwise must be unitless).\nrho_max: Upper bound for the variance-inflation correlation cap.\n\nReturns\n\n(msm_binned, var_matrix) where msm_binned is the binned MassScanMatrix (retentions become the bin centers, intensities become weighted means) and var_matrix holds the inflated variances for each bin/m/z pair.\n\nNotes\n\nMetadata (instrument, acquisition, user, sample, extras) is deep-copied from  msm.\nquadvar_params and rho_lag1 accept scalars for convenience; they are broadcast internally when needed.\nNegative intensities are preserved; only variances are clamped at zero_threshold.\nWhen msm has unitful intensities, zero_threshold and the predicted variances must use the corresponding squared intensity units (unitless thresholds are automatically promoted).\n\nExample\n\njulia> msm = MassScanMatrix(collect(0.0:0.5:2.0), nothing, [100.0, 101.0], nothing,\n                            [10 12; 9 11; 8 10; 7 9; 6 8], nothing);\n       quad_params = fill(QuadVarParams(0.1, 0.01, 0.0), 2);\n       lag1 = fill(0.2, 2);\n       edges = 0:1:3.0;\n\njulia> msm_binned, vars = binretentions(msm, edges, quad_params, lag1);\n\njulia> size(msm_binned.intensities)\n(3, 2)\n\n\n\n\n\n","category":"method"},{"location":"man/transform/#JuChrom.clr","page":"Transform","title":"JuChrom.clr","text":"clr(x::AbstractArray{<:Real}) -> Array{Float64}\nclr(x::AbstractArray{<:Real},\n    variances::AbstractArray{<:Real}) -> Tuple{Array{Float64}, Array{Float64}}\n\nApply the centered log-ratio (CLR) transformation to compositional data, with optional  variance propagation.\n\nThe CLR transformation converts strictly positive data to log-ratio coordinates by subtracting the geometric mean (in log space) from each log-transformed value: clr(x) = log(x) - mean(log(x)).\n\nSingle Array Usage\n\nWhen called with one array, returns only the CLR-transformed data.\n\nVariance Propagation Usage\n\nWhen called with two arrays, the second array contains variances of the original data. Returns both the CLR-transformed data and the propagated variances using exact  finite-sample correction.\n\nArguments\n\nx::AbstractArray{<:Real}: Input array with strictly positive values\nvariances::AbstractArray{<:Real}: Element-wise variances of original data (same shape  as x)\n\nReturns\n\nSingle array: Array{Float64} - CLR-transformed data with same shape as input\nTwo arrays: Tuple{Array{Float64}, Array{Float64}} - (CLR-transformed data, propagated  variances)\n\nThrows\n\nDomainError: if any element of x is ≤ 0\nDimensionMismatch: if x and variances have different shapes\n\nExamples\n\njulia> x = [0.1, 0.7, 0.2]; σ² = [1, 9, 3];\n\njulia> clr(x) ≈ [-0.8796857765384194, 1.0662243725168936, -0.18653859597847422]\ntrue\n\njulia> x_clr, σ²_clr = clr(x, σ²);\n\njulia> x_clr == clr(x)\ntrue\n\njulia> σ²_clr ≈ [54.81859410430839, 27.60770975056689, 46.485260770975046]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.densestgrid-Tuple{AbstractVector{<:AbstractMassScanMatrix}}","page":"Transform","title":"JuChrom.densestgrid","text":"densestgrid(msmatrices::AbstractVector{<:AbstractMassScanMatrix};\n            minwidth::Union{Nothing,Real,Unitful.AbstractQuantity}=nothing,\n            maxwidth::Union{Nothing,Real,Unitful.AbstractQuantity}=nothing,\n            tolerance::Union{Nothing,Real,Unitful.AbstractQuantity}=nothing,\n            coarse_inflation=1.001,\n            primary_refine_iters=35,\n            secondary_refine_iters=20,\n            max_anchors_basic=256,\n            max_anchors_enriched=1024)\n\nExtracts the retention vectors from all matrices, then determines a near-minimal bin width  w and matching regular grid edges so that every bin inside the shared overlap  [global_min, global_max] contains at least one observation from each dataset.\n\nIn simple terms, the algorithm trims every dataset to the common overlap, then keeps trying slightly wider bins—beginning at the smallest possible positive gap—until it finds a width that works for some grid alignment (anchor phase). The coarse growth is governed by coarse_inflation, so shrinking that ratio forces a finer sweep at the expense of runtime. Once a working width is found, two rounds of binary search progressively tighten the interval: the primary search runs for primary_refine_iters iterations while limiting the anchor phases to at most max_anchors_basic, and the secondary search repeats for secondary_refine_iters iterations using the enriched anchor pool capped by max_anchors_enriched.\n\nThree-stage search (delegating to the numeric core):\n\nCoarse inflation: Inflate a rigorous lower-bound width by coarse_inflation until some anchor phase yields full occupancy.\nPrimary refinement: Binary search between the last failing and first successful widths for primary_refine_iters iterations with a capped basic anchor set (max_anchors_basic).\nSecondary refinement: Repeat with an enriched anchor set (max_anchors_enriched) for secondary_refine_iters iterations to tighten the bound.\n\nUnit handling:\n\nAll retentions must be either plain reals or Unitful.Quantity values sharing the same physical dimension.\nIf retentions are unitful, minwidth, maxwidth, and tolerance must be nothing or compatibly dimensioned quantities; default tolerance is 1e-8 * unit.\nIf retentions are unitless, the keywords must be nothing or plain reals and tolerance defaults to 1e-8.\n\nArguments:\n\nmsmatrices: Non-empty vector of MassScanMatrix, each with at least one retention value inside the shared overlap region.\nminwidth::Union{Nothing,Real,Unitful.AbstractQuantity}: Optional lower bound; defaults to the minimum strictly positive internal gap implied by the datasets.\nmaxwidth::Union{Nothing,Real,Unitful.AbstractQuantity}: Optional upper bound; defaults to the length of the common overlap.\ntolerance::Union{Nothing,Real,Unitful.AbstractQuantity}: Inclusion tolerance for the last bin’s right edge.\n\nReturns (edges, w) (unit-attached when retentions are unitful), where w is the final bin width guaranteeing at least one observation from every dataset per bin. Throws ArgumentError if inputs are empty, units are inconsistent, the overlap is empty, or no admissible width is found up to maxwidth.\n\n\n\n\n\n","category":"method"},{"location":"man/transform/#JuChrom.densestgrid-Tuple{AbstractDict{<:Any, <:AbstractMassScanMatrix}}","page":"Transform","title":"JuChrom.densestgrid","text":"densestgrid(msmatrices::AbstractDict{<:Any, <:AbstractMassScanMatrix};\n            minwidth::Union{Nothing,Real,Unitful.AbstractQuantity}=nothing,\n            maxwidth::Union{Nothing,Real,Unitful.AbstractQuantity}=nothing,\n            tolerance::Union{Nothing,Real,Unitful.AbstractQuantity}=nothing,\n            coarse_inflation=1.001,\n            primary_refine_iters=35,\n            secondary_refine_iters=20,\n            max_anchors_basic=256,\n            max_anchors_enriched=1024)\n\nConvenience wrapper for datasets aggregated in a dictionary keyed by dataset identifier. Extracts the retention vectors from every MassScanMatrix value, then delegates to the vector-based densestgrid to compute a near-minimal bin width w and the accompanying grid edges covering the shared overlap. All search-related keywords (coarse_inflation, refinement counts, anchor caps) behave identically to the vector method densestgrid(::AbstractVector{<:AbstractMassScanMatrix}).\n\nUnit handling mirrors the vector API:\n\nWhen retentions are unitful quantities, minwidth, maxwidth, and tolerance must be nothing or dimensionally compatible quantities, and the default tolerance (when nothing) is 1e-8 * unit.\nWhen retentions are unitless reals, the keywords must be nothing or plain reals, and the default tolerance becomes 1e-8.\n\nArguments:\n\nmsmatrices::AbstractDict{<:Any,<:AbstractMassScanMatrix}: Non-empty mapping whose values each provide at least one retention time within the common overlap region.\nminwidth::Union{Nothing,Real,Unitful.AbstractQuantity}: Optional lower bound on w; defaults to the smallest strictly positive gap implied by the datasets.\nmaxwidth::Union{Nothing,Real,Unitful.AbstractQuantity}: Optional upper bound for w; defaults to the length of the shared overlap.\ntolerance::Union{Nothing,Real,Unitful.AbstractQuantity}: Inclusion tolerance for the final bin’s right edge.\n\nReturns (edges, w) (unit-attached whenever the inputs are unitful). Throws ArgumentError if the dictionary is empty, any matrix lacks data, units are inconsistent, or no admissible width can be found up to maxwidth.\n\n\n\n\n\n","category":"method"},{"location":"man/transform/#JuChrom.indextrim","page":"Transform","title":"JuChrom.indextrim","text":"indextrim(series::AbstractScanSeries; start=firstindex(scans(series)), \n          stop=lastindex(scans(series))) -> AbstractScanSeries\n\nReturn a new AbstractScanSeries containing only the scans whose indices are within the  inclusive range [start, stop].\n\nArguments\n\nseries::AbstractScanSeries: The scan series to trim.\nstart::Integer: Starting index of the scan range to retain. Defaults to the first index.\nstop::Integer: Ending index of the scan range to retain. Defaults to the last index.\n\nReturns\n\nA new copy of series with only the scans in the specified index range.\n\nThrows\n\nBoundsError if start or stop is outside the bounds of scans(series).\nArgumentError if start > stop.\nArgumentError if the resulting scan list is empty.\n\nSee also AbstractScanSeries, indextrim!, retentiontrim, retentiontrim!, scans, scancount.\n\nExamples\n\n```jldoctest julia> scan1 = ChromScan(1.0u\"minute\", 5.0)        scan2 = ChromScan(2.0u\"minute\", 6.0)        scan3 = ChromScan(3.0u\"minute\", 7.0)        series = ChromScanSeries([scan1, scan2, scan3]);\n\njulia> trimmed = indextrim(series; start=2, stop=2);\n\njulia> scancount(trimmed) 1\n\njulia> retentions(trimmed) == [2.0]u\"minute\" true ````\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.indextrim!","page":"Transform","title":"JuChrom.indextrim!","text":"indextrim!(series::AbstractScanSeries; start=firstindex(scans(series)), \n           stop=lastindex(scans(series))) -> AbstractScanSeries\n\nMutate series by retaining only scans whose indices fall within the inclusive range [start, stop].\n\nThis operation trims the underlying scan vector in-place. It is non-allocating and  modifies the original data structure.\n\nArguments\n\nseries::AbstractScanSeries: The scan series to modify.\nstart::Integer: Starting index of the scan range to retain. Defaults to the first index.\nstop::Integer: Ending index of the scan range to retain. Defaults to the last index.\n\nReturns\n\nThe mutated series with only scans from index start to stop remaining.\n\nThrows\n\nBoundsError if start or stop is outside the bounds of scans(series).\nArgumentError if start > stop.\nArgumentError if the resulting scan list is empty.\n\nSee also AbstractScanSeries, indextrim, retentiontrim, retentiontrim!, scans, scancount.\n\nExamples\n\njulia> scan1 = ChromScan(1.0u\"minute\", 5.0)\n       scan2 = ChromScan(2.0u\"minute\", 6.0)\n       scan3 = ChromScan(3.0u\"minute\", 7.0)\n       series = ChromScanSeries([scan1, scan2, scan3]);\n\njulia> indextrim!(series; start=2, stop=2);\n\njulia> scancount(series)\n1\n\njulia> retentions(series) == [2.0]u\"minute\"\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.integer","page":"Transform","title":"JuChrom.integer","text":"integer(value::Real; offset::Real=0.3) -> Int\n\nAssigns a real number value to an integer bin such that the integer bin n includes the interval [n - offset, n + (1 - offset)).\n\nArguments\n\nvalue::Real: The number to assign to a bin.\noffset::Real=0.3: Determines the left edge of the bin around each integer. Must be in  the range [0, 1).\n\nReturns\n\nAn Int representing the bin number for value.\n\nThrows\n\nArgumentError if offset is not in [0, 1).\n\nSee also binmzvalues.\n\nExamples\n\njulia> integer(3.2)\n3\n\njulia> integer(3.69)\n3\n\njulia> integer(3.7)\n4\n\njulia> integer(3.7, 0.999)\n4\n\njulia> integer(3.7, 1)\nERROR: ArgumentError: `offset` must be in the range [0, 1).\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.levelscans","page":"Transform","title":"JuChrom.levelscans","text":"levelscans(series::AbstractMassScanSeries, target_level::Integer=1) \n    -> AbstractMassScanSeries\n\nReturn a new AbstractMassScanSeries containing only scans with the specified  target_level.\n\nArguments\n\nseries::AbstractMassScanSeries: A series of mass spectrometry scans.\ntarget_level::Integer=1: The MS level to filter for (e.g. 1 for MS1, 2 for MS2).\n\nReturns\n\nA new mass scan series containing only the scans at the specified level. All metadata is  preserved.\n\nThrows\n\nArgumentError if no scans exist at the specified target_level.\n\nSee also AbstractMassScanSeries, scans, scan, level.\n\nExamples\n\njulia> scan1 = MassScan(1.0u\"minute\", [100.0], [10.0]; level=1)\n       scan2 = MassScan(2.0u\"minute\", [150.0], [15.0]; level=2)\n       series = MassScanSeries([scan1, scan2]);\n\njulia> filtered = levelscans(series, 2);\n\njulia> scancount(filtered)\n1\n\njulia> level(scan(filtered, 1))\n2\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.retentiontrim","page":"Transform","title":"JuChrom.retentiontrim","text":"retentiontrim(series::AbstractScanSeries; start=first(retentions(series)), \n              stop=last(retentions(series))) -> AbstractScanSeries\n\nReturn a new AbstractScanSeries containing only those scans whose retention values fall  within the inclusive range [start, stop].\n\nThis method supports series with unitful or unitless retention values. It automatically  uses the correct default range based on the retention values present in the series.\n\nArguments\n\nseries::AbstractScanSeries: The scan series to trim.\nstart: The lower bound of the retention range. Defaults to the first retention value in  series.\nstop: The upper bound of the retention range. Defaults to the last retention value in  series.\n\nReturns\n\nA new AbstractScanSeries with scans filtered by the specified retention range.\n\nThrows\n\nArgumentError if start > stop.\nArgumentError if no scans remain after trimming.\n\nSee also AbstractScanSeries, retentiontrim!, indextrim,  indextrim!, scans, scancount.\n\nExamples\n\njulia> scan1 = ChromScan(1.0u\"minute\", 5.0)\n       scan2 = ChromScan(2.0u\"minute\", 6.0)\n       scan3 = ChromScan(3.0u\"minute\", 7.0)\n       series = ChromScanSeries([scan1, scan2, scan3]);\n\njulia> trimmed = retentiontrim(series; start=1.5u\"minute\", stop=2.5u\"minute\");\n\njulia> scancount(trimmed)\n1\n\njulia> retentions(trimmed) == [2.0]u\"minute\"\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.retentiontrim!","page":"Transform","title":"JuChrom.retentiontrim!","text":"retentiontrim!(series::AbstractScanSeries; start=first(retentions(series)), \n               stop=last(retentions(series))) -> AbstractScanSeries\n\nMutate the series in-place by removing scans whose retention values fall outside the  inclusive range [start, stop].\n\nThis method supports series with either unitful or unitless retention values.\n\nArguments\n\nseries::AbstractScanSeries: The scan series to modify.\nstart: Lower bound for retention filtering. Defaults to the first retention in the  series.\nstop: Upper bound for retention filtering. Defaults to the last retention in the  series.\n\nReturns\n\nThe same series object, with its scans filtered in-place.\n\nThrows\n\nArgumentError if start > stop.\nArgumentError if no scans remain after filtering.\n\nSee also AbstractScanSeries, retentiontrim, indextrim,  indextrim!, scans, scancount.\n\nExamples\n\njulia> scan1 = ChromScan(1.0u\"minute\", 5.0)\n       scan2 = ChromScan(2.0u\"minute\", 6.0)\n       scan3 = ChromScan(3.0u\"minute\", 7.0)\n       series = ChromScanSeries([scan1, scan2, scan3]);\n\njulia> retentiontrim!(series; start=1.5u\"minute\", stop=2.5u\"minute\");\n\njulia> scancount(series)\n1\n\njulia> retention(scan(series, 1)) == 2.0u\"minute\"\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/transform/#JuChrom.whiten","page":"Transform","title":"JuChrom.whiten","text":"whiten(x::AbstractArray{<:Real}, σ²::AbstractArray{<:Real}, σ²_floor::Real)\n\nWhiten x using its propagated variances.\n\nPerforms element-wise whitening by dividing each value by its corresponding standard deviation (derived from the variances), with a floor applied to prevent division by very small values.\n\nArguments\n\nx::AbstractArray{<:Real}: Data to be whitened (e.g. CLR-transformed intensities).\nσ²::AbstractArray{<:Real}: Matching variances array (same size as x)\nσ²_floor::Real: Absolute variance floor (must be positive)\n\nReturns\n\nWhitened data\n\nExamples\n\njulia> x = [0.1, 0.7, 0.2]; σ² = [1, 9, 3];\n\njulia> x_clr, σ²_clr = clr(x, σ²);\n\njulia> x_whitened = whiten(x_clr, σ²_clr, 0.01);\n\njulia> x_whitened ≈ [-0.11881290739752365, 0.20292400048800466, -0.0273596834199544]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/quadvar_model/#Quadratic-Variance-Model","page":"Quadratic Variance Model","title":"Quadratic Variance Model","text":"","category":"section"},{"location":"man/quadvar_model/#JuChrom.fitquadvarmodel","page":"Quadratic Variance Model","title":"JuChrom.fitquadvarmodel","text":"fitquadvarmodel(series_batches::AbstractVector{<:AbstractVector};\n                mzsel=nothing, show_progress::Bool=true, progress_every::Int=1, kwargs...)\n\nFit the signal/offset/gain + quadratic-variance model across a selection of m/z. Returns a self-contained QuadVarFit that includes the observed matrices restricted to the selected m/z.\n\nArguments\n\nseries_batches: vector of batches; each batch is a vector of replicate series. Within a batch, replicates must share the same m/z grid and the same scan count.\n\nKeyword arguments\n\nmzsel: m/z selection:\nnothing → all m/z in the reference grid,\nindices (range or Vector{Int}) into mz_ref,\nVector{<:Number} of exact m/z values (unitless numbers interpreted in mz_unit; Unitful quantities are converted to mz_unit) found in mz_ref.\nshow_progress (default true), progress_every (default 1).\nkwargs... are forwarded to fitquadvarmodel(Ms::Vector{<:AbstractMatrix}).\n\nReturns\n\nA QuadVarFit struct containing per-m/z fits and the observed data for the selected m/z.\n\n\n\n\n\nfitquadvarmodel(Ms::Vector{<:AbstractMatrix{<:Real}}; kwargs...)\n\nEnd-to-end fitting of the signal/offset/gain + quadratic variance model via alternating updates with smoothing, ridge regularization, pooled variance re-estimation, optional global scale calibration, and diagnostics.\n\nArguments\n\nMs: list of batches; each Ms[g] is N_g × R_g (N scans, R replicates).\n\nKeyword arguments\n\nSignal / offset / gain\n\nλ_signal: smoothing strength on the shared signal.\nλ_offset: smoothing (ridge) on offsets via D' D.\ngain_ridge: ridge shrinkage of gains toward 1.\ndamping: step size for the signal update in [0, 1].\n\nVariance re-fit\n\nquantlevel, bins, var_stat, σ₀²_min, ϕ_min, κ_min, ϕ_ridge, κ_ridge, z_max, c_eps, v_clip_q, z_low_q, feas_tol.\n\nFloors and jitter\n\nqc_varfloor: variance floor for QC/diagnostics.\nτ_floor: fraction to set the adaptive floor from per-batch medians.\nvarpred_floor: hard floor used inside varpred when forming weights.\nchol_jitter: relative diagonal jitter in the offset solver.\n\nIteration / stopping\n\nmaxiter, var_update_every, obj_reltol.\n\nCalibration\n\ncalibrate_scale, cal_trim_lo, cal_trim_hi, cal_clip_lo, cal_clip_hi.\n\nDiagnostics\n\nac_lag::Int=1: residual autocorrelation lag.\nacf_restrict::Symbol=:flat: observation mask used for ACF.\n:none     → use all rows\n:low      → keep rows with low normalized signal z = s/c′\n:flat     → keep rows with small local slope (|Δs| below a quantile)\n:lowflat  → apply both low and flat masks\nacf_z_quant::Float64=quantlevel: quantile for pooled scale c′ (used only for :low/:lowflat).\nacf_z_max_keep::Float64=0.30: keep rows with s/c′ ≤ acf_z_max_keep when low mask is active.\nacf_flat_q::Float64=0.20: keep rows where both adjacent |Δs| are ≤ this quantile.\nacf_trimfrac::Float64=0.0: fraction of extreme residual pairs to trim when computing ACF.\n\nReturns\n\nA named tuple with fields:\n\nparams::QuadVarParams\ns::Vector{Vector{Float64}}\no::Vector{Matrix{Float64}}\ng::Vector{Vector{Float64}}\nc::Float64\nstats::NamedTuple with keys z_rms, cov68, cov95, s_min, s_max\nacf::Float64\nacf_lag::Int\nn_pairs::Int\n\nNotes\n\nWeights use 1 ./ max(varpred(s, p; varfloor=varpred_floor), varfloor_eff) with varfloor_eff = max(qc_varfloor, τ_floor * median(per-batch medians)).\nAt least one variance update is guaranteed even if the main loop exits early.\n\n\n\n\n\n","category":"function"},{"location":"man/quadvar_model/#JuChrom.QuadVarParams","page":"Quadratic Variance Model","title":"JuChrom.QuadVarParams","text":"QuadVarParams(σ₀²::Number, ϕ::Number, κ::Number)\n\nParameter container for a quadratic variance model of the form\n\nσ²(y) = σ₀² + ϕ * y + κ * y^2\n\nFields\n\nσ₀²: baseline variance (intercept term, shares the variance units).\nϕ: linear coefficient in y (shares the intensity units).\nκ: quadratic coefficient in y (dimensionless; multiplies y^2).\n\nUsage\n\nQuadVarParams is typically used with [varpred] and [varpredbias] to evaluate the variance model given a true or estimated input y. All fields accept plain numbers or Unitful quantities; when intensities have units, set σ₀² and ϕ using the corresponding squared or linear intensity units so predicted variances retain their physical dimensions. The constructor enforces this relationship and also requires κ to remain unitless.\n\n\n\n\n\n","category":"type"},{"location":"man/quadvar_model/#JuChrom.QuadVarFit","page":"Quadratic Variance Model","title":"JuChrom.QuadVarFit","text":"QuadVarFit()\n\nContainer for fitted signal/offset/gain + quadratic variance results across a selected set of m/z values.\n\nFields\n\nmz_unit::Union{Unitful.Units, Nothing}: m/z unit tracked from the input grid (or nothing if unitless).\nmz_ref::Vector{<:Real}: numeric m/z grid present in the input data (values expressed in mz_unit when that is set).\nmz_idx::Vector{Int}: indices into mz_ref that were fitted.\nmz_values::Vector{<:Real}: selected m/z values (mz_ref[mz_idx], numeric).\nbatchcount::Int: number of batches.\nn_reps_per_batch::Vector{Int}: replicates per batch.\nn_scans_per_batch::Vector{Int}: scans per batch.\nparams::Vector{QuadVarParams}: variance parameters per selected m/z.\nintensity_unit::Union{Unitful.Units, Nothing}: intensity unit tracked from input data (or nothing if unitless).\nsignal::Vector{Vector{Vector{Float64}}}: fitted signal per m/z, per batch.\noffsets::Vector{Vector{Matrix{Float64}}}: offsets per m/z, per batch.\ngains::Vector{Vector{Vector{Float64}}}: gains per m/z, per batch.\nscale_c::Vector{Float64}: pooled scale c per m/z.\nacf::Vector{Float64}: pooled residual autocorrelation per m/z.\nacf_lag::Vector{Int}: lag used for acf (echoed) per m/z.\nn_pairs::Vector{Int}: total pairs contributing to acf per m/z.\nqc_z_rms::Vector{Float64}: pooled z-RMS per m/z.\nqc_cov68::Vector{Float64}: |z|≤1 coverage per m/z.\nqc_cov95::Vector{Float64}: |z|≤1.96 coverage per m/z.\nqc_s_min::Vector{Float64} / qc_s_max::Vector{Float64}: signal range per m/z.\nqc_nz::Vector{Int}: count of finite standardized residuals per m/z.\nobserved::Vector{Vector{Matrix{Float64}}}: raw data restricted to selected m/z, shaped as observed[b][r] :: n_scans_b × n_mz_select.\n\nNotes\n\nUse mz_values[j] for labels (multiply by mz_unit to recover Unitful values); use mz_idx[j] if you need to index into a full grid.\nobserved[b][r][:, j] matches the j-th selected m/z (i.e., mz_values[j]).\n\n\n\n\n\n","category":"type"},{"location":"man/quadvar_model/#JuChrom.residautocorr","page":"Quadratic Variance Model","title":"JuChrom.residautocorr","text":"residautocorr(Y, o, g, s, varmodel; lag=1, mask=nothing,\n              varfloor=1e-12, trimfrac=0.0)\n\nCompute the lag-lag residual autocorrelation for each replicate series.\n\nArguments\n\nY: data matrix (N × R).\no: offset matrix (N × R).\ng: gains vector (length R).\ns: shared signal vector (length N).\nvarmodel: function mapping s → variance.\n\nKeyword arguments\n\nlag::Int=1: autocorrelation lag (≥ 1).\nmask::Union{Nothing, AbstractVector{Bool}}=nothing: optional observation mask (length N); rows with mask[i] == false are excluded.\nvarfloor::Float64=1e-12: variance floor to avoid division by zero.\ntrimfrac::Float64=0.0: fraction (0 ≤ trimfrac < 0.5) of largest standardized residual pairs to trim before computing autocorrelation.\n\nReturns\n\nTuple (ρ_all, ρ_series, n_pairs):\n\nρ_all: overall pooled ACF across replicates (Fisher–z weighted).\nρ_series: vector of per-replicate ACF values.\nn_pairs: vector of counts of contributing lagged pairs per replicate.\n\n\n\n\n\n","category":"function"},{"location":"man/quadvar_model/#JuChrom.varpred","page":"Quadratic Variance Model","title":"JuChrom.varpred","text":"varpred(y, p::QuadVarParams; varfloor::Number=0)\n\nEvaluate the quadratic variance model elementwise using a parameter bundle:\n\nσ²(y) = p.σ₀² + p.ϕ * y + p.κ * y^2\n\nWorks for scalars, vectors, and matrices via broadcasting.\n\nArguments\n\ny: true input value(s) at which to evaluate the variance model (number or array).\np: QuadVarParams with fields σ₀², ϕ, κ.\n\nKeyword arguments\n\nvarfloor=0: elementwise lower bound applied to predicted variances; plain numbers are automatically converted to the variance units when σ₀² carries units. Also replaces non-finite results.\n\nReturns\n\nσ²(y) with the same shape as y. The element type is the promotion of eltype(y), the parameter field types in p, and typeof(varfloor).\n\nNotes\n\nNon-finite intermediate results are replaced by varfloor.\nPredicted values retain the units implied by σ₀²/ϕ.\nUse this when y is a true (non-estimated) input. For estimated inputs, see [varpredbias].\n\n\n\n\n\nvarpred(y, σ₀²::Number, ϕ::Number, κ::Number; varfloor::Number=0)\n\nEvaluate the quadratic variance model elementwise with scalar parameters:\n\nσ²(y) = σ₀² + ϕ * y + κ * y^2\n\nWorks for scalars, vectors, and matrices via broadcasting.\n\nArguments\n\ny: true input value(s) (number or array).\nσ₀², ϕ, κ: scalar parameters of the quadratic variance model.\n\nKeyword arguments\n\nvarfloor=0: elementwise lower bound applied to predicted variances; coerced to the correct units when σ₀² is unitful. Also replaces non-finite results.\n\nReturns\n\nσ²(y) with the same shape as y. The element type is the promotion of eltype(y), the parameter types, and typeof(varfloor).\n\nNotes\n\nNon-finite intermediate results are replaced by varfloor.\nPredicted values inherit the units of σ₀².\nIf you have a parameter bundle, use [varpred(y, p::QuadVarParams; varfloor=...)].\n\n\n\n\n\n","category":"function"},{"location":"man/quadvar_model/#JuChrom.varpredbias","page":"Quadratic Variance Model","title":"JuChrom.varpredbias","text":"varpredbias(y, p::QuadVarParams; varfloor::Number=0)\n\nEvaluate the quadratic variance model with a bias correction (for estimated y):\n\nσ²(y) = (p.σ₀² + p.ϕ * y + p.κ * y^2) / (1 + p.κ)\n\nWorks for scalars, vectors, and matrices via broadcasting.\n\nArguments\n\ny: estimated input value(s) (number or array).\np: QuadVarParams with fields σ₀², ϕ, κ.\n\nKeyword arguments\n\nvarfloor=0: elementwise lower bound applied to predicted variances; coercion to the variance units happens automatically when parameters are unitful. Also replaces non-finite results.\n\nReturns\n\nσ²(y) with the same shape as y. The element type is the promotion of eltype(y), the parameter field types in p, and typeof(varfloor).\n\nNotes\n\nNon-finite intermediate results are replaced by varfloor.\nPredicted values retain the units implied by σ₀²/ϕ.\nThis form assumes 1 + p.κ > 0 (typically ensured by enforcing κ_min ≥ 0).\nFor true (non-estimated) inputs, see [varpred].\n\n\n\n\n\n","category":"function"},{"location":"man/quadvar_model/#JuChrom.vif","page":"Quadratic Variance Model","title":"JuChrom.vif","text":"vif(ρ::Real, n::Integer; ρmax=0.8, nonnegative=true, nmin=1)\n\nCompute the variance inflation factor (VIF) associated with correlation ρ and sample size n. The factor is defined as\n\nVIF = 1 + 2 * ρ * (n_eff - 1) / n_eff\n\nwhere n_eff = max(n, nmin) ensures a minimum effective sample size.\n\nKeyword arguments\n\nρmax (default 0.8): maximum absolute correlation allowed after capping\nnonnegative (default true): if true, negative correlations are clipped to 0;  if false, correlations are symmetrically capped in [-ρmax, ρmax]\nnmin (default 1): minimum sample size used in n_eff\n\nBehavior\n\nNon-finite ρ values (NaN or Inf) are treated as 0\nCorrelations are sanitized (clipped and capped) before use\nThe result is always ≥ 1 (variance cannot be deflated)\n\nReturns\n\nA floating-point variance inflation factor of the same type as ρ.\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#Retention-Mapper","page":"Retention Mapper","title":"Retention Mapper","text":"","category":"section"},{"location":"man/retention_mapper/#JuChrom.applymap","page":"Retention Mapper","title":"JuChrom.applymap","text":"applymap(rm::RetentionMapper, retention::Union{<:Real, <:Quantity{<:Real}}; \n         domain_boundary_threshold::Real=1e-8,\n         warn::Bool=false, \n         unit::Union{<:Nothing, Unitful.Units}=rm.rB_unit)\n\nApply the fitted mapping to transform a retention value from domain A to domain B using the  fitted spline within the RetentionMapper.\n\nArguments\n\nrm::RetentionMapper: A fitted retention mapper containing the spline and normalization  parameters.\nretention::Union{<:Real, <:Quantity{<:Real}}: The retention value to be mapped from  domain A to domain B.\ndomain_boundary_threshold::Real=1e-8: Threshold for determining when to warn about extrapolation beyond the spline domain.\nwarn::Bool=false: If true, logs a warning when extrapolating beyond the spline domain.\nunit::Union{<:Nothing, Unitful.Units}=rm.rB_unit: Desired output unit (defaults to the  unit used for domain B during fitting).\n\nBehavior\n\nFor inputs outside the spline domain, linear extrapolation is performed using the  spline's first derivative at the boundary\nReturns the predicted output value on the original scale with appropriate units\n\nSee also rawapplymap, invmap, derivmap, derivinvmap,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]u\"Th\"\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> applymap(mapper, 5.0u\"minute\") ≈ 338.71144090340465u\"Th\"\ntrue\n\njulia> applymap(mapper, 0.5u\"minute\", warn=true) ≈ 44.68816899287087u\"Th\"\n[ Info: rA=0.5 is below the spline domain boundary (rA_min=1.2): extrapolating left.\ntrue\n\n\n\n\n\napplymap(rmap::RetentionMapper, series::MassScanSeries;\n         domain_boundary_threshold::Real=1e-8,\n         unit::Union{<:Nothing, Unitful.Units}=rm.rB_unit,\n         warn::Bool=false) -> MassScanSeries\n\nApply retention mapping rmap to series, transforming retention coordinates and scaling  intensities by the Jacobian to preserve peak areas.\n\nFor parameter descriptions and basic behavior, see applymap for single retention  values.\n\nReturns\n\nNew MassScanSeries with mapped retentions and Jacobian-corrected intensities\n\nImportant Notes\n\napplymap treats intensities as densities with respect to retention coordinates. Monotonic  reparameterization A→B rescales intensities by 1/(dB/dA) to preserve peak areas. If your  data are integrated counts per scan with variable dwell times, convert to densities first  using dwell time before calling applymap. Only numerical values are transformed — units  remain unchanged. If intensities are densities with retention units in the denominator,  handle unit transformation separately.\n\nExamples\n\n\n\n\n\napplymap(rmap::RetentionMapper,\n         msm::MassScanMatrix;\n         domain_boundary_threshold::Real=1e-8,\n         unit=rmap.rB_unit,\n         warn::Bool=false)\n    -> MassScanMatrix\n\nApply retention mapper rmap to msm, transforming retention coordinates and scaling intensities by the Jacobian to preserve peak areas.\n\nFor additional parameter descriptions and basic behavior, see applymap for  single retention values.\n\nReturns\n\nNew MassScanMatrix with mapped retentions and Jacobian-corrected intensities\n\nImportant Notes\n\napplymap treats intensities as densities with respect to retention coordinates. Monotonic  reparameterization A→B rescales intensities by 1/(dB/dA) to preserve peak areas. If your  data are integrated counts per scan with variable dwell times, convert to densities first  using dwell time before calling applymap. Only numerical values are transformed — units  remain unchanged. If intensities are densities with retention units in the denominator,  handle unit transformation separately.\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.derivinvmap","page":"Retention Mapper","title":"JuChrom.derivinvmap","text":"derivinvmap(rm::RetentionMapper, retention::Union{<:Real, <:Quantity{<:Real}};\n            rA_unit::T1=rm.rA_unit, rB_unit::T2=rm.rB_unit, tol::T3=1e-8, \n            warn::Bool=false) where {T1<:Union{Nothing, Unitful.Units}, \n            T2<:Union{Nothing, Unitful.Units}, T3<:Real}\n\nCompute the derivative of the inverse mapping, i.e. d(A)/d(B), at a given output value  (domain B).\n\nThis function computes the local derivative d(A)/d(B) at a given output value using  the inverse of the normalized B-spline approximation stored in the RetentionMapper.  This derivative describes how a small change in the output (domain B) would translate  back to a change in the input (domain A), under the smoothed, monotonic mapping. If the  output value is outside the supported domain, extrapolation is performed using the boundary  derivative. The derivative is adjusted to account for the normalization scales applied  during spline fitting.\n\nArguments\n\nrm::RetentionMapper: The retention mapper containing spline and scaling parameters.\nretention::Union{<:Real, <:Quantity{<:Real}}: Output value (domain B) for which the  inverse derivative is computed.\nrA_unit: Desired input unit for the derivative (defaults to the domain A unit used in  fitting).\nrB_unit: Desired output unit for the derivative (defaults to the domain B unit used in  fitting).\ntol::Real=1e-8: Tolerance for root-finding when locating the corresponding input value.\nwarn::Bool=false: Whether to emit informational messages when extrapolating outside the  spline domain.\n\nReturns\n\nThe derivative d(A)/d(B) at the specified output value, with units of rA_unit/rB_unit.\n\nNotes\n\nFor retention time/retention index mappings, this gives the local \"time per retention  index unit\" rate.\nThis is the reciprocal of the forward derivative from derivmap.\nThe derivative is always positive due to the monotonicity constraint.\nRoot-finding is used to locate the corresponding input value before computing the  derivative.\n\nSee also derivmap, applymap, invmap, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]u\"Th\"\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> derivinvmap(mapper, 350.0u\"Th\") ≈ 0.02857099580171666u\"minute/Th\"\ntrue\n\njulia> derivinvmap(mapper, 350.0)\nERROR: ArgumentError: Input must have units when rm.rB_unit is a Unitful unit. Expected units compatible with Th.\n\njulia> test_indices = [250.0, 600.0]u\"Th\";\n\njulia> derivinvmap.(mapper, test_indices) ≈ [0.015606366497378708, 0.03240806524912834]u\"minute/Th\"\ntrue\n\njulia> derivinvmap(mapper, 350.0u\"Th\", rA_unit=u\"s\", rB_unit=u\"kTh\") ≈ 1714.2597481029995u\"s/kTh\"\ntrue\n\njulia> derivinvmap(mapper, 50.0u\"Th\", warn=true) ≈ 0.012655503630152843u\"minute/Th\"\n[ Info: rB=50.0 is below the inverse spline domain boundary (rB_min=100.000073): extrapolating left.\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.derivmap","page":"Retention Mapper","title":"JuChrom.derivmap","text":"derivmap(rm::RetentionMapper, retention::Union{<:Real, <:Quantity{<:Real}};\n         rA_unit::T1=rm.rA_unit, rB_unit::T2=rm.rB_unit, warn::Bool=false) where {\n         T1<:Union{Nothing, Unitful.Units}, T2<:Union{Nothing, Unitful.Units}}\n\nCompute the first derivative of the fitted mapping with respect to the input (domain A)  at a given input value.\n\nThis function evaluates the derivative of the fitted monotonic B-spline, extrapolating  using boundary derivatives if the input lies outside the spline domain. The derivative is  adjusted to account for the normalization scales applied during spline fitting.\n\nArguments\n\nrm::RetentionMapper: The retention mapper containing spline and scaling parameters.\nretention::Union{<:Real, <:Quantity{<:Real}}: Input value (domain A) at which to  evaluate the derivative.\nrA_unit: Desired input unit for the derivative (defaults to the domain A unit used in  fitting).\nrB_unit: Desired output unit for the derivative (defaults to the domain B unit used in  fitting).\nwarn::Bool=false: Whether to emit informational messages when extrapolating outside the  spline domain.\n\nReturns\n\nThe derivative d(B)/d(A) at the specified input value, with units of rB_unit/rA_unit.\n\nNotes\n\nFor retention time/retention index mappings, this gives the local \"retention index per  unit time\" rate.\nThe derivative is always positive due to the monotonicity constraint, indicating the  rate of increase.\nExtrapolation uses constant derivatives at the boundaries, ensuring smooth behavior  outside the fitted domain.\n\nSee also derivinvmap, applymap, invmap, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> derivmap(mapper, 5.0u\"minute\") ≈ 37.42885149584893u\"minute^-1\"\ntrue\n\njulia> test_times = [3.0, 11.0]u\"minute\";\n\njulia> derivmap.(mapper, test_times) ≈ [67.10235298491122, 34.639458067769134]u\"minute^-1\"\ntrue\n\njulia> derivmap(mapper, 5.0u\"minute\", rA_unit=u\"s\") ≈ 0.6238141915974822u\"s^-1\"\ntrue\n\njulia> derivmap(mapper, 0.8u\"minute\", warn=true) ≈ 79.01700550402535u\"minute^-1\"\n[ Info: rA=0.8 is below the spline domain boundary (rA_min=1.2): extrapolating left.\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.extras","page":"Retention Mapper","title":"JuChrom.extras","text":"extras(msm::AbstractMassScanMatrix) -> Dict{String, Any}\n\nReturns the unstructured extras associated with the mass scan matrix.\n\nThis dictionary may contain arbitrary key-value pairs that are not captured by the  structured fields such as instrument, acquisition, user, or sample.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix.\n\nReturns\n\nA Dict{String, Any} containing unstructured metadata.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, acquisition,  instrument, sample, user.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]; \n                             extras=Dict(\"run\" => 42, \"comment\" => \"Baseline drift\"));\n\njulia> extras(msm)\nDict{String, Any} with 2 entries:\n  \"run\"     => 42\n  \"comment\" => \"Baseline drift\"\n\njulia> extras(msm)[\"qc_passed\"] = true;\n\njulia> extras(msm)\nDict{String, Any} with 3 entries:\n  \"qc_passed\" => true\n  \"run\"       => 42\n  \"comment\"   => \"Baseline drift\"\n\n\n\n\n\nextras(series::AbstractScanSeries) -> Dict{String, Any}\n\nReturns the unstructured extras associated with the scan series.\n\nThis dictionary may contain arbitrary key-value pairs that are not captured by the  structured fields such as instrument, acquisition, user, or sample.\n\nArguments\n\nseries: A concrete subtype of AbstractScanSeries.\n\nReturns\n\nA Dict{String, Any} containing unstructured metadata.\n\nSee also instrument, acquisition, user, sample.\n\nExamples\n\njulia> s = [ChromScan(1.0u\"s\", 10.0u\"V\"), ChromScan(2.0u\"s\", 200.0u\"V\")];\n\njulia> series = ChromScanSeries(s, extras=Dict(\"run\"=>42, \"comment\"=>\"Baseline drift\"));\n\njulia> extras(series)\nDict{String, Any} with 2 entries:\n  \"run\"     => 42\n  \"comment\" => \"Baseline drift\"\n\njulia> extras(series)[\"qc_passed\"] = true;\n\njulia> extras(series)\nDict{String, Any} with 3 entries:\n  \"qc_passed\" => true\n  \"run\"       => 42\n  \"comment\"   => \"Baseline drift\"\n\n\n\n\n\nextras(rm::AbstractRetentionMapper)\n\nRetrieve the metadata dictionary associated with the retention mapper.\n\nThe metadata can store additional information about the mapper, such as the calibration  file name, creation date, experimental conditions, or other user-defined properties  that were stored during mapper creation or added subsequently.\n\nArguments\n\nrm::AbstractRetentionMapper: The retention mapper from which to retrieve metadata.\n\nReturns\n\nA Dict{String, Any} containing the metadata key-value pairs. Returns an empty  dictionary if no metadata was stored.\n\nNotes\n\nMetadata is stored as a mutable dictionary and can be modified after mapper creation.\nCommon metadata keys include \"calfile\", \"creationdate\", \"instrument\", etc.\nThe metadata does not affect the mathematical mapping operations.\n\nSee also fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]\n       mapper = fitmap(retention_times, retention_indices, \n                       extras=Dict(\"cal_file\" => \"test.cal\", \"instrument\" => \"GC-MS\"));\n\njulia> extras(mapper)\nDict{String, Any} with 2 entries:\n  \"cal_file\"   => \"test.cal\"\n  \"instrument\" => \"GC-MS\"\n\njulia> extras(mapper)[\"cal_file\"]\n\"test.cal\"\n\njulia> extras(mapper)[\"analysis_date\"] = \"2025-06-28\";\n\njulia> extras(mapper)\nDict{String, Any} with 3 entries:\n  \"cal_file\"      => \"test.cal\"\n  \"instrument\"    => \"GC-MS\"\n  \"analysis_date\" => \"2025-06-28\"\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.fitmap","page":"Retention Mapper","title":"JuChrom.fitmap","text":"fitmap(retentions_A::AbstractVector{<:Union{<:Real, <:Quantity{<:Real}}},\n       retentions_B::AbstractVector{<:Union{<:Real, <:Quantity{<:Real}}};\n       smoothness_penalty_n::Integer=100,\n       monotonicity_grid_size::Integer=10^5,\n       λ_max::Real=1e2,\n       λ_min::Real=1e-20,\n       logλ_tolerance::Real=1e-4,\n       max_lambda_iters::Integer=100,\n       extras::AbstractDict{<:AbstractString, <:Any}=Dict{String, Any}())\n\nConstructs a strictly increasing, smooth cubic B-spline that maps values from domain A  (retentions_A) to domain B (retentions_B), subject to a monotonicity constraint and  smoothness penalty.\n\nThe fitted spline minimizes a regularized least-squares objective: data fidelity (squared  residuals) and a smoothness penalty (second derivative norm), subject to non-negativity of  the first derivative.\n\nThe smoothing parameter λ is automatically determined via binary search: it selects the  smallest value that yields a monotonic spline while fitting the data as closely as possible,  thus ensuring both stability and high fidelity without introducing spurious oscillations.\n\nThis method offers a principled and robust way to construct a physically meaningful mapping between any two monotonically related quantities:\n\nMonotonicity enforcement ensures the fitted function is strictly increasing, which is appropriate when the relationship between the two variables is expected to be monotonic.\nAutomatic regularization strength selection identifies the highest level of smoothing that still maintains monotonicity, balancing accurate data representation with robustness against overfitting and numerical instability.\nInvertibility is guaranteed due to strict monotonicity, enabling reliable backward mapping from domain B to domain A.\nNumerical robustness is achieved through convex optimization over normalized data, ensuring convergence and stability across a wide range of inputs.\n\nArguments\n\nretentions_A::AbstractVector{<:Union{<:Real, <:Quantity{<:Real}}}: Input domain values  (strictly increasing, same units if using Unitful quantities).\nretentions_B::AbstractVector{<:Union{<:Real, <:Quantity{<:Real}}}: Corresponding output  domain values.\nsmoothness_penalty_n::Integer=100: Number of evaluation points for curvature penalty.\nmonotonicity_grid_size::Integer=10^5: Number of grid points to enforce monotonicity.\nλ_max::Real=1e2: Upper bound for smoothness parameter search.\nλ_min::Real=1e-20: Lower bound for smoothness parameter search.\nlogλ_tolerance::Real=1e-4: Tolerance for log₁₀(λ) convergence in binary search.\nmax_lambda_iters::Integer=100: Maximum number of iterations for λ search.\nextras::AbstractDict{<:AbstractString, <:Any}: Optional metadata to attach to the  mapper.\n\nReturns\n\nA RetentionMapper object containing the fitted monotonic spline and associated metadata.\n\nSee also extras, mapmin, rawmapmin, mapmax,  rawmapmax, invmapmin, rawinvmapmin, invmapmax,  rawinvmapmax, applymap, invmap, derivinvmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0];\n\njulia> mapper = fitmap(retention_times, retention_indices, \n                      extras=Dict(\"instrument\" => \"GC-MS\", \"column\" => \"DB-5\"));\n\njulia> applymap(mapper, 5.0u\"minute\") ≈ 338.71144090340465\ntrue\n\njulia> invmap(mapper, 150) ≈ 1.8368240074613091u\"minute\"\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.invmap","page":"Retention Mapper","title":"JuChrom.invmap","text":"invmap(rm::RetentionMapper, retention::Union{<:Real, <:Quantity{<:Real}};\n       unit::T1=rm.rA_unit, tol::T2=1e-8, warn::Bool=false\n       ) where {T1<:Unitful.TimeUnits, T2<:Real}\n\nInvert the fitted mapping by computing the input value (domain A) corresponding to a given  output value (domain B).\n\nArguments\n\nrm::RetentionMapper: The fitted retention mapper containing the spline and scaling info.\nretention::Union{<:Real, <:Quantity{<:Real}}: Output value from domain B to invert back  to domain A.\nunit: Desired output unit (defaults to the unit used for domain A during fitting).\ntol::Real=1e-8: Tolerance for root-finding (default 1e-8).\nwarn::Bool=false: If true, logs warnings when extrapolating beyond spline domain.\n\nBehavior\n\nNormalizes the input value to the spline domain.\nPerforms linear extrapolation beyond the spline range using derivative at the boundaries.\nUses numerical root-finding (bisection method) within the spline domain for precise  inversion.\nConverts result back to original domain A scale with requested units.\n\nThis function leverages the strict monotonicity of the fitted spline to provide reliable  inverse mapping, enabling bidirectional conversion between the two domains.\n\nSee also rawinvmap, applymap, derivmap, derivinvmap,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]u\"Th\"\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> invmap(mapper, 350.0u\"Th\") ≈ 5.312425320906996u\"minute\"\ntrue\n\njulia> invmap(mapper, 350.0)\nERROR: ArgumentError: Input must have units when rm.rB_unit is a Unitful unit. Expected units compatible with Th.\n[...]\n\njulia> test_indices = [250.0u\"Th\", 450.0u\"Th\"];\n\njulia> invmap.(mapper, test_indices) ≈ [3.2283166885897936, 8.08686182716771]u\"minute\"\ntrue\n\njulia> invmap(mapper, 400.0u\"Th\", unit=u\"s\") ≈ 407.99982102982375u\"s\"\ntrue\n\njulia> invmap(mapper, 50.0u\"Th\", warn=true) ≈ 0.5672238965934812u\"minute\"\n[ Info: rB=50.0 is below the inverse spline domain boundary (rB_min=100.000073): extrapolating left.\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.invmapmax","page":"Retention Mapper","title":"JuChrom.invmapmax","text":"invmapmax(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the maximum predicted value of the output domain (domain B) for the fitted  retention mapper.\n\nThis corresponds to the predicted output value at the maximum input value and represents  the upper bound of the output range that can be reliably inverted back to input values. For unitful mappers, returns the value with units; for unitless mappers, returns the raw  numeric value.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: Desired output unit (optional). If specified for unitful mappers, converts to  the requested unit.\n\nReturns\n\nThe maximum predicted output value. For unitful mappers, returns a Quantity with  appropriate units (converted if unit is specified). For unitless mappers, returns the  raw numeric value.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention B maximum to a unit\".\n\nSee also rawinvmapmax, invmapmin, rawinvmapmin,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> invmapmax(mapper) ≈ 499.9999793028839\ntrue\n\njulia> invmapmax(mapper) ≈ applymap(mapper, mapmax(mapper))\ntrue\n\njulia> invmap(mapper, invmapmax(mapper)) ≈ mapmax(mapper)\ntrue\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> invmapmax(mapper_unitless) ≈ 499.9999793028839\ntrue\n\njulia> invmapmax(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.invmapmin","page":"Retention Mapper","title":"JuChrom.invmapmin","text":"invmapmin(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the minimum predicted value of the output domain (domain B) for the fitted retention  mapper. This corresponds to the predicted output value at the minimum input value and  represents the lower bound of the output range that can be reliably inverted back to input  values. For unitful mappers, returns the value with units; for unitless mappers, returns  the raw numeric value.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: Desired output unit (optional). If specified for unitful mappers, converts to  the requested unit.\n\nReturns\n\nThe minimum predicted output value. For unitful mappers, returns a Quantity with  appropriate units (converted if unit is specified). For unitless mappers, returns the  raw numeric value.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention B minimum to a unit\".\n\nSee also rawinvmapmin, invmapmax, rawinvmapmax,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> invmapmin(mapper) ≈ 100.00001207241763\ntrue\n\njulia> invmapmin(mapper) ≈ applymap(mapper, mapmin(mapper))\ntrue\n\njulia> (invmapmin(mapper), invmapmax(mapper)) .≈ (100.00001207241763, 499.9999793028839)\n(true, true)\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> invmapmin(mapper_unitless) ≈ 100.00001207241763\ntrue\n\njulia> invmapmin(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.mapmax","page":"Retention Mapper","title":"JuChrom.mapmax","text":"mapmax(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the maximum value of the input domain (domain A) for the fitted retention mapper. This corresponds to the largest input value used during calibration and represents the upper bound of the reliable interpolation range. For unitful mappers, returns the value with units; for unitless mappers, returns the raw numeric value.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: Desired output unit (optional). If specified for unitful mappers, converts to  the requested unit.\n\nReturns\n\nThe maximum input value from the calibration data. For unitful mappers, returns a Quantity with appropriate units (converted if unit is specified). For unitless mappers, returns the raw numeric value.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention A maximum to a unit\".\n\nSee also rawmapmax, mapmin, rawmapmin, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> mapmax(mapper) ≈ 9.3u\"minute\"\ntrue\n\njulia> mapmax(mapper, unit=u\"s\") ≈ 558.0u\"s\"\ntrue\n\njulia> (mapmin(mapper), mapmax(mapper)) .≈ (1.2u\"minute\", 9.3u\"minute\")\n(true, true)\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> mapmax(mapper_unitless) ≈ 9.3\ntrue\n\njulia> mapmax(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.mapmin","page":"Retention Mapper","title":"JuChrom.mapmin","text":"mapmin(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the minimum value of the input domain (domain A) for the fitted retention mapper. This corresponds to the smallest input value used during calibration and represents the lower bound of the reliable interpolation range. For unitful mappers, returns the value with units; for unitless mappers, returns the raw numeric value.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: Desired output unit (optional). If specified for unitful mappers, converts to the requested unit.\n\nReturns\n\nThe minimum input value from the calibration data. For unitful mappers, returns a Quantity with appropriate units (converted if unit is specified). For unitless mappers, returns the raw numeric value.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention A minimum to a unit\".\n\nSee also rawmapmin, mapmax, rawmapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> mapmin(mapper) ≈ 1.2u\"minute\"\ntrue\n\njulia> mapmin(mapper, unit=u\"s\") ≈ 72.0u\"s\"\ntrue\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> mapmin(mapper_unitless) ≈ 1.2\ntrue\n\njulia> mapmin(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawapplymap","page":"Retention Mapper","title":"JuChrom.rawapplymap","text":"rawapplymap(rm::RetentionMapper, retention::Quantity{<:Real};\n            warn::Bool=false, unit::Union{<:Nothing, Unitful.Units}=rm.rB_unit)\n\nApply the fitted mapping to transform an input value from domain A to domain B using the fitted spline within the RetentionMapper, returning a unitless numeric result.\n\nArguments\n\nrm::RetentionMapper: A fitted retention mapper containing the spline and normalization parameters.\nretention::Quantity{<:Real}: The input value with units to be mapped from domain A to  domain B.\nwarn::Bool=false: If true, logs a warning when extrapolating beyond the spline domain.\nunit::Union{<:Nothing, Unitful.Units}=rm.rB_unit: Unit system for the output value  before unit stripping (defaults to the unit used for domain B during fitting).\n\nBehavior\n\nInput value is normalized before spline evaluation.\nIf the input lies outside the spline domain, linear extrapolation is performed using the spline's first derivative at the boundary.\nReturns the predicted output value as a unitless number in the specified unit system.\nRequires input with units (use applymap for unitless inputs).\n\nThis function provides the same transformation as applymap but strips units from  the result, which is useful for downstream calculations that require raw numeric values.\n\nSee also applymap, invmap, derivmap, derivinvmap,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]u\"Th\"\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawapplymap(mapper, 5.0u\"minute\") ≈ 338.71144090340465\ntrue\n\njulia> test_times = [3.0, 11.0]u\"minute\";\n\njulia> rawapplymap.(mapper, test_times) ≈ [235.0195638002354, 564.0302630521933]\ntrue\n\njulia> rawapplymap(mapper, 0.5u\"minute\", warn=true) ≈ 44.68816899287087\n[ Info: rA=0.5 is below the spline domain boundary (rA_min=1.2): extrapolating left.\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawderivinvmap","page":"Retention Mapper","title":"JuChrom.rawderivinvmap","text":"rawderivinvmap(rm::RetentionMapper, retention::Union{<:Real, <:Quantity{<:Real}};\n              rA_unit::T1=rm.rA_unit, rB_unit::T2=rm.rB_unit, tol::T3=1e-8, \n              warn::Bool=false) where {T1<:Union{Nothing, Unitful.Units}, \n              T2<:Union{Nothing, Unitful.Units}, T3<:Real}\n\nCompute the derivative of the inverse mapping, i.e. d(A)/d(B), at a given output value  (domain B), returning a unitless numeric result.\n\nThis function computes the local derivative d(A)/d(B) at a given output value using  the inverse of the normalized B-spline approximation stored in the RetentionMapper.  This derivative describes how a small change in the output (domain B) would translate  back to a change in the input (domain A), under the smoothed, monotonic mapping. If the  output value is outside the supported domain, extrapolation is performed using the boundary  derivative. The derivative is adjusted to account for the normalization scales applied  during spline fitting.\n\nArguments\n\nrm::RetentionMapper: The retention mapper containing spline and scaling parameters.\nretention::Union{<:Real, <:Quantity{<:Real}}: Output value (domain B) for which the  inverse derivative is computed.\nrA_unit: Input unit for the derivative calculation (defaults to the domain A unit used  in fitting).\nrB_unit: Output unit for the derivative calculation (defaults to the domain B unit used  in fitting).\ntol::Real=1e-8: Tolerance for root-finding when locating the corresponding input value.\nwarn::Bool=false: Whether to emit informational messages when extrapolating outside the  spline domain.\n\nReturns\n\nThe derivative d(A)/d(B) at the specified output value as a unitless number, expressed in  the unit system of rA_unit/rB_unit before unit stripping.\n\nNotes\n\nFor retention time/retention index mappings, this gives the local \"time per retention  index unit\" rate as a raw numeric value.\nThis is the reciprocal of the forward derivative from rawderivmap.\nThe derivative is always positive due to the monotonicity constraint.\nRoot-finding is used to locate the corresponding input value before computing the  derivative.\n\nThis function provides the same transformation as derivinvmap but strips units from  the result, which is useful for downstream calculations that require raw numeric values.\n\nSee also derivinvmap, derivmap, applymap, invmap,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]u\"Th\"\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawderivinvmap(mapper, 350.0u\"Th\") ≈ 0.02857099580171666\ntrue\n\njulia> rawderivinvmap(mapper, 350.0)\nERROR: ArgumentError: Input must have units when rm.rB_unit is a Unitful unit. Expected units compatible with Th.\n[...]\n\njulia> test_indices = [250.0, 600.0]u\"Th\";\n\njulia> rawderivinvmap.(mapper, test_indices) ≈ [0.015606366497378708, 0.03240806524912834]\ntrue\n\njulia> rawderivinvmap(mapper, 350.0u\"Th\", rA_unit=u\"s\") ≈ 1.7142597481029995\ntrue\n\njulia> rawderivinvmap(mapper, 50.0u\"Th\", warn=true) ≈ 0.012655503630152843\n[ Info: rB=50.0 is below the inverse spline domain boundary (rB_min=100.000073): extrapolating left.\ntrue\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawderivinvmap(mapper, 350.0) ≈ 0.02857099580171666\ntrue\n\njulia> rawderivinvmap(mapper, 350.0u\"Th\")\nERROR: ArgumentError: Input cannot have units when rm.rB_unit is Nothing. Expected unitless input.\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawderivmap","page":"Retention Mapper","title":"JuChrom.rawderivmap","text":"rawderivmap(rm::RetentionMapper, retention::Quantity{<:Real};\n            rA_unit::T1=rm.rA_unit, rB_unit::T2=rm.rB_unit, warn::Bool=false) where {\n            T1<:Union{Nothing, Unitful.Units}, T2<:Union{Nothing, Unitful.Units}}\n\nCompute the first derivative of the fitted mapping with respect to the input (domain A) at a given input value, returning a unitless numeric result.\n\nThis function evaluates the derivative of the fitted monotonic B-spline, extrapolating using boundary derivatives if the input lies outside the spline domain. The derivative is adjusted to account for the normalization scales applied during spline fitting.\n\nArguments\n\nrm::RetentionMapper: The retention mapper containing spline and scaling parameters.\nretention::Quantity{<:Real}: Input value with units (domain A) at which to evaluate  the derivative.\nrA_unit: Input unit for the derivative calculation (defaults to the domain A unit used  in fitting).\nrB_unit: Output unit for the derivative calculation (defaults to the domain B unit used  in fitting).\nwarn::Bool=false: Whether to emit informational messages when extrapolating outside the spline domain.\n\nReturns\n\nThe derivative d(B)/d(A) at the specified input value as a unitless number, expressed in  the unit system of rB_unit/rA_unit before unit stripping.\n\nNotes\n\nRequires input with units (use derivmap for unitless inputs).\nFor retention time/retention index mappings, this gives the local \"retention index per unit time\" rate as a raw numeric value.\nThe derivative is always positive due to the monotonicity constraint.\nExtrapolation uses constant derivatives at the boundaries, ensuring smooth behavior outside the fitted domain.\n\nThis function provides the same transformation as derivmap but strips units from  the result, which is useful for downstream calculations that require raw numeric values.\n\nSee also derivmap, derivinvmap, applymap, invmap,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawderivmap(mapper, 5.0u\"minute\") ≈ 37.42885149584893\ntrue\n\njulia> test_times = [3.0, 11.0]u\"minute\";\n\njulia> rawderivmap.(mapper, test_times) ≈ [67.10235298491122, 34.639458067769134]\ntrue\n\njulia> rawderivmap(mapper, 5.0u\"minute\", rA_unit=u\"s\") ≈ 0.6238141915974822\ntrue\n\njulia> rawderivmap(mapper, 0.8u\"minute\", warn=true) ≈ 79.01700550402535\n[ Info: rA=0.8 is below the spline domain boundary (rA_min=1.2): extrapolating left.\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawinvmap","page":"Retention Mapper","title":"JuChrom.rawinvmap","text":"rawinvmap(rm::RetentionMapper, retention::Quantity{<:Real};\n          unit::T1=rm.rA_unit, tol::T2=1e-8, warn::Bool=false\n          ) where {T1<:Unitful.TimeUnits, T2<:Real}\n\nInvert the fitted mapping by computing the input value (domain A) corresponding to a given  output value (domain B), returning a unitless numeric result.\n\nArguments\n\nrm::RetentionMapper: The fitted retention mapper containing the spline and scaling info.\nretention::Quantity{<:Real}: Output value with units from domain B to invert back  to domain A.\nunit: Unit system for the output value before unit stripping (defaults to the unit used  for domain A during fitting).\ntol::Real=1e-8: Tolerance for root-finding (default 1e-8).\nwarn::Bool=false: If true, logs warnings when extrapolating beyond spline domain.\n\nBehavior\n\nNormalizes the input value to the spline domain.\nPerforms linear extrapolation beyond the spline range using derivative at the boundaries.\nUses numerical root-finding (bisection method) within the spline domain for precise  inversion.\nReturns the result as a unitless number in the specified unit system.\nRequires input with units (use invmap for unitless inputs).\n\nThis function leverages the strict monotonicity of the fitted spline to provide reliable  inverse mapping, enabling bidirectional conversion between the two domains while returning raw numeric values useful for downstream calculations.\n\nSee also invmap, applymap, derivmap, derivinvmap,  fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]u\"Th\"\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawinvmap(mapper, 350.0u\"Th\") ≈ 5.312425320906996\ntrue\n\njulia> rawinvmap(mapper, 350.0) ≈ 5.312425320906996\nERROR: ArgumentError: Input must have units when rm.rB_unit is a Unitful unit. Expected units compatible with Th.\n[...]\n\njulia> test_indices = [250.0, 450.0]u\"Th\";\n\njulia> rawinvmap.(mapper, test_indices) ≈ [3.2283166885897936, 8.08686182716771]\ntrue\n\njulia> rawinvmap(mapper, 400.0u\"Th\", unit=u\"s\") ≈ 407.99982102982375\ntrue\n\njulia> rawinvmap(mapper, 50.0u\"Th\", warn=true) ≈ 0.5672238965934812\n[ Info: rB=50.0 is below the inverse spline domain boundary (rB_min=100.000073): extrapolating left.\ntrue\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3, 12.1, 15.7]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawinvmap(mapper, 350.0) ≈ 5.312425320906996\ntrue\n\njulia> rawinvmap(mapper, 350.0u\"Th\") ≈ 5.312425320906996\nERROR: ArgumentError: Input cannot have units when rm.rB_unit is Nothing. Expected unitless input.\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawinvmapmax","page":"Retention Mapper","title":"JuChrom.rawinvmapmax","text":"rawinvmapmax(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw numeric maximum predicted value of the output domain (domain B), stripped  of units.\n\nThis function always returns the numeric value without units, regardless of whether the  mapper was created with unitful or unitless data.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: For unitful mappers, specifies the unit to convert to before stripping.  For unitless mappers, this parameter is ignored.\n\nReturns\n\nThe maximum predicted output value as a raw number (no units), optionally converted to  the specified unit first.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention B maximum to a unit\".\n\nSee also invmapmax, invmapmin, rawinvmapmin, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawinvmapmax(mapper) ≈ 499.9999793028839\ntrue\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> rawinvmapmax(mapper_unitless) ≈ 499.9999793028839\ntrue\n\njulia> rawinvmapmax(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawinvmapmin","page":"Retention Mapper","title":"JuChrom.rawinvmapmin","text":"rawinvmapmin(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw numeric minimum predicted value of the output domain (domain B), stripped  of units.\n\nThis function always returns the numeric value without units, regardless of whether  the mapper was created with unitful or unitless data.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: For unitful mappers, specifies the unit to convert to before stripping.  For unitless mappers, this parameter is ignored.\n\nReturns\n\nThe minimum predicted output value as a raw number (no units), optionally converted to the  specified unit first.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention B minimum to a unit\".\n\nSee also invmapmin, invmapmax, rawinvmapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawinvmapmin(mapper) ≈ 100.00001207241763\ntrue\n\njulia> (rawinvmapmin(mapper), rawinvmapmax(mapper)) .≈ (100.00001207241763, 499.9999793028839)\n(true, true)\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> rawinvmapmin(mapper_unitless) ≈ 100.00001207241763\ntrue\n\njulia> rawinvmapmin(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawmapmax","page":"Retention Mapper","title":"JuChrom.rawmapmax","text":"rawmapmax(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw numeric maximum value of the input domain (domain A), stripped of units. This function always returns the numeric value without units, regardless of whether the mapper was created with unitful or unitless data.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: For unitful mappers, specifies the unit to convert to before stripping. For unitless mappers, this parameter is ignored.\n\nReturns\n\nThe maximum input value as a raw number (no units), optionally converted to the specified  unit first.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention A maximum to a unit\".\n\nSee also mapmax, mapmin, rawmapmin, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawmapmax(mapper) ≈ 9.3\ntrue\n\njulia> rawmapmax(mapper, unit=u\"s\") ≈ 558.0\ntrue\n\njulia> (rawmapmin(mapper), rawmapmax(mapper)) .≈ (1.2, 9.3)\n(true, true)\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> rawmapmax(mapper_unitless) ≈ 9.3\ntrue\n\njulia> rawmapmax(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawmapmin","page":"Retention Mapper","title":"JuChrom.rawmapmin","text":"rawmapmin(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw numeric minimum value of the input domain (domain A), stripped of units. This function always returns the numeric value without units, regardless of whether the mapper was created with unitful or unitless data.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: For unitful mappers, specifies the unit to convert to before stripping. For unitless mappers, this parameter is ignored.\n\nReturns\n\nThe minimum input value as a raw number (no units), optionally converted to the specified unit first.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention A minimum to a unit\".\n\nSee also mapmin, mapmax, rawmapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawmapmin(mapper) ≈ 1.2\ntrue\n\njulia> rawmapmin(mapper, unit=u\"s\") ≈ 72.0\ntrue\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> rawmapmin(mapper_unitless) ≈ 1.2\ntrue\n\njulia> rawmapmin(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A minimum to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawretentions_A","page":"Retention Mapper","title":"JuChrom.rawretentions_A","text":"rawretentions_A(rm::AbstractRetentionMapper;\n                unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw numeric calibration data values from the input domain (domain A), stripped  of units.\n\nThis function always returns the numeric values without units, regardless of whether  the mapper was created with unitful or unitless data.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: For unitful mappers, specifies the unit to convert to before stripping.  For unitless mappers, this parameter is ignored.\n\nReturns\n\nA vector of raw numeric calibration input values (no units), optionally converted to the  specified unit first.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention A to a unit\".\n\nSee also retentions_A, retentions_B, rawretentions_B,  mapmin, mapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawretentions_A(mapper) ≈ [1.2, 2.5, 4.1, 6.8, 9.3]\ntrue\n\njulia> rawretentions_A(mapper, unit=u\"s\") ≈ [72.0, 150.0, 246.0, 408.0, 558.0]\ntrue\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> rawretentions_A(mapper_unitless) ≈ [1.2, 2.5, 4.1, 6.8, 9.3]\ntrue\n\njulia> rawretentions_A(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.rawretentions_B","page":"Retention Mapper","title":"JuChrom.rawretentions_B","text":"rawretentions_B(rm::AbstractRetentionMapper;\n                unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw numeric calibration data values from the output domain (domain B),  stripped of units.\n\nThis function always returns the numeric values without units, regardless of whether  the mapper was created with unitful or unitless data.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: For unitful mappers, specifies the unit to convert to before stripping.  For unitless mappers, this parameter is ignored.\n\nReturns\n\nA vector of raw numeric calibration output values (no units), optionally converted to the  specified unit first.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention B to a unit\".\n\nSee also retentions_B, retentions_A, rawretentions_A,  mapmin, mapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> rawretentions_B(mapper) ≈ [100.0, 200.0, 300.0, 400.0, 500.0]\ntrue\n\njulia> rawretentions_B(mapper, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention B to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.retentions_A","page":"Retention Mapper","title":"JuChrom.retentions_A","text":"retentions_A(rm::AbstractRetentionMapper; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the calibration data values from the input domain (domain A) used to fit the  retention mapper.\n\nThis function provides access to the original input values that were used during  calibration. For unitful mappers, returns the values with units; for unitless mappers,  returns the raw numeric values.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: Desired output unit (optional). If specified for unitful mappers, converts to  the requested unit.\n\nReturns\n\nA vector of calibration input values. For unitful mappers, returns a vector of Quantity  objects with appropriate units (converted if unit is specified). For unitless mappers,  returns a vector of raw numeric values.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention A to a unit\".\n\nSee also rawretentions_A, retentions_B, rawretentions_B,  mapmin, mapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> retentions_A(mapper) ≈ [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\ntrue\n\njulia> retentions_A(mapper, unit=u\"s\") ≈ [72.0, 150.0, 246.0, 408.0, 558.0]u\"s\"\ntrue\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> retentions_A(mapper_unitless) ≈ [1.2, 2.5, 4.1, 6.8, 9.3]\ntrue\n\njulia> retentions_A(mapper_unitless, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention A to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.retentions_B","page":"Retention Mapper","title":"JuChrom.retentions_B","text":"retentions_B(rm::AbstractRetentionMapper;\nunit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the calibration data values from the output domain (domain B) used to fit the  retention mapper.\n\nThis function provides access to the original output values that were used during  calibration. For unitful mappers, returns the values with units; for unitless mappers,  returns the raw numeric values.\n\nArguments\n\nrm::AbstractRetentionMapper: The fitted retention mapper.\nunit: Desired output unit (optional). If specified for unitful mappers, converts to  the requested unit.\n\nReturns\n\nA vector of calibration output values. For unitful mappers, returns a vector of Quantity  objects with appropriate units (converted if unit is specified). For unitless mappers,  returns a vector of raw numeric values.\n\nThrows\n\nArgumentError: When attempting to specify a unit for a unitless mapper. The error message will be \"Cannot convert unitless retention B to a unit\".\n\nSee also rawretentions_B, retentions_A, rawretentions_A,  mapmin, mapmax, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> retentions_B(mapper) ≈ [100.0, 200.0, 300.0, 400.0, 500.0]\ntrue\n\njulia> retentions_B(mapper, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention B to a unit\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.retentionunit_A","page":"Retention Mapper","title":"JuChrom.retentionunit_A","text":"retentionunit_A(mapper::AbstractRetentionMapper)\n\nReturn the unit associated with the input domain (domain A) of the retention mapper.\n\nFor unitful mappers, this returns the Unitful.Units object representing the unit  of the input values. For unitless mappers, this returns Nothing.\n\nArguments\n\nmapper::AbstractRetentionMapper: The fitted retention mapper.\n\nReturns\n\nThe unit of the input domain. Returns a Unitful.Units object for unitful mappers,  or Nothing for unitless mappers.\n\nSee also retentions_A, rawretentions_A, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> retentionunit_A(mapper)\nminute\n\njulia> inputs = [1.2, 2.5, 4.1, 6.8, 9.3]\n       outputs = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper_unitless = fitmap(inputs, outputs);\n\njulia> retentionunit_A(mapper_unitless) === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retention_mapper/#JuChrom.retentionunit_B","page":"Retention Mapper","title":"JuChrom.retentionunit_B","text":"retentionunit_B(mapper::AbstractRetentionMapper)\n\nReturn the unit associated with the output domain (domain B) of the retention mapper.\n\nFor unitful mappers, this returns the Unitful.Units object representing the unit  of the output values. For unitless mappers, this returns Nothing.\n\nArguments\n\nmapper::AbstractRetentionMapper: The fitted retention mapper.\n\nReturns\n\nThe unit of the output domain. Returns a Unitful.Units object for unitful mappers,  or Nothing for unitless mappers.\n\nSee also retentions_B, rawretentions_B, fitmap.\n\nExamples\n\njulia> retention_times = [1.2, 2.5, 4.1, 6.8, 9.3]u\"minute\"\n       retention_indices = [100.0, 200.0, 300.0, 400.0, 500.0]\n       mapper = fitmap(retention_times, retention_indices);\n\njulia> retentionunit_B(mapper) === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/transform/#Transform","page":"Transform","title":"Transform","text":"","category":"section"},{"location":"internals/transform/#JuChrom.binretentions-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Transform","title":"JuChrom.binretentions","text":"binretentions(retentions::AbstractVector{<:Number}, intensities::AbstractVector{<:Number}, \n    bin_edges::AbstractVector{<:Number}, variances::AbstractVector{<:Number};\n    zero_threshold::Number=1e-8, rho_lag1::Real=0.0, rho_max::Real=0.8)\n\nAggregate scan intensities into retention-coordinate bins via inverse-variance weighting.\n\nEach observation contributes to the bin covering its retention value (time or index), after clamping its variance to zero_threshold (with units promoted when needed). The weighted bin mean is Σ wᵢ yᵢ / Σ wᵢ with wᵢ = 1 / Varᵢ, and the reported variance is inflated by the lag-1 correlation factor controlled through rho_lag1 and rho_max. Inputs may be plain numbers or Unitful quantities. Retentions must share the same dimension as the bin edges, and unitful intensities require variances expressed in the corresponding squared intensity units (unitless intensities must use unitless variances).\n\nArguments\n\nretentions: Vector of retention coordinates for each observation.\nintensities: Vector of signal values aligned with retentions.\nbin_edges: Monotonic vector defining closed-open bin intervals [eᵢ, eᵢ₊₁).\nvariances: Vector of variance estimates for each intensity.\n\nKeyword Arguments\n\nzero_threshold: Minimum variance allowed after clamping (supports units).\nrho_lag1: Lag-1 residual correlation used to inflate bin variances.\nrho_max: Upper bound on the effective correlation (default 0.8).\n\nNotes\n\nNegative intensities are kept so residual or baseline-corrected signals can contribute to the weighted mean.\n\nReturns\n\n(centers, bin_means, bin_vars) — bin centers, weighted mean intensities, and inflated variance estimates.\n\nExamples\n\njulia> rets = collect(0.0:0.5:4.5);\n       ints = [10, 12, 9, 4, 6, 7, 3, 2, 1, 0];\n       edges = 0.0:1.0:5.0;\n       vars = fill(0.25, length(ints));\n\njulia> centers, means, varŝ = binretentions(rets, ints, edges, vars);\n\njulia> centers\n5-element Vector{Float64}:\n 0.5\n 1.5\n 2.5\n 3.5\n 4.5\n\njulia> means[1] ≈ (10 + 12) / 2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/transform/#JuChrom.densestgrid-Tuple{AbstractVector{<:AbstractVector{<:Real}}}","page":"Transform","title":"JuChrom.densestgrid","text":"densestgrid(datavectors; minwidth=nothing, maxwidth=nothing,\n            tolerance=1e-8,\n            coarse_inflation=1.001,\n            primary_refine_iters=35,\n            secondary_refine_iters=20,\n            max_anchors_basic=256,\n            max_anchors_enriched=1024)\n\nDetermine a near‑minimal bin width w and an associated regular grid edges such that every bin in the interval [global_min, global_max] contains at least one observation from each input dataset in datavectors.\n\nThree‑stage procedure:\n\nCoarse inflation: Starting from a rigorous lower bound lb, multiply the candidate width by coarse_inflation until a basic anchor (phase) yields full occupancy.\nPrimary refinement: Perform binary search between the last failing and first successful widths for primary_refine_iters iterations using the basic (limited) anchor set, narrowing the admissible interval for w.\nSecondary refinement: Apply an additional binary search of secondary_refine_iters iterations with an enriched anchor set to further reduce the upper bound on w.\n\nAnchor sets (cardinality is explicitly capped to bound runtime):\n\nBasic set: Residue 0 together with residues (global_min - x) % w drawn from early points of each dataset, up to max_anchors_basic, with ULP‑based de‑duplication.\nEnriched set: The basic set plus residues from terminal points and midpoints of the largest internal gaps (per dataset), up to max_anchors_enriched.\n\nReturns: (edges, w).\n\nArguments:\n\ndatavectors: Vector of non‑empty real-valued vectors (datasets).\nminwidth: Optional lower bound. If nothing, the minimal strictly positive internal gap over all datasets.\nmaxwidth: Optional upper bound. If nothing, the length of the common overlap global_max - global_min.\ntolerance: Numerical tolerance used only when deciding inclusion of the right boundary in the final bin.\ncoarse_inflation: Multiplicative growth factor (>1) in the coarse search.\nprimary_refine_iters: Number of binary refinement iterations with the basic anchor set.\nsecondary_refine_iters: Number of binary refinement iterations with the enriched anchor set.\nmax_anchors_basic: Maximum number of basic anchor candidates per width.\nmax_anchors_enriched: Maximum number of enriched anchor candidates per width.\n\nThrows:\n\nArgumentError if there is no non‑empty overlap, if any input dataset is empty, or if no width satisfying the occupancy criterion is found within maxwidth.\n\nNotes:\n\nBins are left‑closed, right‑open, except the final bin which includes the right edge (within tolerance).\nFor a width closer to the theoretical minimum, decrease coarse_inflation and/or increase the refinement iteration counts and anchor caps. This will increase computational cost in exchange for potentially smaller w.\n\n\n\n\n\n","category":"method"},{"location":"internals/transform/#JuChrom.densestgrid-Tuple{AbstractVector{<:AbstractVector{<:Unitful.AbstractQuantity}}}","page":"Transform","title":"JuChrom.densestgrid","text":"densestgrid(datavectors::AbstractVector{<:AbstractVector{<:Unitful.AbstractQuantity}};\n            minwidth=nothing,\n            maxwidth=nothing,\n            tolerance=nothing,\n            coarse_inflation=1.001,\n            primary_refine_iters=35,\n            secondary_refine_iters=20,\n            max_anchors_basic=256,\n            max_anchors_enriched=1024)\n\nUnit‑aware wrapper of the numeric densestgrid.\n\nComputes a near‑minimal bin width w and regular grid edges such that every bin contains at least one observation from each dataset (three‑stage procedure: coarse inflation, primary refinement, secondary refinement with enriched anchors).\n\nRequirements:\n\nAll elements of all inner vectors must be Unitful.Quantity with the same physical dimension (units themselves may differ).\nminwidth, maxwidth, tolerance when provided must be quantities of that dimension (nothing allowed).\nIf tolerance === nothing, it defaults to 1e-8 * ref_unit.\n\nKeyword arguments (forwarded to numeric core): coarse_inflation, primary_refine_iters, secondary_refine_iters, max_anchors_basic, max_anchors_enriched.\n\nReturns (edges, w) with the original unit attached.\n\n\n\n\n\n","category":"method"},{"location":"man/alignment/#Alignment","page":"Alignment","title":"Alignment","text":"","category":"section"},{"location":"man/alignment/#JuChrom.cosdis","page":"Alignment","title":"JuChrom.cosdis","text":"cosdis(x::AbstractVector{<:Real}, y::AbstractVector{<:Real}, \n       positive_only::Bool=true) -> Float64\n\nCompute the cosine distance between two real-valued vectors x and y.\n\nCosine distance is defined as:\n\n1 - cossim(x, y)\n\nArguments\n\nx, y: Vectors of real numbers.\npositive_only: If true (default), clamps result to the range [0, 1], assuming  non-negative inputs (e.g., intensity spectra). If false, the range is [0, 2] to  account for possible negative similarity.\n\nReturns\n\nA Float64 value representing the cosine distance.\nReturns NaN if either input vector is a zero vector.\n\nExamples\n\n```jldoctest julia> x = [1.0, 2.0, 3.0];\n\njulia> y = [4.0, 5.0, 6.0];\n\njulia> isapprox(cosdis(x, y), 0.025368153802923787; atol=1e-12) true\n\njulia> isapprox(cosdis(x, y, false), 0.025368153802923787; atol=1e-12) true ````\n\n\n\n\n\n","category":"function"},{"location":"man/alignment/#JuChrom.cossim","page":"Alignment","title":"JuChrom.cossim","text":"cossim(x::AbstractVector{<:Real}, y::AbstractVector{<:Real}, \n       positive_only::Bool=true) -> Float64\n\nCompute the cosine similarity between two real-valued vectors x and y.\n\nCosine similarity is defined as:\n\ndot(x, y) / (‖x‖ * ‖y‖)\n\nArguments\n\nx, y: Vectors of real numbers.\npositive_only: If true (default), clamps similarity to the range [0, 1], assuming  non-negative input vectors (e.g., intensity spectra).  If false, similarity may range  in [-1, 1].\n\nReturns\n\nA Float64 value representing the cosine similarity between x and y.\nReturns NaN if either vector is a zero vector (norm is zero).\n\nExamples\n\njulia> x = [1.0, 2.0, 3.0];\n\njulia> y = [4.0, 5.0, 6.0];\n\njulia> isapprox(cossim(x, y), 0.9746318461970762; atol=1e-12)\ntrue\n\njulia> isapprox(cossim(x, y, false), 0.9746318461970762; atol=1e-12)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/alignment/#JuChrom.gapalign","page":"Alignment","title":"JuChrom.gapalign","text":"gapalign(S::Matrix{<:Real}, γ::Real, τ::Real) -> (Dict{Int, Int}, Real)\n\nFind the optimal alignment between compounds and positions using dynamic programming  with gap penalties and similarity thresholds.\n\nThis function solves a constrained assignment problem where compounds can be matched to  positions based on similarity scores, with penalties for leaving items unmatched and  minimum thresholds for valid matches.\n\nAlgorithm\n\nUses dynamic programming to solve:\n\nObjective: Maximize total similarity score minus gap penalties\nConstraints: Only allow matches where similarity ≥ τ\nComplexity: O(mn) time and space\n\nArguments\n\nS::Matrix{<:Real}: An m × n similarity matrix where S[i,j] represents the  similarity between compound i and position j. Higher values indicate better matches.\nγ::Real: Gap penalty (≥ 0) subtracted for each unmatched compound or position.  Higher values encourage more matches.\nτ::Real: Minimum similarity threshold for valid matches. Matches with S[i,j] < τ  are forbidden.\n\nReturns\n\nassignment::Dict{Int, Int}: Optimal compound-to-position mapping (1-indexed).  Keys are compound indices, values are position indices. Unmatched compounds are  not included.\nscore::Real: Total alignment score = Σ(matched similarities) - γ × (unmatched items)\n\nExamples\n\njulia> S = [0.9 0.1; 0.2 0.8];  # Simple 2×2 case: perfect matches\n\njulia> assignment, score = gapalign(S, 0.1, 0.5);\n\njulia> assignment == Dict(1 => 1, 2 => 2)\ntrue\n\njulia> score ≈ 1.7  # 0.9 + 0.8 - 2*0.1 (no gaps)\ntrue\n\njulia> S = [0.9 0.1; 0.1 0.2];  # Poor second match\n\njulia> assignment, score = gapalign(S, 0.3, 0.5); # With gap penalty: prefer partial matching\n\njulia> assignment == Dict(1 => 1)  # Skip compound 2\ntrue\n\njulia> score ≈ 0.3  # 0.9 - 0.3 (skip compound 2) - 0.3 (skip position 2)\ntrue\n\njulia> S = [0.9 0.3; 0.2 0.8];  # Threshold filtering: block poor matches\n\njulia> assignment, score = gapalign(S, 0.1, 0.4);  # τ=0.4 blocks S[1,2] and S[2,1]\n\njulia> assignment == Dict(1 => 1, 2 => 2)  # Perfect matches\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/loaders/#Loaders","page":"Loaders","title":"Loaders","text":"Shimadzu loaders are available when PyCall is installed and loaded (extension).\n\nusing JuChrom\nusing Markdown\nif isdefined(JuChrom, :ShimadzuMSLoader)\n    bt = Char(96)\n    docs_block = string(\n        bt, bt, bt, \"@docs\\n\",\n        \"JuChrom.ShimadzuMSLoader.ShimadzuMSLoaderSpec\\n\",\n        \"JuChrom.ShimadzuMSLoader.ShimadzuMS\\n\",\n        bt, bt, bt\n    )\n    Markdown.parse(docs_block)\nend","category":"section"},{"location":"man/loaders/#JuChrom.AgilentFIDLoader.AgilentFIDLoaderSpec","page":"Loaders","title":"JuChrom.AgilentFIDLoader.AgilentFIDLoaderSpec","text":"AgilentFIDLoaderSpec{F}(path::String)\n\nInternal structure representing a configured load request for Agilent FID data. This type encapsulates:\n\nthe source path, and\na type tag for format versioning.\n\nNormally, this is constructed indirectly via AgilentFID(...).\n\n\n\n\n\n","category":"type"},{"location":"man/loaders/#JuChrom.AgilentFIDLoader.AgilentFID","page":"Loaders","title":"JuChrom.AgilentFIDLoader.AgilentFID","text":"AgilentFID(path::String) -> AgilentFIDLoaderSpec\n\nConstruct a loader specification for Agilent FID data. The path can be either a directory (containing FID1A.ch) or a direct path to the file. \n\nReturns a AgilentFIDLoaderSpec object used for deferred data loading via load(...).\n\n\n\n\n\n","category":"function"},{"location":"man/loaders/#JuChrom.ChemStationMSLoader.ChemStationMS","page":"Loaders","title":"JuChrom.ChemStationMSLoader.ChemStationMS","text":"ChemStationMS(path::String; mode::Symbol=:ms) -> ChemStationMSLoaderSpec\n\nConstruct a loader specification for Agilent ChemStation GC/MS data. The path can be either a directory (containing data.ms) or a direct path to the file. \n\nThe keyword argument mode determines the type of data to load:\n\n:ms  → full mass spectral data (default)\n:tic → total ion chromatogram only\n\nReturns a ChemStationMSLoaderSpec object used for deferred data loading via load(...).\n\n\n\n\n\n","category":"function"},{"location":"man/loaders/#JuChrom.ChemStationMSLoader.ChemStationMSLoaderSpec","page":"Loaders","title":"JuChrom.ChemStationMSLoader.ChemStationMSLoaderSpec","text":"ChemStationMSLoaderSpec{F}(path::String; mode::Symbol=:ms)\n\nInternal structure representing a configured load request for ChemStation MS data. This type encapsulates:\n\nthe source path,\nselected mode (:ms or :tic), and\na type tag for format versioning.\n\nNormally, this is constructed indirectly via ChemStationMS(...).\n\n\n\n\n\n","category":"type"},{"location":"man/loaders/#FileIO.load","page":"Loaders","title":"FileIO.load","text":"load(req::MassHunterMSLoaderSpec{MassHunterMSv1}) -> AbstractScanSeries\n\nLoads and parses mass spectrometry data from Agilent MassHunter (version 1) GC/MS files. Takes a MassHunterMSLoaderSpec created via MassHunterMS(...).\n\nReturns a AbstractScanSeries subtype object containing either:\n\na vector of MassScan objects (for mode=:ms), or\na vector of ChromScan objects (for mode=:tic),\n\nalong with parsed metadata (sample, user, acquisition, instrument).\n\n\n\n\n\nload(req::ChemStationMSLoaderSpec{ChemStationMSv2}) -> AbstractScanSeries\n\nLoads and parses mass spectrometry data from Agilent ChemStation (version 2) GC/MS files. Takes a ChemStationMSLoaderSpec created via ChemStationMS(...).\n\nReturns a AbstractScanSeries subtype object containing either:\n\na vector of MassScan objects (for mode=:ms), or\na vector of ChromScan objects (for mode=:tic),\n\nalong with parsed metadata (sample, user, acquisition, instrument).\n\n\n\n\n\n","category":"function"},{"location":"man/loaders/#JuChrom.MassHunterMSLoader.MassHunterMSLoaderSpec","page":"Loaders","title":"JuChrom.MassHunterMSLoader.MassHunterMSLoaderSpec","text":"MassHunterMSLoaderSpec{F}(path::String; mode::Symbol=:ms)\n\nInternal structure representing a configured load request for Agilent MassHunter MS data. This type encapsulates:\n\nthe source path,\nselected mode (:ms or :tic), and\na type tag for format versioning.\n\nNormally, this is constructed indirectly via MassHunterMS(...).\n\n\n\n\n\n","category":"type"},{"location":"man/loaders/#JuChrom.MassHunterMSLoader.MassHunterMS","page":"Loaders","title":"JuChrom.MassHunterMSLoader.MassHunterMS","text":"MassHunterMS(path::String; mode::Symbol=:ms) -> MassHunterMSLoaderSpec\n\nConstruct a loader specification for Agilent MassHunter GC/MS data. The path can be either a directory (containing data.ms) or a direct path to the file. \n\nThe keyword argument mode determines the type of data to load:\n\n:ms  → full mass spectral data (default)\n:tic → total ion chromatogram only\n\nReturns a MassHunterMSLoaderSpec object used for deferred data loading via load(...).\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"internals/utils/#JuChrom.consistentunits","page":"Utilities","title":"JuChrom.consistentunits","text":"consistentunits(vals::AbstractArray{<:Union{Real, AbstractQuantity{<:Real}}}) -> Bool\n\nCheck whether all elements in vals have consistent Unitful units.\n\nThis function determines if an array contains only plain numbers, or only quantities with  the same unit. Mixed arrays of numbers and quantities, or arrays of quantities with  differing units, are considered inconsistent.\n\nArguments\n\nvals: An array of values, which may be Unitful.AbstractQuantity or plain numbers.\n\nReturn\n\nBool: true if\nvals is empty (trivially consistent),\nall elements are plain numbers (no units), or\nall elements are quantities with the same unit.\nReturns false if\nthere is a mixture of quantities and plain numbers, or\nquantities have different units.\n\nSee also: strip_units_checked\n\nExamples\n\njulia> JuChrom.consistentunits(Int64[])\ntrue\n\njulia> JuChrom.consistentunits([1.0, 2.0, 3.0])\ntrue\n\njulia> JuChrom.consistentunits([1, 2, 3]u\"s\")\ntrue\n\njulia> ret = [1u\"s\", 2u\"minute\", 3u\"s\"];\n\njulia> ret ≈ [1, 120, 3]u\"s\"\ntrue\n\njulia> JuChrom.consistentunits(ret)\ntrue\n\njulia> JuChrom.consistentunits([1u\"m\", 2.0u\"minute\", 3.0u\"kg\"])\nfalse\n\njulia> JuChrom.consistentunits([1u\"s\", 2.0, 3.0])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.copy_with","page":"Utilities","title":"JuChrom.copy_with","text":"copy_with(obj, overrides::NamedTuple) -> typeof(obj)\n\nCreate a deep copy of obj, replacing specified fields with new values.\n\nThis function returns a new object of the same type as obj, with selected fields  replaced by values provided in the overrides named tuple. All other fields are  deep-copied from the original object. The function assumes that all overridden values  are type-compatible with the corresponding fields.\n\nThis function does not infer new field types and expects all overrides to match the  original field types.\n\nArguments\n\nobj: The original object to copy.\noverrides: A NamedTuple of field-value pairs to override in obj.\n\nReturn\n\nA new object of the same type as obj, with specified fields updated.\n\nExample\n\njulia> struct MyStruct\n         x::Int\n         y::String\n       end\n\njulia> obj = MyStruct(1, \"a\")\nMyStruct(1, \"a\")\n\njulia> JuChrom.copy_with(obj, (y = \"b\",))\nMyStruct(1, \"b\")\n\njulia> JuChrom.copy_with(obj, (x = 42, y = \"hello\",))\nMyStruct(42, \"hello\")\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.inverse","page":"Utilities","title":"JuChrom.inverse","text":"inverse(u::Unitful.Units) -> Unitful.Units\n\nReturn the reciprocal (multiplicative inverse) of the given unit.\n\nThis function computes the inverse of a unit, returning a new unit representing 1/u.  This is useful for expressing rates or reciprocals of physical quantities (e.g. from  meters to 1/meter).\n\nArguments\n\nu: A unit from Unitful.\n\nReturn\n\nUnitful.Units: The inverse unit, such as 1/u.\n\nExample\n\njulia> JuChrom.inverse(u\"m\")\nm^-1\njulia> JuChrom.inverse(u\"kg\")\nkg^-1\njulia> JuChrom.inverse(u\"s\")\ns^-1\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.inverse_minmax_scale","page":"Utilities","title":"JuChrom.inverse_minmax_scale","text":"inverse_minmax_scale(v_norm::Real, v_min::Real, v_max::Real) -> Real\n\nConvert a min-max normalized value back to its original scale.\n\nThis function performs the inverse of min-max normalization, mapping a normalized value v_norm ∈ [0, 1] back to its original scale using the provided minimum (v_min) and maximum (v_max) values.\n\nArguments\n\nv_norm: The normalized value (typically in the range [0, 1]).\nv_min: The minimum value of the original scale.\nv_max: The maximum value of the original scale.\n\nReturn\n\nThe corresponding value on the original scale as a Real.\n\nSee also: minmax_scale\n\nExample\n\njulia> JuChrom.inverse_minmax_scale(0.5, 10, 20)\n15.0\njulia> JuChrom.inverse_minmax_scale(0.0, 5, 15)\n5.0\njulia> JuChrom.inverse_minmax_scale(1.0, 5, 15)\n15.0\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.isunitful","page":"Utilities","title":"JuChrom.isunitful","text":"isunitful(x) -> Bool\n\nReturn true if x is a Unitful.AbstractQuantity, regardless of whether it carries nontrivial units. This is a light-weight check used to branch between unitful and unitless code paths; values with Unitful.NoUnits still return true because they are wrapped quantities.\n\nArguments\n\nx: Any value that may or may not be a Unitful quantity.\n\nReturn\n\nBool: true for Unitful quantities, false otherwise.\n\nExample\n\njulia> JuChrom.isunitful(1.0u\"s\")\ntrue\n\njulia> JuChrom.isunitful(2.0)\nfalse\n\njulia> JuChrom.isunitful(ustrip(1.0u\"s\"))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.localmaxima","page":"Utilities","title":"JuChrom.localmaxima","text":"localmaxima(values::AbstractVector{<:Real}) -> Vector{Int}\n\nReturn the indices of local maxima in a vector or 1D array of real numbers.\n\nA local maximum is defined as an element that is strictly greater than its immediate  neighbors. Only strictly greater maxima are detected; plateaus or flat maxima are not  identified.\n\nArguments\n\nvalues: A one-dimensional vector or array of real numbers.\n\nReturn\n\nA vector of integer indices corresponding to positions in values where local maxima  occur.\n\nNotes\n\nAt least three elements are required in values to detect maxima.\nWorks with arrays having arbitrary indexing (e.g., OffsetArrays).\nOnly strictly greater maxima are detected; flat or plateau maxima are ignored.\n\nExample\n\njulia> vals = [1, 3, 2, 4, 5, 1];\n\njulia> JuChrom.localmaxima(vals) == [2, 5]\ntrue\n\njulia> JuChrom.localmaxima([1, 2, 3]) == []\ntrue\n\njulia> JuChrom.localmaxima([1, 5, 1]) == [2]\ntrue\n\njulia> JuChrom.localmaxima([1, 2, 2, 1]) == []\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.maxdecimals","page":"Utilities","title":"JuChrom.maxdecimals","text":"maxdecimals(vec::AbstractVector{<:Real}) -> Int\n\nReturn the maximum number of decimal places present in any element of the input vector.\n\nThis function examines each element of vec, converts it to a string, and counts the  number of digits after the decimal point (ignoring trailing zeros). It returns the largest  such count found among all elements. If the vector is empty or contains only integers,  returns 0.\n\nArguments\n\nvec: A vector of real numbers to analyze.\n\nReturn\n\nInt: The maximum number of decimal digits present in any element of vec.\n\nExample\n\njulia> JuChrom.maxdecimals([1.23, 4.567, 8.9])\n3\njulia> JuChrom.maxdecimals([1.0, 2.0, 3.0])\n0\njulia> JuChrom.maxdecimals(Int[])\n0\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.minmax_scale","page":"Utilities","title":"JuChrom.minmax_scale","text":"minmax_scale(v::Real, v_min::Real, v_max::Real) -> Real\n\nScale a value to the [0, 1] range using min-max normalization.\n\nThis function applies min-max normalization to a scalar value v, mapping it to the  range [0, 1] based on the provided minimum (v_min) and maximum (v_max) values of the  original scale.\n\nArguments\n\nv: The value to normalize.\nv_min: The minimum value of the original scale.\nv_max: The maximum value of the original scale.\n\nReturn\n\nThe normalized value in the range [0, 1] as a Real.\n\nSee also: inverse_minmax_scale\n\nExample\n\njulia> JuChrom.minmax_scale(15, 10, 20)\n0.5\njulia> JuChrom.minmax_scale(5, 5, 15)\n0.0\njulia> JuChrom.minmax_scale(15, 5, 15)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.strip_units_checked","page":"Utilities","title":"JuChrom.strip_units_checked","text":"strip_units_checked(arr::AbstractArray, name::String) -> Tuple{AbstractArray, Union{Unitful.Units, Nothing}}\n\nStrip units from an array, returning both the unitless values and the associated unit.\n\nThis function checks that all elements of arr have consistent units (if any), strips the  units if present, and returns a tuple (values, unit). If the array is empty, it returns  the array and nothing. If the array contains quantities with inconsistent units, an  ArgumentError is thrown. If the array contains only numbers (no units), the original  array and nothing are returned.\n\nArguments\n\narr: An array of numbers or Unitful.AbstractQuantity values.\nname: A string used for error messages to identify the data source.\n\nReturn\n\nA tuple (values, unit), where values is an array of numbers (units stripped if  present), and unit is the associated Unitful.Units object or nothing if not  applicable.\n\nThrows\n\nArgumentError if the array contains quantities with inconsistent units.\n\nSee also: consistentunits\n\nExamples\n\njulia> JuChrom.stripunitschecked([1, 2]u\"s\", \"times\") ([1, 2], s)\n\njulia> JuChrom.stripunitschecked([1.0, 2.0], \"values\") ([1.0, 2.0], nothing)\n\njulia> JuChrom.stripunitschecked([], \"empty\") (Any[], nothing)\n\njulia> JuChrom.stripunitschecked([1u\"s\", 2u\"m\"], \"mixed\") ERROR: ArgumentError: Inconsistent units in mixed. [...]\n\n\n\n\n\n","category":"function"},{"location":"internals/utils/#JuChrom.typify","page":"Utilities","title":"JuChrom.typify","text":"typify(collection) -> new_collection\n\nPromotes and converts the elements of a dictionary or vector to a common type.\n\nFor a dictionary, typify(dict::Dict) inspects the types of the values, computes their common promoted type T using promote_type, and returns a new Dict{K, T} with each value converted via convert(T, v).\n\nFor a vector, typify(vec::AbstractVector) promotes the element types to a common type T and returns a Vector{T} with all elements converted.\n\nIf the promoted type T is not concrete (e.g., a union or abstract type), a warning is emitted, as this may lead to type instability.\n\nArguments\n\ndict::Dict: A dictionary with arbitrary value types.\nvec::AbstractVector: A vector with potentially mixed element types.\n\nReturns\n\nA new container of the same kind (Dict or Vector) with unified and converted element types.\n\nThrows\n\nA MethodError if any element cannot be converted to the promoted type T.\n\nExamples\n\n```julia d = Dict(\"a\" => 1, \"b\" => 2.5) typify(d)\n\n=> Dict{String, Float64}\n\nv = [1, 2.5, 3] typify(v)\n\n=> Vector{Float64}\n\nv = [1, \"x\"] typify(v)\n\n=> Vector{Union{Int, String}}, with warning\n\n\n\n\n\n","category":"function"},{"location":"man/baseline/#Baseline","page":"Baseline","title":"Baseline","text":"","category":"section"},{"location":"man/baseline/#JuChrom.airpls","page":"Baseline","title":"JuChrom.airpls","text":"airpls(retentions::AbstractVector{<:Real}, intensities::AbstractVector{<:Real};          λ::Real=1e7, max_iter::Integer=10^4, ...) -> Vector{Float64}\n\nEstimate a smooth baseline from spectroscopic/chromatographic data using Adaptive Iteratively Reweighted Penalized Least Squares (airPLS).\n\nUses asymmetric weighting to suppress peaks while preserving baseline trend. Enhanced with weight propagation across peak shoulders - when peak regions are detected, their low weights are extended to neighboring points following the peak slope, improving baseline estimation for broad or overlapping peaks.\n\nArguments\n\nretentions::AbstractVector{<:Real}: Independent variable (e.g., retention times,  retention indices)\nintensities::AbstractVector{<:Real}: Signal data containing baseline + peaks\nλ::Real=1e7: Smoothing parameter (higher -> smoother baseline)\nvariances::AbstractVector{<:Real}=nothing: Optional measurement uncertainties for each  intensity value\nimprovement_threshold::Real=1e-6: Minimum improvement to continue optimization\nmax_iter::Integer=10^4: Maximum iterations\nno_improvement_limit::Integer=10: Stop after this many non-improving iterations\nthreshold_factor::Real=1.96: Peak detection sensitivity (higher = less sensitive).  A factor of 1.282 corresponds to 90% coverage of the one-sided noise distribution.\nzero_threshold::Real=1e-8: Threshold for zero-valued points\nzero_weight::Real=0.01: Weight factor for zero-threshold points\n\nAlgorithm\n\nIteratively solves penalized least squares with asymmetric weights\nDown-weights positive residuals (above baseline) more than negative ones\nPropagates low weights across peak shoulders using slope analysis\nTracks optimization progress and returns best solution found\n\nReturns estimated baseline vector with same length as input intensities.\n\nReferences\n\nZhang ZM, Chen S, Liang YZ (2010): Baseline correction using adaptive\n\niteratively reweighted penalized least squares. – Analyst 135: 1138-1146.\n\nExample\n\n```julia\n\nBasic usage\n\nbaseline = airpls(wavelengths, spectrum; λ=1e6)\n\nWith measurement uncertainties\n\nbaseline = airpls(times, signal; variances=errors.^2, λ=1e5)\n\nSensitive peak detection\n\nbaseline = airpls(x, y; thresholdfactor=2.0, noimprovement_limit=15)\n\n\n\n\n\nairpls(msm::MassScanMatrix; ...) -> MassScanMatrix\n\nEstimate baseline from mass scan matrix data using airPLS algorithm. The method assumes the retrieved intensity counts represent raw Poisson shot-noise data with identical variance. Do not apply this method to data whose counts have been transformed (e.g., by applying a retention mapper). Use instead the method airpls(msm::MassScanMatrix, variances::AbstractMatrix{<:Real}; ...).\n\nConvenience method that extracts retention times and intensities of each mz channel from the MassScanMatrix, applies baseline correction, and returns the identified baselines as a MassScanMatrix object.\n\nArguments\n\nmsm::MassScanMatrix: Mass scan matrix object with retention and intensity values\n\nSee airpls(retentions, intensities; ...) for algorithm details and full parameter documentation.\n\nExample\n\ncorrected_msm = airpls(msm; λ=1e6, threshold_factor=2.0)\n\n\n\n\n\nairpls(msm::MassScanMatrix, variances::AbstractMatrix{<:Real}; ...) -> MassScanMatrix\n\nEstimate baseline from mass scan matrix data using airPLS algorithm. The method weights the  PLS regression by the inverse of the variances.\n\nConvenience method that extracts retention times and intensities of each mz channel from the MassScanMatrix, applies baseline correction, and returns the identified baselines as a MassScanMatrix object.\n\nArguments\n\nmsm::MassScanMatrix::MassScanMatrix: Mass scan matrix object with retention and  intensity values\nvariances::AbstractMatrix{<:Real}: Variance matrix with dimensions (nscans, nmzs) containing the variances for each intensity value\n\nSee airpls(retentions, intensities; ...) for algorithm details and full parameter documentation.\n\nExample\n\ncorrected_msm = airpls(msm, vars; λ=1e6, threshold_factor=2.0)\n\n\n\n\n\n","category":"function"},{"location":"man/Scans/#Scans","page":"Scans","title":"Scans","text":"","category":"section"},{"location":"man/Scans/#JuChrom.AbstractScan","page":"Scans","title":"JuChrom.AbstractScan","text":"AbstractScan{R, I}\n\nAbstract supertype for all scan objects, such as individual chromatographic or mass spectrometric scan points.\n\nType Parameters\n\nR: Type of the separation unit (i.e. Unitful.Units subtype or Nothing)\nI: Type of the signal intensity unit (i.e. Unitful.Units subtype or Nothing)\n\nRequired Fields for Subtypes\n\nConcrete subtypes must define the following fields:\n\nretention::Real — separation coordinate (e.g. time, index, or position), stored without  units\nretention_unit::Union{Unitful.Units, Nothing} — unit of the separation axis, or  nothing if not provided\nintensity_unit::Union{Unitful.Units, Nothing} — unit of the signal intensity, or  nothing if not provided\nattrs::NamedTuple — additional scan-level attrs\n\nNote: This abstract type does not enforce a specific field name or structure for the  intensity data. Subtypes may define fields like intensity, intensities, or others, and  the intensity may be a scalar, a vector, a matrix, or any other form.\n\nThe type parameter I only indicates the unit of the intensity data, not its structure or  where it is stored. Subtypes are responsible for documenting how to access their intensity  values.\n\n\n\n\n\n","category":"type"},{"location":"man/Scans/#JuChrom.AbstractChromScan","page":"Scans","title":"JuChrom.AbstractChromScan","text":"AbstractChromScan{R, I} <: AbstractScan{R, I}\n\nAbstract supertype for individual chromatographic scan points.\n\nType Parameters\n\nR: Type of the separation unit (i.e. Unitful.Units subtype or Nothing)\nI: Type of the signal intensity unit (i.e. Unitful.Units subtype or Nothing)\n\nRequired Fields for Subtypes\n\nConcrete subtypes must define the following fields:\n\nretention::Real — separation coordinate (e.g. time, index, position), stored without  units\nretention_unit::Union{Unitful.Units, Nothing} — unit of retention, or nothing if not  provided\nintensity::Real — signal intensity value, stored without units\nintensity_unit::Union{Unitful.Units, Nothing} — unit of intensity, or nothing if not  provided\nattrs::NamedTuple — additional scan-level attrs\n\nSubtypes may define additional fields as necessary.\n\n\n\n\n\n","category":"type"},{"location":"man/Scans/#JuChrom.ChromScan","page":"Scans","title":"JuChrom.ChromScan","text":"ChromScan(retention::Union{Real, AbstractQuantity{<:Real}},\n          intensity::Union{Real, AbstractQuantity{<:Real}};\n          attrs::NamedTuple = NamedTuple())\n\nConstruct a ChromScan object representing a single chromatographic scan point acquired at a given value along the separation axis (e.g. retention time, index, or position).\n\nBoth retention and intensity may be given as plain numbers or Unitful.AbstractQuantity  values. If units are provided, they are stripped from the values and stored separately in  the retention_unit and intensity_unit fields. If no unit is provided, nothing is  stored.\n\nArguments\n\nretention: Separation coordinate (e.g. 2u\"s\" or 5000)\nintensity: Signal intensity (e.g. 1000 or 10u\"pA\")\nattrs: Optional scan-level attrs as a NamedTuple (default: empty)\n\nReturns\n\nA ChromScan instance where numeric values and their units are stored separately.\n\nThrows\n\nArgumentError if retention or intensity is not finite\n\nSee also AbstractChromScan, AbstractScan, retention,  rawretention, retentionunit, intensity,  rawintensity, intensityunit, attrs.\n\nExamples\n\njulia> using Unitful\n\njulia> csc = ChromScan(5u\"minute\", 1000u\"pA\");\n\njulia> retention(csc)\n5 minute\n\njulia> rawretention(csc)\n5\n\njulia> intensity(csc)\n1000 pA\n\njulia> rawintensity(csc)\n1000\n\njulia> attrs(csc)\nNamedTuple()\n\njulia> csc2 = ChromScan(5000, 100, attrs=(scan_id=1,));\n\njulia> attrs(csc2)\n(scan_id = 1,)\n\n\n\n\n\nChromScan(retention::Real, retention_unit::Union{Unitful.Units, Nothing},\n          intensity::Real, intensity_unit::Union{Unitful.Units, Nothing};\n          attrs::NamedTuple = NamedTuple())\n\nConstruct a ChromScan object by explicitly providing the unit-stripped numeric values and their associated units.\n\nThis constructor bypasses automatic unit inference. It is intended for advanced use cases such as programmatic data loading, conversion, or optimization, where unit parsing has already been performed externally.\n\nArguments\n\nretention: Numeric value representing the separation coordinate\nretention_unit: Unit of retention (Unitful.Units subtype) or nothing\nintensity: Numeric intensity value\nintensity_unit: Unit of intensity (Unitful.Units subtype) or nothing\nattrs: Optional scan-level attrs (NamedTuple, default: empty)\n\nThrows\n\nArgumentError if retention or intensity is not finite\n\nNote\n\nNo unit consistency checks are performed in this constructor. It assumes all values are  prevalidated.\n\n\n\n\n\n","category":"type"},{"location":"man/Scans/#JuChrom.AbstractMassScan","page":"Scans","title":"JuChrom.AbstractMassScan","text":"AbstractMassScan{R, M, I} <: AbstractScan{R, I}\n\nAbstract supertype for individual mass spectrometric scan points.\n\nType Parameters\n\nR: Type of the separation unit (i.e. Unitful.Units subtype or Nothing)\nM: Type of the m/z value unit (i.e. Unitful.Units subtype or Nothing)\nI: Type of the signal intensity unit (i.e. Unitful.Units subtype or Nothing)\n\nRequired Fields for Subtypes\n\nConcrete subtypes must define the following fields:\n\nretention::Real — separation coordinate (e.g. time, index, position), stored without  units\nretention_unit::Union{Unitful.Units, Nothing} — unit of separation, or nothing if not  provided\nmz_values::AbstractVector{<:Real} — vector of m/z values (must be non-empty, finite, \n0, strictly increasing)\nmz_unit::Union{Unitful.Units, Nothing} — optional unit of m/z values (e.g. Da/e);  typically nothing since m/z is unitless by convention\nintensities::AbstractVector{<:Real} — vector of intensity values (same length as  mz_values, all finite)\nintensity_unit::Union{Unitful.Units, Nothing} — unit of intensity, or nothing if not  provided\nlevel::Integer — MS level (must be ≥ 1)\nattrs::NamedTuple — additional scan-level attrs\n\nSubtypes may define additional fields as necessary.\n\n\n\n\n\n","category":"type"},{"location":"man/Scans/#JuChrom.MassScan","page":"Scans","title":"JuChrom.MassScan","text":"MassScan(\n    retention::Union{Real, AbstractQuantity{<:Real}},\n    mz_values::AbstractVector{<:Union{Real, AbstractQuantity{<:Real}}},\n    intensities::AbstractVector{<:Union{Real, AbstractQuantity{<:Real}}};\n    level::Integer = 1,\n    attrs::NamedTuple = NamedTuple()\n)\n\nConstruct a MassScan object representing a single scan acquired at a specific point along the separation axis (e.g. time, index, or physical position).\n\nAll three arguments — retention, mz_values, and intensities — may be provided as plain numbers or Unitful.AbstractQuantity values. If units are present, they are stripped  from the values and stored separately. Each of mz_values and intensities must be either  entirely unitless or share a consistent unit within their respective vectors.\n\nArguments\n\nretention: Separation coordinate (e.g. 2.0u\"s\" or 5000)\nmz_values: Vector of mass-to-charge (m/z) values; must be non-empty, finite, strictly  increasing, and > 0\nintensities: Vector of signal intensities (same length as mz_values, all finite)\nlevel: MS level (default: 1; must be ≥ 1)\nattrs: Optional scan-level attrs as a NamedTuple\n\nReturns\n\nA MassScan instance where numeric values and their units (if present) are stored  separately.\n\nThrows\n\nArgumentError if:\nretention is not finite\nmz_values is empty, contains non-positive or non-finite values, or is not strictly  increasing\nmz_values mix unitful and unitless values\nmz_values have inconsistent units\nintensities is empty\nintensities contain non-finite values\nintensities mix unitful and unitless values\nintensities have inconsistent units\nlevel is less than 1\nDimensionMismatch if length(mz_values) ≠ length(intensities)\n\nSee also AbstractMassScan, AbstractScan, retention,  rawretention, retentionunit, mzvalues, rawmzvalues,  mzcount, mzunit intensities, rawintensities,  intensityunit, level, attrs.\n\nExamples\n\njulia> msc = MassScan(2.0u\"s\", [100.0, 150.0], [1000, 2000]);\n\njulia> retention(msc)\n2.0 s\n\njulia> msc.mz_values == [100.0, 150.0]\ntrue\n\njulia> intensities(msc) == [1000, 2000]\ntrue\n\njulia> attrs(msc)\nNamedTuple()\n\njulia> msc2 = MassScan(3.0u\"s\", [120.0, 160.0], [600, 1100], attrs=(scan_id=42,));\n\njulia> attrs(msc2)\n(scan_id = 42,)\n\n\n\n\n\nMassScan(retention::Real, retention_unit::Union{Unitful.Units, Nothing},\n         mz_values::AbstractVector{<:Real},\n         mz_unit::Union{Unitful.Units, Nothing},\n         intensities::AbstractVector{<:Real},\n         intensity_unit::Union{Unitful.Units, Nothing};\n         level::Integer = 1,\n         attrs::NamedTuple = NamedTuple())\n\nConstruct a MassScan object from pre-parsed and unit-stripped values. This constructor is intended for advanced use cases where unit inference and validation are handled externally (e.g. during deserialization or optimized data loading).\n\nArguments\n\nretention: Numeric retention value (unit-stripped)\nretention_unit: Unit of retention (or nothing)\nmz_values: Vector of m/z values (must be validated externally)\nmz_unit: Unit of m/z values (or nothing)\nintensities: Vector of numeric intensity values (unit-stripped)\nintensity_unit: Unit of intensity (or nothing)\nlevel: MS level (default: 1)\nattrs: Optional attrs (NamedTuple)\n\nThrows\n\nArgumentError or DimensionMismatch if values are invalid (see inner constructor)\n\nNote\n\nThis constructor performs no unit consistency checks. Use only when values have already been validated.\n\n\n\n\n\n","category":"type"},{"location":"man/Scans/#JuChrom.attrs-Tuple{AbstractScan}","page":"Scans","title":"JuChrom.attrs","text":"attrs(scan::AbstractScan)\n\nReturn the scan-level attrs associated with the given scan object.\n\nThe attrs is stored as a NamedTuple and may contain additional contextual or  acquisition-specific information beyond the primary measurement fields (e.g., scan ID,  instrument settings, annotations).\n\nArguments\n\nscan: A subtype of AbstractScan\n\nReturns\n\nA NamedTuple containing the attrs fields defined for the scan.\n\nSee also AbstractScan, AbstractChromScan, AbstractMassScan.\n\nExamples\n\njulia> csc = ChromScan(5.0, 1200.0, attrs=(scan_id=42, comment=\"baseline\"));\n\njulia> attrs(csc)\n(scan_id = 42, comment = \"baseline\")\n\njulia> attrs(csc).scan_id\n42\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.intensity-Tuple{AbstractChromScan{<:Any, Nothing}}","page":"Scans","title":"JuChrom.intensity","text":"intensity(scan::AbstractChromScan; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the intensity value of a chromatographic scan, optionally as a Unitful.Quantity.\n\nIf the scan’s intensity_unit is not nothing, the intensity is returned as a quantity  in that unit. If a unit is specified, the value is converted using uconvert.\n\nIf intensity_unit is nothing:\n\nand a unit is provided, an error is thrown\nand no unit is provided, the raw numeric value is returned unchanged\n\nThis function does not assign units to raw values — it only performs conversions when a  unit is already stored.\n\nArguments\n\nscan: A subtype of AbstractChromScan\nunit: (Optional) target unit (e.g. u\"pA\") — used only if a unit is stored\n\nReturns\n\nA Quantity in the scan’s stored or requested unit, if applicable\nA plain Real value if no unit is stored and no unit is requested\n\nThrows\n\nArgumentError if unit is specified for a scan with no stored intensity_unit\n\nSee also AbstractChromScan, AbstractScan, rawintensity,  intensityunit.\n\nExamples\n\njulia> csc = ChromScan(3.0u\"minute\", 100u\"pA\");\n\njulia> intensity(csc)\n100 pA\n\njulia> intensity(csc; unit=u\"fA\")\n100000 fA\n\njulia> csc2 = ChromScan(5000, 100);  # intensity_unit == nothing\n\njulia> intensity(csc2)\n100\n\njulia> intensity(csc2; unit=u\"pA\")\nERROR: ArgumentError: Cannot convert unitless intensity to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.intensityunit-Tuple{AbstractScan}","page":"Scans","title":"JuChrom.intensityunit","text":"intensityunit(scan::AbstractScan) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the intensity value(s) of a scan.\n\nThis function retrieves the intensity_unit field from any scan subtype, which indicates  the physical unit used for the signal intensity or intensities (e.g. u\"pA\", u\"counts\").  If no unit was specified at construction, returns nothing.\n\nArguments\n\nscan: A subtype of AbstractScan, such as ChromScan or MassScan\n\nReturns\n\nA Unitful.Units subtype representing the intensity unit, or nothing if unspecified\n\nSee also AbstractScan, AbstractChromScan, AbstractMassScan,  intensity, rawintensity, intensities,  rawintensities.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]u\"pA\");\n\njulia> intensityunit(msc)\npA\n\njulia> csc = ChromScan(1.0u\"minute\", 42.0);\n\njulia> intensityunit(csc) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.intensities-Tuple{AbstractMassScan{<:Any, <:Any, Nothing}}","page":"Scans","title":"JuChrom.intensities","text":"intensities(scan::AbstractMassScan; unit=nothing)\n\nReturn the intensity values from a mass spectrometric scan.\n\nThis method supports both unitless and unitful scans. If unit is specified, the  intensities are converted to the desired unit using Unitful.uconvert. If the scan is  unitless and a unit is requested, an error is thrown.\n\nArguments\n\nscan: A subtype of AbstractMassScan\nunit: Desired unit to convert intensities into (Unitful.Units subtype or nothing,  default)\n\nReturns\n\nA vector of intensity values. If a unit is provided, the values are returned in that unit.\n\nThrows\n\nArgumentError if:\nThe scan has no intensity unit and a unit conversion is requested.\nAssertionError if:\nThe scan claims to have a unit but intensity_unit is nothing (internal  inconsistency)\n\nSee also AbstractMassScan, AbstractScan, rawintensities,  intensityunit.\n\nExamples\n\n```jldoctest julia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]u\"pA\");\n\njulia> intensities(msc) == [10.0, 20.0]u\"pA\" true\n\njulia> intensities(msc, unit=u\"nA\") == [0.01, 0.02]u\"nA\" true ````\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.level-Tuple{AbstractMassScan}","page":"Scans","title":"JuChrom.level","text":"level(scan::AbstractMassScan) -> Integer\n\nReturn the MS level of a mass spectrometric scan.\n\nThe MS level indicates the stage of mass spectrometry at which the scan was acquired:\n\n1 for full MS1 scans (e.g. precursor spectra),\n2 for MS/MS scans (e.g. product ion spectra),\nHigher values for advanced fragmentation strategies (e.g. MS^n).\n\nArguments\n\nscan: A subtype of AbstractMassScan, such as MassScan\n\nReturns\n\nAn Integer value representing the MS level (guaranteed to be ≥ 1)\n\nSee also AbstractMassScan, AbstractScan.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]);\n\njulia> level(msc)\n1\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.mzcount-Tuple{AbstractMassScan}","page":"Scans","title":"JuChrom.mzcount","text":"mzcount(scan::AbstractMassScan) -> Int\n\nReturn the number of m/z values in the scan.\n\nThis is a simple utility function that returns the length of the mz_values vector stored  in a mass spectrometric scan. It reflects the number of data points (peaks) measured at a  given separation coordinate.\n\nArguments\n\nscan: A subtype of AbstractMassScan, such as MassScan\n\nReturns\n\nAn Int representing the number of m/z values in the scan\n\nSee also AbstractMassScan, AbstractScan, mzvalues,  rawmzvalues, intensities, rawintensities.\n\nExamples\n\njulia> msc = MassScan(0.5u\"s\", [100.0, 150.0, 200.0], [10.0, 20.0, 30.0]);\n\njulia> mzcount(msc)\n3\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.mzunit-Tuple{AbstractMassScan}","page":"Scans","title":"JuChrom.mzunit","text":"mzunit(scan::AbstractMassScan) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the mass-to-charge (m/z) values of a scan.\n\nTypically, this is nothing, since m/z values are conventionally unitless. If a unit was explicitly provided during scan construction, it will be returned.\n\nArguments\n\nscan: A subtype of AbstractMassScan, such as MassScan\n\nReturns\n\nA Unitful.Units subtype representing the m/z unit, or nothing if unspecified\n\nSee also AbstractMassScan, AbstractScan, mzvalues,  rawmzvalues.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]);\n\njulia> mzunit(msc) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.mzvalues-Tuple{AbstractMassScan{<:Any, Nothing}}","page":"Scans","title":"JuChrom.mzvalues","text":"mzvalues(scan::AbstractMassScan; unit=nothing)\n\nReturn the mass-to-charge (m/z) values from a mass spectrometric scan.\n\nThis method supports both unitless and unitful scans. If the scan has an associated m/z  unit, values can be converted to a different unit using the optional unit argument.  If the scan is unitless and a unit is requested, an error is thrown.\n\nArguments\n\nscan: A subtype of AbstractMassScan\nunit: Desired unit to convert m/z values into (Unitful.Units subtype or nothing,  default)\n\nReturns\n\nA vector of m/z values. If a unit is specified, values are converted to that unit;  otherwise, values are returned in their stored form.\n\nThrows\n\nArgumentError if:\nThe scan is unitless and a unit is requested.\nAssertionError if:\nThe scan claims to have a unit but mz_unit is nothing (internal inconsistency)\n\nSee also AbstractMassScan, AbstractScan, rawmzvalues,  mzunit, mzcount, intensities, rawintensities.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]);\n\njulia> mzvalues(msc) == [100.0, 200.0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.rawintensities-Tuple{AbstractMassScan{<:Any, <:Any, Nothing}}","page":"Scans","title":"JuChrom.rawintensities","text":"rawintensities(scan::AbstractMassScan; unit=nothing)\n\nReturn the raw (unitless) numeric intensity values from a mass spectrometric scan.\n\nIf the scan stores unitful intensities, the unit is stripped using Unitful.ustrip. If a specific unit is requested via the unit keyword, the values are first converted to that unit before stripping.\n\nArguments\n\nscan: A subtype of AbstractMassScan\nunit: Desired unit to convert intensities into before stripping  (Unitful.Units subtype or nothing, default)\n\nReturns\n\nA vector of numeric (unitless) intensity values.\n\nThrows\n\nArgumentError if:\nThe scan is unitless but a unit conversion is requested.\nAssertionError if:\nThe scan claims to have a unit but intensity_unit is nothing (internal  inconsistency)\n\nSee also AbstractMassScan, AbstractScan, intensities,  intensityunit, mzvalues, rawmzvalues, mzcount.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]u\"pA\");\n\njulia> rawintensities(msc) == [10.0, 20.0]\ntrue\n\njulia> rawintensities(msc, unit=u\"nA\") == [0.01, 0.02]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.rawintensity-Tuple{AbstractChromScan{<:Any, Nothing}}","page":"Scans","title":"JuChrom.rawintensity","text":"rawintensity(scan::AbstractChromScan; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the numeric intensity value of a chromatographic scan as a unitless Real.\n\nIf the scan’s intensity_unit is not nothing, the intensity value is optionally  converted to the user-specified unit using uconvert, then stripped of units. If no  unit is specified, the stored unit is used for stripping.\n\nIf intensity_unit is nothing:\n\nand a unit is requested, an error is thrown\nand no unit is requested, the raw numeric value is returned unchanged\n\nArguments\n\nscan: A subtype of AbstractChromScan\nunit: (Optional) target unit for conversion before stripping — must not be used for  unitless scans\n\nReturns\n\nA Real value with all units stripped.\n\nThrows\n\nArgumentError if a unit is requested for a scan with no stored intensity_unit\n\nBehavior Summary\n\nIf intensity_unit ≠ nothing and unit is provided → convert, then strip\nIf intensity_unit ≠ nothing and unit == nothing → strip using stored unit\nIf intensity_unit == nothing and unit == nothing → return raw value\nIf intensity_unit == nothing and unit ≠ nothing → throw ArgumentError\n\nSee also AbstractChromScan, AbstractScan, intensity,  intensityunit.\n\nExamples\n\njulia> csc = ChromScan(5.0u\"minute\", 100u\"pA\");\n\njulia> rawintensity(csc)\n100\n\njulia> rawintensity(csc; unit=u\"fA\")\n100000\n\njulia> csc2 = ChromScan(5000, 200);  # unitless intensity\n\njulia> rawintensity(csc2)\n200\n\njulia> rawintensity(csc2; unit=u\"pA\")\nERROR: ArgumentError: Cannot convert unitless intensity to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.rawmzvalues-Tuple{AbstractMassScan{<:Any, <:Any, Nothing}}","page":"Scans","title":"JuChrom.rawmzvalues","text":"rawmzvalues(scan::AbstractMassScan; unit=nothing)\n\nReturn the raw (unit-stripped) m/z values from a mass spectrometric scan.\n\nThis method returns the numeric representation of m/z values, optionally converted  to a different unit. If the scan is unitless and a unit conversion is requested,  an error is thrown.\n\nArguments\n\nscan: A subtype of AbstractMassScan\nunit: Desired unit to convert values into before stripping units  (Unitful.Units subtype or nothing, default)\n\nReturns\n\nA vector of plain numeric m/z values, optionally converted to the requested unit  and stripped of units.\n\nThrows\n\nArgumentError if:\nThe scan is unitless and a unit is requested.\nAssertionError if:\nThe scan claims to have a unit but mz_unit is nothing (internal inconsistency)\n\nSee also AbstractMassScan, AbstractScan, mzvalues,  mzunit, mzcount, intensities, rawintensities.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]);\n\njulia> rawmzvalues(msc) == [100.0, 200.0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.rawretention-Tuple{AbstractScan{Nothing}}","page":"Scans","title":"JuChrom.rawretention","text":"rawretention(scan::AbstractScan; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the numeric retention value of a scan, always as a unitless Real.\n\nIf the scan’s retention_unit is not nothing, the value is optionally converted to the  user-specified unit using uconvert, then stripped of units. If no unit is specified,  the stored unit is used for stripping.\n\nIf retention_unit is nothing:\n\nand a unit is requested, an error is thrown\nand no unit is requested, the raw numeric value is returned unchanged\n\nArguments\n\nscan: A subtype of AbstractScan\nunit: (Optional) target unit to convert to before unit stripping — must not be used for  unitless scans\n\nReturns\n\nA Real value with all units stripped.\n\nThrows\n\nArgumentError if a unit is requested for a scan with no stored retention_unit\n\nBehavior Summary\n\nIf retention_unit ≠ nothing and unit is provided → convert, then strip\nIf retention_unit ≠ nothing and unit == nothing → strip using stored unit\nIf retention_unit == nothing and unit == nothing → return raw value\nIf retention_unit == nothing and unit ≠ nothing → throw ArgumentError\n\nSee also AbstractScan, AbstractChromScan, AbstractMassScan,  retention, retentionunit.\n\nExamples\n\njulia> csc = ChromScan(5.0u\"minute\", 1000);\n\njulia> rawretention(csc)\n5.0\n\njulia> rawretention(csc; unit=u\"s\")\n300.0\n\njulia> csc2 = ChromScan(5000, 200);  # unitless retention\n\njulia> rawretention(csc2)\n5000\n\njulia> rawretention(csc2; unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.retention-Tuple{AbstractScan{Nothing}}","page":"Scans","title":"JuChrom.retention","text":"retention(scan::AbstractScan; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the retention value of a scan, optionally converted to a specified unit.\n\nIf the scan’s retention_unit is not nothing, the return value is a Unitful.Quantity.  If a unit is provided, the value is converted to that unit using uconvert.\n\nIf retention_unit is nothing:\n\nand a unit is requested, an error is thrown\nand no unit is requested, the raw numeric value is returned unchanged\n\nThis function does not assign units to unitless scans — it only performs conversions  when a unit is already stored in retention_unit.\n\nArguments\n\nscan: A subtype of AbstractScan\nunit: (Optional) target unit (e.g. u\"s\" or u\"minute\") — used only if a unit is  stored\n\nReturns\n\nA Quantity in the scan’s stored or requested unit, if applicable\nA plain Real value if the scan is unitless and no unit is requested\n\nThrows\n\nArgumentError if a unit is requested for a unitless scan\n\nSee also AbstractScan, AbstractChromScan, AbstractMassScan,  rawretention, retentionunit.\n\nExamples\n\njulia> csc = ChromScan(3.0u\"minute\", 1000);\n\njulia> retention(csc)\n3.0 minute\n\njulia> retention(csc; unit=u\"s\")\n180.0 s\n\njulia> csc2 = ChromScan(5000, 100);  # unitless retention\n\njulia> retention(csc2)\n5000\n\njulia> retention(csc2; unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retention to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/Scans/#JuChrom.retentionunit-Tuple{AbstractScan}","page":"Scans","title":"JuChrom.retentionunit","text":"retentionunit(scan::AbstractScan) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the retention value of a scan.\n\nThis function retrieves the retention_unit field from any scan subtype, which indicates  the physical unit used along the separation axis (e.g. u\"s\", u\"minute\"). If no unit  was specified at construction, returns nothing.\n\nArguments\n\nscan: A subtype of AbstractScan, such as ChromScan or MassScan\n\nReturns\n\nA Unitful.Units subtype representing the retention unit, or nothing if unspecified\n\nSee also AbstractScan, AbstractChromScan, AbstractMassScan,  retention, rawretention.\n\nExamples\n\njulia> msc = MassScan(1.0u\"s\", [100.0, 200.0], [10.0, 20.0]);\n\njulia> retentionunit(msc)\ns\n\njulia> csc = ChromScan(1.0u\"minute\", 42.0);\n\njulia> retentionunit(csc)\nminute\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#ScanMatrices","page":"ScanMatrices","title":"ScanMatrices","text":"","category":"section"},{"location":"man/ScanMatrices/#JuChrom.AbstractMassScanMatrix","page":"ScanMatrices","title":"JuChrom.AbstractMassScanMatrix","text":"AbstractMassScanMatrix{R, M, I}\n\nAbstract supertype for all matrix-based representations of mass spectrometry scan data.\n\nThis type is parameterized as follows:\n\nR: Type of the separation axis unit (a subtype of Unitful.Units or Nothing)\nM: Type of the m/z unit (a subtype of Unitful.Units or Nothing)\nI: Type of the intensity unit (a subtype of Unitful.Units or Nothing)\n\nConcrete subtypes must provide, at a minimum:\n\nretentions: A vector of real values (with or without units) representing separation  coordinates (e.g. time, index, or position)\nmz_values: A strictly increasing vector of real-valued (with or without units) m/z  values (no duplicates)\nintensities: A matrix of real-valued (with or without units) signal intensities;  each row corresponds to a scan, each column to an m/z value\nlevel: The MS level of the scans (e.g., 1 for MS1, 2 for MS2)\ninstrument, acquisition, sample, user: structured metadata as NamedTuples\nextras: Optional unstructured metadata (Dict{String, Any})\n\nSubtypes may include additional fields if needed.\n\n\n\n\n\n","category":"type"},{"location":"man/ScanMatrices/#JuChrom.MassScanMatrix","page":"ScanMatrices","title":"JuChrom.MassScanMatrix","text":"MassScanMatrix(\n    retention_unitfree::AbstractVector{<:Real},\n    retention_unit::Union{Nothing, Unitful.Units},\n    mz_values_unitfree::AbstractVector{<:Real},\n    mz_unit::Union{Nothing, Unitful.Units},\n    intensities_unitfree::AbstractMatrix{<:Real},\n    intensity_unit::Union{Nothing, Unitful.Units};\n    level::Integer = 1,\n    instrument::NamedTuple = NamedTuple(),\n    acquisition::NamedTuple = NamedTuple(),\n    user::NamedTuple = NamedTuple(),\n    sample::NamedTuple = NamedTuple(),\n    extras::AbstractDict = Dict{String, Any}()\n)\n\nConstruct a MassScanMatrix from already unitless numeric arrays and explicit unit fields.\n\nThis method is intended for advanced use, when you have already separated units from  values (e.g., after pre-processing or deserialization). All arrays must be strictly  numeric (Real), and unit arguments must be either a compatible Unitful.Units object  or nothing if unitless.\n\nArguments\n\nretention_unitfree: Vector of retention/separation coordinates (unitless, non-empty,  finite).\nretention_unit: Unit for retention values (Unitful.Units or nothing).\nmz_values_unitfree: Vector of mass-to-charge (m/z) values (unitless, strictly  increasing, positive, non-empty, finite).\nmz_unit: Unit for m/z values (Unitful.Units or nothing).\nintensities_unitfree: 2D matrix of intensities (unitless, finite, size:  length(retention_unitfree) × length(mz_values_unitfree)).\nintensity_unit: Unit for intensities (Unitful.Units or nothing).\nlevel: MS level (default: 1; must be ≥ 1).\ninstrument: Optional instrument metadata as a NamedTuple.\nacquisition: Optional acquisition metadata as a NamedTuple.\nuser: Optional user metadata as a NamedTuple.\nsample: Optional sample metadata as a NamedTuple.\nextras: Optional metadata as a Dict{String, Any}.\n\nReturns\n\nA MassScanMatrix instance with all values stored as unitless arrays and units preserved  in separate fields.\n\nThrows\n\nArgumentError if:\nretention_unitfree or mz_values_unitfree is empty or contains non-finite values\nmz_values_unitfree is not strictly increasing or contains non-positive values\nintensities_unitfree is empty or contains non-finite values\nlevel is less than 1\nDimensionMismatch if the shape of intensities_unitfree does not match length(retention_unitfree) × length(mz_values_unitfree)\n\nExamples\n\njulia> ret = [1.0, 2.0];\n       mzs = [100.0, 200.0, 300.0];\n       ints = [1.0 2.0 3.0\n               4.0 5.0 6.0];\n\njulia> msm = MassScanMatrix(ret, u\"s\", mzs, nothing, ints, nothing);\n\njulia> msm.retention_unit\ns\njulia> isnothing(msm.mz_unit)\ntrue\njulia> isnothing(msm.intensity_unit)\ntrue\njulia> size(msm.intensities)\n(2, 3)\n\n\n\n\n\nMassScanMatrix(\n    retentions::AbstractVector{<:Union{Real, Quantity}},\n    mz_values::AbstractVector{<:Union{Real, Quantity}},\n    intensities::AbstractMatrix{<:Union{Real, Quantity}};\n    level::Integer = 1,\n    instrument::NamedTuple = NamedTuple(),\n    acquisition::NamedTuple = NamedTuple(),\n    user::NamedTuple = NamedTuple(),\n    sample::NamedTuple = NamedTuple(),\n    extras::AbstractDict = Dict{String, Any}()\n)\n\nConstruct a MassScanMatrix representing a collection of aligned mass spectrometry scans.\n\nAll inputs may contain raw numeric values or Unitful.Quantity values. If units are  present, they are stripped and stored separately. Each input must either be entirely  unitless or use consistent units across its values.\n\nArguments\n\nretentions: A vector of separation coordinates (e.g. times, positions, or indices); must be non-empty and finite; may include units.\nmz_values: A strictly increasing, positive, non-empty vector of mass-to-charge (m/z) values; may include units.\nintensities: A 2D matrix of intensities, where rows match retentions and columns match mz_values; all values must be finite and units (if any) must be consistent.\nlevel: MS level (default: 1; must be ≥ 1).\ninstrument: Optional instrument metadata as a NamedTuple.\nacquisition: Optional acquisition metadata as a NamedTuple.\nuser: Optional user metadata as a NamedTuple.\nsample: Optional sample metadata as a NamedTuple.\nextras: Optional metadata as a Dict{String, Any}.\n\nReturns\n\nA MassScanMatrix instance with values stored unitless, and units preserved in separate fields.\n\nThrows\n\nArgumentError if:\nretentions is empty or contains non-finite values\nmz_values is empty, non-strictly increasing, non-positive, or non-finite\nintensities is empty or contains non-finite values\nunits (if present) are inconsistent across any of the inputs\nlevel is less than 1\nDimensionMismatch if the shape of intensities does not match length(retentions) × length(mz_values)\n\nExamples\n\njulia> ret = [1.0, 2.0]u\"s\"\n       mzs = [100.0, 200.0, 300.0];\n       ints = [1.0 2.0 3.0\n               4.0 5.0 6.0];\n\njulia> msm = MassScanMatrix(ret, mzs, ints);\n\njulia> msm.retention_unit\ns\n\njulia> isnothing(msm.mz_unit)\ntrue\n\njulia> isnothing(msm.intensity_unit)\ntrue\n\njulia> size(msm.intensities)\n(2, 3)\n\njulia> msm.level\n1\n\njulia> msm.extras\nDict{String, Any}()\n\n\n\n\n\n","category":"type"},{"location":"man/ScanMatrices/#JuChrom.acquisition-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.acquisition","text":"acquisition(msm::AbstractMassScanMatrix) -> NamedTuple\n\nReturns the acquisition metadata associated with the mass scan matrix.\n\nThe acquisition metadata typically includes details such as scan mode, method parameters, instrument configuration, or other context relevant to how the mass spectrometry data was  acquired.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix.\n\nReturns\n\nA NamedTuple containing acquisition-related metadata.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, instrument,  sample, user, extras.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0], \n                            acquisition=(mode = \"DIA\", method = \"Orbitrap-MS\"));\n\njulia> acquisition(msm)\n(mode = \"DIA\", method = \"Orbitrap-MS\")\n\njulia> acquisition(msm).method\n\"Orbitrap-MS\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.extras-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.extras","text":"extras(msm::AbstractMassScanMatrix) -> Dict{String, Any}\n\nReturns the unstructured extras associated with the mass scan matrix.\n\nThis dictionary may contain arbitrary key-value pairs that are not captured by the  structured fields such as instrument, acquisition, user, or sample.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix.\n\nReturns\n\nA Dict{String, Any} containing unstructured metadata.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, acquisition,  instrument, sample, user.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]; \n                             extras=Dict(\"run\" => 42, \"comment\" => \"Baseline drift\"));\n\njulia> extras(msm)\nDict{String, Any} with 2 entries:\n  \"run\"     => 42\n  \"comment\" => \"Baseline drift\"\n\njulia> extras(msm)[\"qc_passed\"] = true;\n\njulia> extras(msm)\nDict{String, Any} with 3 entries:\n  \"qc_passed\" => true\n  \"run\"       => 42\n  \"comment\"   => \"Baseline drift\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.instrument-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.instrument","text":"instrument(msm::AbstractMassScanMatrix) -> NamedTuple\n\nReturns the instrument metadata associated with the mass scan matrix.\n\nThis typically includes information about the hardware used for data acquisition, such as  detector type, manufacturer, model, or configuration parameters.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix.\n\nReturns\n\nA NamedTuple containing instrument-specific metadata.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, acquisition,  sample, user, extras.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0];                              instrument=(detector = \"Orbitrap\", manufacturer = \"Thermo\")); julia> instrument(msm) (detector = \"Orbitrap\", manufacturer = \"Thermo\")\n\njulia> instrument(msm).detector \"Orbitrap\" ```\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.intensities-Tuple{AbstractMassScanMatrix{<:Any, <:Any, Nothing}}","page":"ScanMatrices","title":"JuChrom.intensities","text":"intensities(msm::AbstractMassScanMatrix;\n            unit::Union{Nothing, Unitful.Units}=nothing) -> Matrix{<:Real}\n\nReturn the intensity values from all scans in a mass scan matrix.\n\nThis function retrieves the intensity values from each scan in the mass scan matrix.   If the matrix stores unitful intensities and a unit is specified, the values are  converted accordingly. If the matrix stores unitless intensities, a unit conversion  request will throw an ArgumentError.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix containing mass scans.\nunit: (optional) A Unitful.Units object to convert intensities to. If omitted or  nothing, intensities are returned as stored.\n\nReturns\n\nA matrix of intensity values, either as plain numbers or Quantitys, depending on the  stored data.\n\nThrows\n\nArgumentError if the scan matrix stores unitless intensities but a unit conversion is  requested.\n\nSee also AbstractMassScanMatrix, MassScanMatrix,  intensityunit, rawintensities, mzcount, scancount.\n\nExamples\n\njulia> msm = MassScanMatrix([1, 2]u\"s\", [100.0, 150.0], [10.0 20.0; 15.0 25.0]u\"pA\");\n\njulia> intensities(msm) ≈ [10.0 20.0; 15.0 25.0]u\"pA\"\ntrue\n\njulia> intensities(msm, unit=u\"nA\") ≈ [0.01 0.02; 0.015 0.025]u\"nA\"\ntrue\n\njulia> msm2 = MassScanMatrix([1, 2]u\"s\", [100.0, 150.0], [10.0 20.0; 15.0 25.0]);\n\njulia> intensities(msm2) ≈ [10.0 20.0; 15.0 25.0]\ntrue\n\njulia> intensities(msm2, unit=u\"nA\")\nERROR: ArgumentError: Cannot convert unitless intensities to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.intensityunit-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.intensityunit","text":"intensityunit(msm::AbstractMassScanMatrix) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the intensity values of a mass scan matrix.\n\nThis function retrieves the intensity_unit field from any mass scan matrix subtype,  which indicates the physical unit used for the signal intensities (e.g. u\"pA\"). If  no unit was specified at construction, returns nothing.\n\nArguments\n\nmsm: A subtype of AbstractMassScanMatrix, such as MassScanMatrix.\n\nReturns\n\nA Unitful.Units subtype representing the intensity unit, or nothing if unspecified.\n\nSee also AbstractMassScanMatrix, AbstractMassScan,  intensities, rawintensities.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]u\"pA\");\n\njulia> intensityunit(msm)\npA\n\njulia> msm2 = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> intensityunit(msm2) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.level-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.level","text":"level(msm::AbstractMassScanMatrix) -> Integer\n\nReturn the MS level of a mass scan matrix.\n\nThe MS level indicates the stage of mass spectrometry at which the scans were acquired:\n\n1 for full MS1 scans (e.g. precursor spectra),\n2 for MS/MS scans (e.g. product ion spectra),\nHigher values for advanced fragmentation strategies (e.g. MSⁿ).\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix, such as MassScanMatrix.\n\nReturns\n\nAn Integer value representing the MS level (guaranteed to be ≥ 1).\n\nSee also AbstractMassScanMatrix, MassScanMatrix, levels,  levelscans.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]; level=2);\n\njulia> level(msm)\n2\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.mzcount-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.mzcount","text":"mzcount(msm::AbstractMassScanMatrix) -> Int\n\nReturn the number of m/z values in the mass scan matrix.\n\nThis utility function returns the length of the mz_values vector stored in a mass  spectrometric scan matrix. It reflects the number of unique m/z data points (peaks)  measured across all scans in the matrix, typically corresponding to the columns of the  intensity matrix.\n\nArguments\n\nmsm::AbstractMassScanMatrix: A mass scan matrix object, such as MassScanMatrix,  containing multiple scans and their associated m/z values.\n\nReturns\n\nInt: The number of m/z values in the scan matrix.\n\nSee also AbstractMassScanMatrix, AbstractMassScan, mzvalues,  rawmzvalues.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0]u\"s\", [100.0, 200.0], [1.0 2.0]);\n\njulia> mzcount(msm) 2\n\njulia> mzcount(msm) == size(intensities(msm), 2) true ```\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.mzunit-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.mzunit","text":"mzunit(msm::AbstractMassScanMatrix) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the mass-to-charge (m/z) values of a mass scan matrix.\n\nTypically, this is nothing, since m/z values are conventionally unitless. If a unit was explicitly provided during matrix construction, it will be returned.\n\nArguments\n\nmsm: A subtype of AbstractMassScanMatrix, such as MassScanMatrix.\n\nReturns\n\nA Unitful.Units subtype representing the m/z unit, or nothing if unspecified.\n\nSee also AbstractMassScanMatrix, AbstractMassScan, mzvalues,  rawmzvalues.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0]u\"Th\", [1.0 2.0; 3.0 4.0]);\n\njulia> mzunit(msm)\nTh\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> mzunit(msm) == nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.mzvalues-Tuple{AbstractMassScanMatrix{<:Any, Nothing}}","page":"ScanMatrices","title":"JuChrom.mzvalues","text":"mzvalues(msm::AbstractMassScanMatrix; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the mass-to-charge (m/z) values from a mass scan matrix.\n\nThis method supports both unitless and unitful matrices. If the matrix has an associated m/z  unit, values can be converted to a different unit using the optional unit argument.  If the matrix is unitless and a unit is requested, an error is thrown.\n\nArguments\n\nmsm: A subtype of AbstractMassScanMatrix.\nunit: Desired unit to convert m/z values into (Unitful.Units subtype or nothing, default).\n\nReturns\n\nA vector of m/z values. If a unit is specified, values are converted to that unit;  otherwise, values are returned in their stored form.\n\nThrows\n\nArgumentError if:\nThe matrix is unitless and a unit is requested.\nAssertionError if:\nThe matrix claims to have a unit but mz_unit is nothing (internal inconsistency).\n\nSee also AbstractMassScanMatrix, AbstractMassScan, rawmzvalues,  mzunit, mzcount, intensities.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0]u\"Th\", [1.0 2.0; 3.0 4.0]);\n\njulia> mzvalues(msm) == [100.0, 200.0]u\"Th\"\ntrue\n\njulia> mzvalues(msm, unit=u\"kTh\") == [0.1, 0.2]u\"kTh\"\ntrue\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> mzvalues(msm) == [100.0, 200.0]\ntrue\n\njulia> mzvalues(msm, unit=u\"Th\")\nERROR: ArgumentError: Cannot convert unitless m/z values to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.rawintensities-Tuple{AbstractMassScanMatrix{<:Any, <:Any, Nothing}}","page":"ScanMatrices","title":"JuChrom.rawintensities","text":"rawintensities(msm::AbstractMassScanMatrix;\n               unit::Union{Nothing, Unitful.Units}=nothing) -> Matrix\n\nReturn the numeric (unitless) intensity values from all scans in a mass scan matrix.\n\nIf the scan matrix’s intensity_unit is not nothing, the intensity values are optionally  converted to the user-specified unit using uconvert, then stripped of units. If no  unit is specified, the stored unit is used for stripping.\n\nIf the matrix does not define intensity units, requesting a unit conversion will throw an  ArgumentError.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix, such as MassScanMatrix.\nunit: (optional) A Unitful.Units object to which the raw intensities should be  converted. If the scan matrix does not define intensity units, this must remain nothing.\n\nReturns\n\nA matrix of (unitless) intensity values, with optional unit conversion. Each row typically  corresponds to a scan, and each column to an m/z value.\n\nThrows\n\nArgumentError if a unit is requested but the scan matrix has no defined intensity unit.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, intensities,  intensityunit, scancount, mzcount.\n\nExamples\n\njulia> msm = MassScanMatrix([1, 2]u\"s\", [100.0, 150.0], [10.0 20.0; 15.0 25.0]u\"pA\");\n\njulia> rawintensities(msm, unit=u\"nA\") ≈ [0.01 0.02; 0.015 0.025]\ntrue\n\njulia> msm2 = MassScanMatrix([1, 2]u\"s\", [100.0, 150.0], [10.0 20.0; 15.0 25.0]);\n\njulia> rawintensities(msm2) ≈ [10.0 20.0; 15.0 25.0]\ntrue\n\njulia> rawintensities(msm2, unit=u\"pA\")\nERROR: ArgumentError: Cannot convert unitless intensities to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.rawmzvalues-Tuple{AbstractMassScanMatrix{<:Any, Nothing}}","page":"ScanMatrices","title":"JuChrom.rawmzvalues","text":"rawmzvalues(msm::AbstractMassScanMatrix; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the raw (unit-stripped) m/z values from a mass scan matrix.\n\nThis method returns the numeric representation of m/z values, optionally converted  to a different unit. If the matrix is unitless and a unit conversion is requested,  an error is thrown.\n\nArguments\n\nmsm: A subtype of AbstractMassScanMatrix.\nunit: Desired unit to convert values into before stripping units  (Unitful.Units subtype or nothing, default).\n\nReturns\n\nA vector of plain numeric m/z values, optionally converted to the requested unit  and stripped of units.\n\nThrows\n\nArgumentError if:\nThe matrix is unitless and a unit is requested.\nAssertionError if:\nThe matrix claims to have a unit but mz_unit is nothing (internal inconsistency).\n\nSee also AbstractMassScanMatrix, AbstractMassScan, mzvalues,  mzunit, mzcount, intensities.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0]u\"Th\", [1.0 2.0; 3.0 4.0]);\n\njulia> rawmzvalues(msm) == [100.0, 200.0]\ntrue\n\njulia> msm2 = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> rawmzvalues(msm2) == [100.0, 200.0]\ntrue\n\njulia> rawmzvalues(msm2, unit=u\"kTh\")\nERROR: ArgumentError: Cannot convert unitless m/z values to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.rawretentions-Tuple{AbstractMassScanMatrix{Nothing}}","page":"ScanMatrices","title":"JuChrom.rawretentions","text":"rawretentions(msm::AbstractMassScanMatrix{Nothing}; \n              unit::Union{Nothing, Unitful.Units}=nothing) -> Vector{<:Real}\n\nReturns the raw (unitless) retention values for all scans in the given mass scan matrix.\n\nIf the scan matrix stores unitless retention values, they are returned as-is. If a unit is  requested via the unit keyword, an error is thrown since conversion is not possible.\n\nArguments\n\nmsm: A subtype of AbstractMassScanMatrix whose retentions are unitless.\nunit: (optional) Must be nothing for unitless retention values; otherwise,  an error is thrown.\n\nReturns\n\nA Vector{<:Real} of raw, unitless retention values for the scan matrix.\n\nThrows\n\nArgumentError if a unit is requested for a scan matrix that does not define a retention  unit.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, retentions,  retentionunit, scancount.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> rawretentions(msm) == [1.0, 2.0]\ntrue\n\njulia> msm2 = MassScanMatrix([1.0, 2.0], [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> rawretentions(msm2, unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retentions to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.retentions-Tuple{AbstractMassScanMatrix{Nothing}}","page":"ScanMatrices","title":"JuChrom.retentions","text":"retentions(msm::AbstractMassScanMatrix; unit::Union{Nothing, Unitful.Units}=nothing)\n\nReturn the vector of retention values for a scan object, optionally converted to a  specified unit.\n\nIf the scan’s retention_unit is not nothing, the returned vector consists of  Unitful.Quantity values. If a unit is provided, all values are converted to that unit  using uconvert..\n\nIf retention_unit is nothing:\n\nand a unit is requested, an error is thrown\nand no unit is requested, the raw numeric vector is returned unchanged\n\nThis function does not assign units to unitless scans — it only performs conversions  when a unit is already stored in retention_unit.\n\nArguments\n\nmsm: A subtype of AbstractScan whose retention field is a vector of values.\nunit: (Optional) target unit (e.g. u\"s\" or u\"minute\") — used only if a unit is  stored.\n\nReturns\n\nA vector of Quantity values in the scan’s stored or requested unit, if applicable.\nA plain vector of Real values if the scan is unitless and no unit is requested.\n\nThrows\n\nArgumentError if a unit is requested for a unitless scan.\n\nSee also AbstractMassScanMatrix, MassScanMatrix,  rawretentions, retentionunit, scancount.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> retentions(msm) == [1.0, 2.0]u\"s\"\ntrue\n\njulia> retentions(msm; unit=u\"ms\") == [1000.0, 2000.0]u\"ms\"\ntrue\n\njulia> msm2 = MassScanMatrix([1.0, 2.0], [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> retentions(msm2) == [1.0, 2.0]  # unitless\ntrue\n\njulia> retentions(msm2; unit=u\"s\")\nERROR: ArgumentError: Cannot convert unitless retentions to a unit\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.retentionunit-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.retentionunit","text":"retentionunit(scan::AbstractMassScanMatrix) -> Union{Unitful.Units, Nothing}\n\nReturn the unit associated with the retention value of a scan.\n\nThis function retrieves the retention_unit field from any scan subtype, which indicates  the physical unit used along the separation axis (e.g. u\"s\", u\"minute\"). If no unit  was specified at construction, returns nothing.\n\nArguments\n\nscan: A subtype of AbstractScan, such as ChromScan or MassScan.\n\nReturns\n\nA Unitful.Units subtype representing the retention unit, or nothing if unspecified.\n\nSee also AbstractMassScanMatrix, MassScanMatrix,  retentions, rawretentions.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> retentionunit(msm)\ns\n\njulia> msm2 = MassScanMatrix([1.0, 2.0]u\"minute\", [100.0, 200.0], [1.0 2.0; 3.0 4.0]);\n\njulia> retentionunit(msm2)\nminute\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.sample-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.sample","text":"sample(msm::AbstractMassScanMatrix) -> NamedTuple\n\nReturns the sample metadata associated with the mass scan matrix.\n\nThis typically includes information about the analyzed sample, such as sample ID, origin,  preparation details, or treatment conditions.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix.\n\nReturns\n\nA NamedTuple containing sample-related metadata.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, acquisition,  instrument, user, extras.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0],\n                            sample=(ID = \"Polistes dominula\", locality = \"Germany\"));\n\njulia> sample(msm)\n(ID = \"Polistes dominula\", locality = \"Germany\")\n\njulia> sample(msm).ID\n\"Polistes dominula\"\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.scancount-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.scancount","text":"scancount(msm::AbstractMassScanMatrix) -> Int\n\nReturn the number of individual scans in the mass scan matrix.\n\nThis function returns the number of scan entries (e.g. time points or separation  coordinates) in the mass scan matrix. It reflects the total number of scans stored in the  intensity matrix.\n\nArguments\n\nmsm::AbstractMassScanMatrix: A mass scan matrix object, such as MassScanMatrix,  containing multiple scans and their associated retention times or separation coordinates.\n\nReturns\n\nInt: The number of scan elements in the matrix.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, retentions.\n\nExamples\n\njulia> msm = MassScanMatrix([0.5, 1.0]u\"s\", [100.0, 150.0, 200.0], [10 20 30; 15 25 35]);\n\njulia> scancount(msm)\n2\n\njulia> scancount(msm) == size(intensities(msm), 1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/ScanMatrices/#JuChrom.user-Tuple{AbstractMassScanMatrix}","page":"ScanMatrices","title":"JuChrom.user","text":"user(msm::AbstractMassScanMatrix) -> NamedTuple\n\nReturns the user metadata associated with the mass scan matrix.\n\nThis typically includes information about the operator, data analyst, or other user-specific annotations relevant to the acquisition or processing of the data.\n\nArguments\n\nmsm: A concrete subtype of AbstractMassScanMatrix.\n\nReturns\n\nA NamedTuple containing user-related metadata.\n\nSee also AbstractMassScanMatrix, MassScanMatrix, acquisition,  instrument, sample, extras.\n\nExamples\n\njulia> msm = MassScanMatrix([1.0, 2.0]u\"s\", [100.0, 200.0], [1.0 2.0; 3.0 4.0],\n                            user=(operator = \"Alice\", project = \"QC-2025\"));\n\njulia> user(msm)\n(operator = \"Alice\", project = \"QC-2025\")\n\njulia> user(msm).operator\n\"Alice\"\n\n\n\n\n\n","category":"method"},{"location":"man/convert/#Convert","page":"Convert","title":"Convert","text":"","category":"section"},{"location":"man/convert/#JuChrom.mzchrom","page":"Convert","title":"JuChrom.mzchrom","text":"mzchrom(series::MassScanSeries,\n        selection::Union{Nothing, <:Number, AbstractVector{<:Number}}=nothing;\n        tol::Number=3e-4,\n        warning::Bool=true)\n\nExtract a chromatogram scan series from a MassScanSeries.\n\nselection: either nothing (TIC) or a scalar/collection of m/z targets. When a scalar or vector is given, intensities at the selected m/z are summed per scan (XIC).  \ntol: the absolute tolerance used when matching selection m/z values to each scan’s discrete m/z grid. The nearest m/z value within tol is chosen for each target. tol  may be numeric or unitful. If the series’ m/z are unitless, tol must be unitless  (unitful tol errors). If the series’ m/z have a unit, numeric tol is interpreted in  that unit; unitful tol is converted to the m/z unit; incompatible units error.\nwarning: whether to emit warnings if m/z values are not found or indices are out of bounds.\n\nReturns a ChromScanSeries with retention time and intensity units preserved.\n\n\n\n\n\nmzchrom(msm::MassScanMatrix, \n        selection::Union{Nothing, <:Number, AbstractVector{<:Number}}=nothing;\n        by::Symbol=:mz, tol::Number=3e-4, warning::Bool=true)\n\nExtract a chromatogram scan series from a MassScanMatrix.\n\nselection: either nothing (TIC) or a scalar/collection of m/z or index targets. When given, intensities at the selected m/z or column indices are summed per scan.  \nby: specifies whether selection refers to m/z values (:mz, default) or to column indices (:index) in the matrix.  \ntol: the absolute tolerance used when matching selection m/z values to the discrete  m/z grid of the matrix. The nearest m/z value within tol is chosen for each target.  tol may be numeric or unitful. If the matrix m/z are unitless, tol must be unitless  (unitful tol errors). If the matrix m/z have a unit, numeric tol is interpreted in  that unit; unitful tol is converted to the m/z unit; incompatible units error.    \nwarning: whether to emit warnings if m/z values are not found or indices are out of bounds.\n\nReturns a ChromScanSeries with retention time and intensity units preserved.\n\n\n\n\n\n","category":"function"},{"location":"#JuChrom.jl","page":"Home","title":"JuChrom.jl","text":"Documentation for JuChrom.jl","category":"section"}]
}
