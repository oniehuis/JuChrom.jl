var documenterSearchIndex = {"docs":
[{"location":"man/register/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/register/","page":"Index","title":"Index","text":"","category":"page"},{"location":"internals/inputoutput/#InputOutput","page":"InputOutput","title":"InputOutput","text":"","category":"section"},{"location":"internals/inputoutput/","page":"InputOutput","title":"InputOutput","text":"JuChrom.InputOutput.FileExistsError\nJuChrom.InputOutput.IOError\nJuChrom.InputOutput.Source\nJuChrom.InputOutput.File\nJuChrom.InputOutput.Path\nJuChrom.InputOutput.buildxic","category":"page"},{"location":"internals/inputoutput/#JuChrom.InputOutput.FileExistsError","page":"InputOutput","title":"JuChrom.InputOutput.FileExistsError","text":"JuChrom.InputOutput.FileExistsError([msg::AbstractString]) <: Exception\n\nFile already exists. msg is an optional descriptive error message.\n\nSee also IOError.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.IOError","page":"InputOutput","title":"JuChrom.InputOutput.IOError","text":"JuChrom.InputOutput.IOError([msg::AbstractString]) <: Exception\n\nThere was a problem reading or writing a file. msg is an optional descriptive error  message.\n\nSee also FileExistsError.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.Source","page":"InputOutput","title":"JuChrom.InputOutput.Source","text":"JuChrom.InputOutput.Source\n\nSupertype for all data sources.\n\nSee also File, Path.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.File","page":"InputOutput","title":"JuChrom.InputOutput.File","text":"JuChrom.InputOutput.File() <: Source\n\nType that indicates a source is a file.\n\nSee also Source, Path.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.Path","page":"InputOutput","title":"JuChrom.InputOutput.Path","text":"JuChrom.InputOutput.Path() <: Source\n\nType that indicates a source is a path.\n\nSee also Source, File.\n\n\n\n\n\n","category":"type"},{"location":"internals/inputoutput/#JuChrom.InputOutput.buildxic","page":"InputOutput","title":"JuChrom.InputOutput.buildxic","text":"JuChrom.InputOutput.buildxic(pointcounts::AbstractVector{<:Integer}, \nionvec::AbstractVector{<:Real}, intsvec::AbstractVector{<:Real})\n\nReturn a sorted list of ions and an intensity matrix with the number of columns equal to  the number of ions in the sorted list and the number of rows equal to the number of scans.  This is based on a vector that stores the number of ion-intensity pairs per scan  (pointcounts), a vector of continuously recorded ions throughout the run (ionvec), and  a vector of intensity values associated with those ions (intsvec).\n\nExamples\n\njulia> pointcounts = [2, 3, 2];\n\njulia> ionvec = [85.1, 100.2, 85.2, 99.9, 112.1, 84.9, 100.6];\n\njulia> intsvec = Int64[12, 234, 23, 324, 45422, 21, 523];\n\njulia> mzs, xic = JuChrom.InputOutput.buildxic(pointcounts, ionvec, intsvec);\n\njulia> mzs\n7-element Vector{Float64}:\n  84.9\n  85.1\n  85.2\n  99.9\n 100.2\n 100.6\n 112.1\n\njulia> xic\n3×7 Matrix{Int64}:\n  0  12   0    0  234    0      0\n  0   0  23  324    0    0  45422\n 21   0   0    0    0  523      0\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"AbstractChromatogram\nAbstractChrom\nAbstractChromMS\nChromMS\nChrom\nIonScanOrder\nLinearAscending\nLinearDescending\nbinions\ninteger\nintensities(::AbstractChrom; ::OrdinalRange{T, S}) where {T<:Integer, S<:Integer}\nintensities(::AbstractChromMS; ::OrdinalRange{T1, S1}, ::OrdinalRange{T2, S2}) where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}\nintensity(::AbstractChrom, ::Integer)\nintensity(::AbstractChrom, ::Unitful.Time; ::Bool)\nintensity(::AbstractChromMS, ::Integer, ::Integer)\nintensity(::AbstractChromMS, ::Unitful.Time, ::Real; ::Bool)\nion(::AbstractChromMS, ::Integer)\nioncount(::AbstractChromMS)\nionindex(::AbstractChromMS, ::Real)\nionscantime\nionscantimeindex\nionscantimes\nionscantimeshift\nions(::AbstractChromMS)\nmaxintensity(::AbstractChrom; ::OrdinalRange{T, S}) where {T<:Integer, S<:Integer}\nmaxintensity(::AbstractChromMS; ::OrdinalRange{T1, S1}, ::OrdinalRange{T2, S2}) where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}\nmaxion(::AbstractChromMS)\nmaxscantime\nmetadata(::AbstractChromatogram)\nminintensity(::AbstractChrom; ::OrdinalRange{T, S}) where {T<:Integer, S<:Integer}\nminintensity(::AbstractChromMS; ::OrdinalRange{T1, S1}, ::OrdinalRange{T2, S2}) where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}\nminion(::AbstractChromMS)\nminscantime\nrimapper(::AbstractChromatogram)\nrimapper!(::AbstractChromatogram, ::AbstractRiMapper)\nrunduration\nscancount\nscanduration\nscantime\nscantimeindex\nscantimes\ntotalionchromatogram","category":"page"},{"location":"man/basics/#JuChrom.AbstractChromatogram","page":"Basics","title":"JuChrom.AbstractChromatogram","text":"AbstractChromatogram\n\nSupertype for all chromatogram implementations. All subtypes (e.g., Chrom, ChromMS)  include scan times and intensities and, optionally, metadata and a retention index mapper.\n\nSee also AbstractChrom, AbstractChromMS, ChromMS, Chrom,  scantimes, intensities, metadata, rimapper,.\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.AbstractChrom","page":"Basics","title":"JuChrom.AbstractChrom","text":"AbstractChrom <: AbstractChromatogram\n\nSupertype for all chromatogram implementations that have a single intensity value  associated with each scan time (e.g., Chrom). The intensities are stored in a vector, with  the index corresponding to the scan time index.\n\nSee also AbstractChromatogram, Chrom, scantimes,  intensities, metadata, rimapper, .\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.AbstractChromMS","page":"Basics","title":"JuChrom.AbstractChromMS","text":"AbstractChromMS <: AbstractChromatogram\n\nSupertype for all chromatogram implementations that include mass-charge ratio (m/z)  data (ions) and associated abundance values (intensities) (e.g., ChromMS). This type can  have one or more ion intensity values associated with a given scan time. Intensities are  stored in a matrix where the row index represents the scan time and the column index  represents the ion.\n\nSee also AbstractChromatogram, AbstractChromMS, ChromMS,  scantimes, ions, intensities, metadata,  rimapper.\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.ChromMS","page":"Basics","title":"JuChrom.ChromMS","text":"ChromMS(scantimes::AbstractVector{<:Unitful.Time}, ions::AbstractVector{<:Real}, \nintensities::AbstractMatrix{<:Real}; metadata::Dict=Dict{Any, Any}(), \nrimapper::Union{AbstractRiMapper, Nothing}=nothing) <: AbstractChromMS\n\nConstruct a ChromMS object that includes scantimes, ions, intensities, and  metadata. Ensure that both scantimes and ions are in ascending order. The scan times  must include a time unit. All time units supported by the  Unitful.jl package  (e.g., u\"s\", u\"minute\") are accepted. You can optionally use the keyword argument  rimapper to include a retention index mapper.\n\nSee also AbstractChromatogram, AbstractChromMS, scantimes,  ions, intensities, metadata.\n\nIn the following examples, the types of scantimes, ions, and intensities are  explicitely annotated to demonstrate that the ChromMS object preserves these types.\n\nExamples\n\njulia> ChromMS(Int32[1, 2, 3]u\"s\", Int64[85, 100], Int32[0 12; 34 956; 23 1])\nChromMS {scan times: Int32, ions: Int64, intensities: Int32}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> ChromMS([1.1f0, 2.1f0]u\"s\", [35.1f0, 76.2f0], Int64[0 12; 34 956], Dict(:id => 4))\nChromMS {scan times: Float32, ions: Float32, intensities: Int64}\n2 scans; scan times: 1.1f0 s, 2.1f0 s\n2 ions: m/z 35.1, 76.2\nintensity range: 0 - 956\nmetadata: 1 entry\n\njulia> ChromMS([2, 1, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nERROR: ArgumentError: scan times not in ascending order\n[...]\n\njulia> ChromMS([1, 2, 3]u\"s\", [100, 85], [0 12; 34 956; 23 1])\nERROR: ArgumentError: ions not in ascending order\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.Chrom","page":"Basics","title":"JuChrom.Chrom","text":"Chrom(scantimes::AbstractVector{<:Unitful.Time}, \nintensities::AbstractVector{<:Real}, metadata::Dict=Dict{Any, Any}; \nrimapper::Union{AbstractRiMapper, Nothing}=nothing) <: AbstractChrom\n\nConstruct a Chrom object that includes scantimes, intensities, and metadata.  Ensure that both scantimes and ions are in ascending order. The scan times must  include a time unit. All time units supported by the  Unitful.jl package (e.g., u\"s\",  u\"minute\") are accepted. You can optionally use the keyword argument rimapper to  include a retention index mapper.\n\nSee also AbstractChromatogram, AbstractChrom, scantimes,  intensities, metadata, rimapper.\n\nIn the following examples, the types of scantimes and intensities are explicitely  annotated to demonstrate that the Chrom object preserves these types.\n\nExamples\n\njulia> Chrom(Int64[1, 2, 3]u\"s\", Int32[12, 956, 1])\nChrom {scan times: Int64, intensities: Int32}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 1 - 956\nmetadata: 0 entries\n\njulia> Chrom(Int32[1, 2, 3]u\"s\", Float64[12.0, 956.0, 1.0], Dict(\"name\" => \"sample\"))\nChrom {scan times: Int32, intensities: Float64}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 1.0 - 956.0\nmetadata: 1 entry\n\njulia> Chrom([2, 1, 3]u\"s\", [12.0, 956.0, 1.0])\nERROR: ArgumentError: scan times not in ascending order\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.IonScanOrder","page":"Basics","title":"JuChrom.IonScanOrder","text":"IonScanOrder\n\nSupertype of all ion scan order implementations.\n\nSee also LinearAscending, LinearDescending, ionscantimeshift,  ionscantimes, ionscantime, ionscantimeindex.\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.LinearAscending","page":"Basics","title":"JuChrom.LinearAscending","text":"LinearAscending(; start::Real=0, stop::Real=1) <: IonScanOrder\n\nConstruct a LinearAscending ion scan order object. This object specifies that ions were  scanned in linear ascending order (i.e., smallest ion first, largest ion last) during each  scan. The time allocated to scan each ion is assumed to be equal, resulting from dividing  the total scan interval time equally among the ions. The optional start and stop  parameters allow you to limit the time interval during which ions were scanned in each  scan. These parameters specify relative points within the scan interval: 0 ≤ start < stop  ≤ 1. The default values are start=0 and stop=1, meaning the scan of the smallest ion  began at the start of the scan interval and the scan of the largest ion concluded at the  end of the interval. In contrast, setting the start value to 0.5 indicates that ions were  scanned only during the second half of the scan interval. For instance, this could occur if  the instrument switched between SIM mode and Scan mode during each scan interval, operating  in Scan mode only during the second half, which generated the data in question.\n\nSee also AbstractChromMS, LinearDescending, ionscantimeshift,  ionscantimes, ionscantime, ionscantimeindex, ions,  minion, maxion, ioncount, scanduration,  scantimes, minscantime, maxscantime.\n\nExamples\n\njulia> LinearAscending()\nLinearAscending{Int64, Int64}(0, 1)\n\njulia> LinearAscending(; start=0.5)\nLinearAscending{Float64, Int64}(0.5, 1)\n\njulia> LinearAscending(; start=0.1, stop=0.5)\nLinearAscending{Float64, Float64}(0.1, 0.5)\n\njulia> LinearAscending(; start=0.5, stop=0.5)\nERROR: ArgumentError: start=0.5 and stop=0.5 do not satisfy condition 0 ≤ start < stop ≤ 1\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.LinearDescending","page":"Basics","title":"JuChrom.LinearDescending","text":"LinearDescending(; start::Real=0, stop::Real=1) <: IonScanOrder\n\nConstruct a LinearDescending ion scan order object. This object specifies that ions were  scanned in linear descending order (i.e., largest ion first, smallest ion last) during each  scan. The time allocated to scan each ion is assumed to be equal, resulting from dividing  the total scan interval time equally among the ions. The optional start and stop  parameters allow you to limit the time interval during which ions were scanned in each  scan. These parameters specify relative points within the scan interval: 0 ≤ start < stop  ≤ 1. The default values are start=0 and stop=1, meaning the scan of the largest ion  began at the start of the scan interval and the scan of the smallest ion concluded at the  end of the interval. In contrast, setting the start value to 0.5 indicates that ions were  scanned only during the second half of the scan interval. For instance, this could occur if  the instrument switched between SIM mode and Scan mode during each scan interval, operating  in Scan mode only during the second half, which generated the data in question.\n\nSee also AbstractChromMS, LinearAscending, ionscantimeshift,  ionscantimes, ionscantime, ionscantimeindex, ions,  minion, maxion, ioncount, scanduration,  scantimes, minscantime, maxscantime.\n\nExamples\n\njulia> LinearDescending()\nLinearDescending{Int64, Int64}(0, 1)\n\njulia> LinearDescending(; start=0.5)\nLinearDescending{Float64, Int64}(0.5, 1)\n\njulia> LinearDescending(; start=0.1, stop=0.5)\nLinearDescending{Float64, Float64}(0.1, 0.5)\n\njulia> LinearDescending(; start=0.5, stop=0.5)\nERROR: ArgumentError: start=0.5 and stop=0.5 do not satisfy condition 0 ≤ start < stop ≤ 1\n[...]\n\n\n\n\n\n","category":"type"},{"location":"man/basics/#JuChrom.binions","page":"Basics","title":"JuChrom.binions","text":"binions(chrom::ChromMS; ionbin::Function=integer)\n\nReturn a ChromMS object in which the ions are binned according to the ionbin function (the  default is the integer function), and the intensities of the binned ions are summed.\n\nSee also AbstractChromMS, integer, intensities, ions,  ioncount.\n\nExamples\n\njulia> chrom = ChromMS((1:3)u\"s\", [84.8, 85.2, 100.9], [0 24 12; 0 0 956; 23 0 1])\nChromMS {scan times: Int64, ions: Float64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n3 ions: m/z 84.8, 85.2, 100.9\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensities(chrom)\n3×3 Matrix{Int64}:\n  0  24   12\n  0   0  956\n 23   0    1\n\njulia> chrom_binnedions = binions(chrom)\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 101\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> ions(chrom_binnedions)\n2-element Vector{Int64}:\n  85\n 101\n\njulia> intensities(chrom_binnedions)\n3×2 Matrix{Int64}:\n 24   12\n  0  956\n 23    1\n\n\njulia> custom_ionbin(ion) = integer(ion, start=0.9);\n\njulia> chrom_binnedions = binions(chrom, ionbin=custom_ionbin)\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n3 ions: m/z 84, 85, 101\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> ions(chrom_binnedions)\n3-element Vector{Int64}:\n  84\n  85\n 101\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.integer","page":"Basics","title":"JuChrom.integer","text":"integer(value::Real; start::Real=0.7) -> Int\n\nReturn the integer for the given value that satisfies the following condition:  integer - 1 + start ≤ value < integer + start, where 0 ≤ start < 1.\n\nSee also AbstractChromMS, ChromMS, binions, ions.\n\nExamples\n\njulia> integer(29.7)\n30\n\njulia> integer(30.0)\n30\n\njulia> integer(30.69)\n30\n\njulia> integer(29.7, start=0.8)\n29\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.intensities-Union{Tuple{AbstractChrom}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:Integer}","page":"Basics","title":"JuChrom.intensities","text":"intensities(chrom::AbstractChrom; scanindexrange::OrdinalRange{T, S}) where {T<:Integer, \nS<:Integer}\n\nReturn the intensities. The optional keyword argument scanindexrange lets you select a  subset of scans for which the intensities will be returned. Note that the function will  return either a reference to the intensity vector or a view into the intensity vector,  depending on whether a subset of scans is selected.\n\nSee also AbstractChrom, intensity, minintensity,  maxintensity, scancount.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> intensities(chrom)  # reference to the data structure\n3-element Vector{Int64}:\n 123\n 224\n 103\n\njulia> intensities(chrom)[:]  # a copy of these values\n3-element Vector{Int64}:\n 123\n 224\n 103\n\njulia> intensities(chrom; scanindexrange=2:3)  # view into the data structure\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 224\n 103\n\njulia> intensities(chrom; scanindexrange=2:3)[:]  # a copy of these values\n2-element Vector{Int64}:\n 224\n 103\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensities-Union{Tuple{AbstractChromMS}, Tuple{S2}, Tuple{T2}, Tuple{S1}, Tuple{T1}} where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}","page":"Basics","title":"JuChrom.intensities","text":"intensities(chrom::AbstractChromMS; scanindexrange::OrdinalRange{T1, S1}, \nionindexrange::OrdinalRange{T2, S2}) where {T1<:Integer, S1<:Integer, T2<:Integer, \nS2<:Integer}\n\nReturn the intensities. The optional keyword arguments scanindexrange and ionindexrange  allow you to select specific parts of the intensity matrix to be returned. Note that the  function returns either a reference to the matrix or a view into it, depending on whether  the keyword arguments specify subranges of the matrix.\n\nSee also AbstractChromMS, scancount, ioncount,  minintensity, maxintensity.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensities(chrom)  # reference to the data structure\n3×2 Matrix{Int64}:\n  0   12\n 34  956\n 23    1\n\njulia> intensities(chrom)[:, :]  # a copy of these values\n3×2 Matrix{Int64}:\n  0   12\n 34  956\n 23    1\n\njulia> intensities(chrom, ionindexrange=1:1)  # all intensities of the ion at index 1\n3×1 view(::Matrix{Int64}, 1:3, 1:1) with eltype Int64:\n  0\n 34\n 23\n\njulia> intensities(chrom, ionindexrange=1:1)[:]  # a copy of these values\n3-element Vector{Int64}:\n  0\n 34\n 23\n\njulia> intensities(chrom, scanindexrange=1:1)  # intensities of all ions from scan 1\n1×2 view(::Matrix{Int64}, 1:1, 1:2) with eltype Int64:\n 0  12\n\njulia> intensities(chrom, scanindexrange=1:1)[:]  # a copy of these values\n2-element Vector{Int64}:\n  0\n 12\n\njulia> intensities(chrom, scanindexrange=1:2, ionindexrange=1:2)\n2×2 view(::Matrix{Int64}, 1:2, 1:2) with eltype Int64:\n  0   12\n 34  956\n\njulia> intensities(chrom, scanindexrange=1:2, ionindexrange=1:2)[:, :]\n2×2 Matrix{Int64}:\n  0   12\n 34  956\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChrom, Integer}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChrom, scanindex::Integer)\n\nReturn the intensity for a scan by specifying its scanindex.\n\nSee also AbstractChrom, intensities, minintensity,  maxintensity.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> intensity(chrom, 1)\n123\n\njulia> intensity(chrom, 2)\n224\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChrom, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChrom, time::Unitful.Time; precisetime::Bool=false)\n\nReturn the intensity at a given time. All time units defined in the package Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. By default, the intensity associated with the scan whose timestamp is closest  to the given time is returned. In case of a tie, the intensity of the scan with the  later timestamp is used. If the optional parameter precisetime is set to true, the  specified time must exactly match a timestamp in the vector; otherwise, an error is  thrown.\n\nSee also AbstractChrom, intensities, scantimes,  minscantime, maxscantime.\n\nExamples\n\njulia> chrom = Chrom([1.0, 2.0, 3.0]u\"s\", [123, 224, 103])\nChrom {scan times: Float64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> intensity(chrom, 1.5u\"s\")\n224\n\njulia> intensity(chrom, 1u\"s\", precisetime=true)\n123\n\njulia> intensity(chrom, 1.5u\"s\", precisetime=true)\nERROR: ArgumentError: scantime 1.5 s does not exist\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChromMS, Integer, Integer}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChromMS, scanindex::Integer, ionindex::Integer)\n\nReturn the intensity of an ion in a scan, given the scanindex of the scan and the  ionindex of the ion.\n\nSee also AbstractChromMS, scancount, ions, ioncount.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensity(chrom, 2, 1)\n34\n\njulia> intensity(chrom, 1, 2)\n12\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.intensity-Tuple{AbstractChromMS, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Real}","page":"Basics","title":"JuChrom.intensity","text":"intensity(chrom::AbstractChromMS, time::Unitful.Time, ion::Real; precisetime::Bool=false)\n\nReturn the intensity of an ion at a given time. All time units defined in the package Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. By default, the intensity associated with the scan whose timestamp is closest  to the given time is returned. In case of a tie, the intensity of the scan with the  later timestamp is used. If the optional parameter precisetime is set to true, the  specified time must exactly match a timestamp in the vector; otherwise, an error is  thrown.\n\nSee also AbstractChromMS, intensities, ions, scantimes.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> intensity(chrom, 1.9u\"s\", 85)\n34\n\njulia> intensity(chrom, 2.9u\"s\", 85, precisetime=true)\nERROR: ArgumentError: scantime 2.9 s does not exist\n[...]\n\njulia> intensity(chrom, 3u\"s\", 85, precisetime=true)\n23\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ion-Tuple{AbstractChromMS, Integer}","page":"Basics","title":"JuChrom.ion","text":"ion(chrom::AbstractChromMS, ionindex::Integer)\n\nReturn the ion at the specified ionindex.\n\nSee also AbstractChromMS, ions, ionindex, minion,  maxion, ioncount.\n\nExamples\n\njulia> chrom = ChromMS((1:3)u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> ion(chrom, 1)\n85\n\njulia> ion(chrom, 2)\n100\n\njulia> ion(chrom, 3)\nERROR: BoundsError: attempt to access 2-element Vector{Int64} at index [3]\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ioncount-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.ioncount","text":"ioncount(chrom::AbstractChromMS) -> Int\n\nReturn the number of ions.\n\nSee also AbstractChromMS, ions, ion, minion,  maxion.\n\nExample\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> ioncount(chrom)\n2\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ionindex-Tuple{AbstractChromMS, Real}","page":"Basics","title":"JuChrom.ionindex","text":"ionindex(chrom::AbstractChromMS, ion::Real) -> Int\n\nReturn the index of the specified ion. An error is thrown if the ion does not exist.\n\nSee also AbstractChromMS, ions, ioncount, ion,  minion, maxion, ionscantime, ionscantimeshift.\n\nExamples\n\njulia> chrom = ChromMS((1:3)u\"s\", [85.2f0, 100.1f0], [0 12; 34 956; 23 1]);\n\njulia> ionindex(chrom, 100.1)\n2\n\njulia> ionindex(chrom, 201.1)\nERROR: ArgumentError: ion 201.1 does not exist\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.ionscantime","page":"Basics","title":"JuChrom.ionscantime","text":"ionscantime(δtᵢ::Function, chrom::AbstractChromMS, scanindex::Integer, ionindex::Integer; \ntimeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the time at which an ion was actually scanned, given the scanindex, ionindex,  and a function δtᵢ that computes the time difference between the timestamp of a scan and  the scan time of the ion from the ionindex. The optional parameter timeunit allows you  to specify the unit of the returned scan time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether the unit is  included in the returned value. Note that the timestamp of a scan is assumed to be the time  when the scanning of ion intensities associated with that scan was completed.\n\nSee also AbstractChromMS, scantimes, scantime,  scantimeindex, ions, ionindex, ionscantimeshift,  IonScanOrder, LinearAscending, LinearDescending.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> ionscantime(δtᵢ, chrom, 2, 1)\n2.0 s\n\njulia> ionscantime(δtᵢ, chrom, 2, 2)\n1.5 s\n\njulia> ionscantime(δtᵢ, chrom, 2, 2; timeunit=u\"minute\")\n0.025 minute\n\njulia> ionscantime(δtᵢ, chrom, 2, 2; timeunit=u\"minute\", ustripped=true)\n0.025\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ionscantimeindex","page":"Basics","title":"JuChrom.ionscantimeindex","text":"ionscantimeindex(δtᵢ::Function, chrom::AbstractChromMS, ionindex::Integer, \ntime::Unitful.Time; precisetime::Bool=false) -> Int\n\nReturn the index of the scan where the scan time for the ion is closest to the specified  time, given the ionindex and a function δtᵢ that computes the time difference between  the timestamp of a scan and the scan time of the ion from the ionindex. All time units  defined in the package Unitful.jl (e.g.,  u\"s\", u\"minute\") are supported. In case of a tie, the larger scan index is returned.  If the optional parameter precisetime is set to true, the ion must have been scanned  exactly at the specified time; otherwise, an error is thrown.\n\nSee also AbstractChromMS, scantimeindex, ionscantime,  ionscantimeshift, IonScanOrder, LinearAscending,  LinearDescending, scantimes, scantime, ions,  ion, ionindex.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> ionscantime(δtᵢ, chrom, 2, 2)\n1.5 s\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.5u\"s\")\n2\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.6u\"s\")\n2\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.6u\"s\", precisetime=true)\nERROR: ArgumentError: ion has not been scanned at the time 1.6 s\n[...]\n\njulia> ionscantimeindex(δtᵢ, chrom, 2, 1.5u\"s\", precisetime=true)\n2\n\njulia> ionscantimeindex(δtᵢ, chrom, 1, 1.4u\"s\")\n1\n\njulia> ionscantime(δtᵢ, chrom, 1, 1)\n1.0 s\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ionscantimes","page":"Basics","title":"JuChrom.ionscantimes","text":"ionscantimes(δtᵢ::Function, chrom::AbstractChromMS, ionindex::Integer; \ntimeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the times at which an ion was actually scanned, given the ionindex and a function  δtᵢ that computes the time difference between the timestamp of a scan and the scan time  of the ion from the ionindex. The optional parameter timeunit allows you to specify the  unit for the returned scan times. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value. Note that the timestamp of a scan is assumed to be the time  when the scanning of ion intensities associated with that scan was completed.\n\nSee also AbstractChromMS, ionscantime, ionscantimeshift,  IonScanOrder, LinearAscending, LinearDescending,  scantimes, scantimeindex, ions, ionindex.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> ionscantimes(δtᵢ, chrom, 1)\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 1.0 s\n 2.0 s\n 3.0 s\n\njulia> ionscantimes(δtᵢ, chrom, 2)\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 0.5 s\n 1.5 s\n 2.5 s\n\njulia> ionscantimes(δtᵢ, chrom, 2; timeunit=u\"minute\")\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 0.008333333333333333 minute\n                0.025 minute\n 0.041666666666666664 minute\n\njulia> ionscantimes(δtᵢ, chrom, 2; timeunit=u\"minute\", ustripped=true)\n3-element Vector{Float64}:\n 0.008333333333333333\n 0.025\n 0.041666666666666664\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ionscantimeshift","page":"Basics","title":"JuChrom.ionscantimeshift","text":"ionscantimeshift(chrom::AbstractChromMS, ionscanorder::IonScanOrder; error::Real=0.001)\n\nReturn a function, based on the ionscanorder, that calculates the time difference between  the timestamp of a scan and the time when an ion was actually scanned, given the ion index  as an argument. The time difference will be zero or negative, since the timestamp of a scan  is considered to be when the scanning of the last ion was completed. The returned function  assumes that the duration of each scan is consistent throughout the run. The optional  keyword argument error lets you specify the maximum allowed deviation of the scan  duration, as a fraction of the average scan time, between the timestamps of two consecutive  scans.\n\nSee also AbstractChromMS, IonScanOrder, LinearAscending,  LinearDescending, ionscantime, ions, minion,  maxion, ioncount, scanduration, scantimes,  minscantime, maxscantime.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.0 s, 2.0 s, 3.0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearAscending());\n\njulia> δtᵢ(1)\n-0.5 s\n\njulia> δtᵢ(2)\n0.0 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending());\n\njulia> δtᵢ(1)\n0.0 s\n\njulia> δtᵢ(2)\n-0.5 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending(start=0.5));\n\njulia> δtᵢ(1)\n0.0 s\n\njulia> δtᵢ(2)\n-0.25 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending(stop=0.5));\n\njulia> δtᵢ(1)\n-0.5 s\n\njulia> δtᵢ(2)\n-0.75 s\n\njulia> δtᵢ = ionscantimeshift(chrom, LinearDescending(start=0.25, stop=0.75));\n\njulia> δtᵢ(1)\n-0.25 s\n\njulia> δtᵢ(2)\n-0.5 s\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.ions-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.ions","text":"ions(chrom::AbstractChromMS)\n\nReturn the ions.\n\nSee also AbstractChromMS, ioncount, ion, minion,  maxion, ionindex, ionscantime, ionscantimeshift. \n\nIn the following examples, the type of ions is explicitely annotated to demonstrate that  the ChromMS object preserves this type.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", Int64[85, 100], [0 12; 34 956; 23 1]);\n\njulia> ions(chrom)\n2-element Vector{Int64}:\n  85\n 100\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", Float32[85, 100], [0 12; 34 956; 23 1]);\n\njulia> ions(chrom)\n2-element Vector{Float32}:\n  85.0\n 100.0\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxintensity-Union{Tuple{AbstractChrom}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:Integer}","page":"Basics","title":"JuChrom.maxintensity","text":"maxintensity(chrom::AbstractChrom[; scanindexrange::OrdinalRange{T, S}]) \nwhere {T<:Integer, S<:Integer})\n\nReturn the minimum intensity. The optional keyword argument scanindexrange allows you to  specify a range of scans from which the minimum intensity is determined.\n\nSee also AbstractChrom, minintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [12, 1, 956]);\n\njulia> maxintensity(chrom)\n956\n\njulia> maxintensity(chrom, scanindexrange=1:2)\n12\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxintensity-Union{Tuple{AbstractChromMS}, Tuple{S2}, Tuple{T2}, Tuple{S1}, Tuple{T1}} where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}","page":"Basics","title":"JuChrom.maxintensity","text":"maxintensity(chrom::AbstractChromMS[; scanindexrange::OrdinalRange{T1, S1}, \nionindexrange::OrdinalRange{T2, S2}]) where {T1<:Integer, S1<:Integer, \nT2<:Integer, S2<:Integer})\n\nReturn the maximum intensity. The optional keyword arguments scanindexrange and  ionindexrange allow you to select a range of scans and ions from which the minimum  intensity is determined.\n\nSee also AbstractChromMS, minintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 1; 23 956]);\n\njulia> maxintensity(chrom)\n956\n\njulia> maxintensity(chrom, scanindexrange=1:2)\n34\n\njulia> maxintensity(chrom, ionindexrange=1:1)\n34\n\njulia> maxintensity(chrom, scanindexrange=1:2, ionindexrange=2:2)\n12\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxion-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.maxion","text":"maxion(chrom::AbstractChromMS)\n\nReturn the largest ion.\n\nSee also AbstractChromMS, minion, ions, ion,  ioncount.\n\nExample\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> maxion(chrom)\n100\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.maxscantime","page":"Basics","title":"JuChrom.maxscantime","text":"maxscantime(chrom::AbstractChromatogram[, scanindexrange::OrdinalRange{<:Integer, \n<:Integer}]; timeunit::Unitful.TimeUnits, ustripped::Bool)\n\nReturn the maximum scan time. The optional second positional argument allows you to  specify the scan range for which the maximum scan time is returned. The optional keyword  argument timeunit lets you change the unit of the returned scan time. All time units  defined in the package Unitful.jl (e.g.,  u\"s\", u\"minute\") are supported. The optional keyword argument ustripped lets you choose  whether to include the unit in the returned value.\n\nSee also AbstractChromatogram, minscantime, scantimes,  scantime,scancount.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> maxscantime(chrom)\n3.0 s\n\njulia> maxscantime(chrom, timeunit=u\"minute\")\n0.05 minute\n\njulia> maxscantime(chrom, timeunit=u\"minute\", ustripped=true)\n0.05\n\njulia> maxscantime(chrom, 1:2)\n2.0 s\n\njulia> maxscantime(chrom, 1:2, timeunit=u\"minute\", ustripped=true)\n0.03333333333333333\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.metadata-Tuple{AbstractChromatogram}","page":"Basics","title":"JuChrom.metadata","text":"metadata(chrom::AbstractChromatogram) -> Dict{Any, Any}\n\nReturn the metadata.\n\nSee also AbstractChromatogram.\n\nExamples\n\njulia> chrom₁ = ChromMS(Int64[1, 2]u\"s\", Int64[85, 100], Int64[0 12; 34 956], Dict(:id => 4))\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 1 entry\n\njulia> metadata(chrom₁)\nDict{Any, Any} with 1 entry:\n  :id => 4\n\njulia> chrom₂ = ChromMS(Int64[1, 2]u\"s\", Int64[85, 100], Int64[0 12; 34 956])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> metadata(chrom₂)\nDict{Any, Any}()\n\njulia> metadata(chrom₂)[\"name\"] = \"sample\"\n\"sample\"\n\njulia> metadata(chrom₂)[:id] = 123\n123\n\njulia> metadata(chrom₂)\nDict{Any, Any} with 2 entries:\n  \"name\" => \"sample\"\n  :id    => 123\n\njulia> chrom₂\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 2 entries\n\njulia> delete!(metadata(chrom₂), \"name\")\nDict{Any, Any} with 1 entry:\n  :id => 123\n\njulia> chrom₂\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n2 scans; scan times: 1 s, 2 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 1 entry\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minintensity-Union{Tuple{AbstractChrom}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:Integer}","page":"Basics","title":"JuChrom.minintensity","text":"minintensity(chrom::AbstractChrom[, greaterthan::Real; \nscanindexrange::OrdinalRange{T, S}]) where {T<:Integer, S<:Integer})\n\nReturn the minimum intensity. The optional positional argument greaterthan allows you to  specify a threshold value; the returned minimum intensity will be greater than this  threshold. If no intensity exceeds the specified value, nothing is returned. The optional  keyword argument scanindexrange allows you to specify a range of scans from which the  minimum intensity is determined.\n\nSee also AbstractChrom, maxintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [12, 956, 1]);\n\njulia> minintensity(chrom)\n1\n\njulia> minintensity(chrom, 1)\n12\n\njulia> minintensity(chrom, scanindexrange=1:2)\n12\n\njulia> minintensity(chrom, 1, scanindexrange=2:3)\n956\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minintensity-Union{Tuple{AbstractChromMS}, Tuple{S2}, Tuple{T2}, Tuple{S1}, Tuple{T1}} where {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer}","page":"Basics","title":"JuChrom.minintensity","text":"minintensity(chrom::AbstractChromMS[, greaterthan::Real; \nscanindexrange::OrdinalRange{T1, S1}, ionindexrange::OrdinalRange{T2, S2}]) \nwhere {T1<:Integer, S1<:Integer, T2<:Integer, S2<:Integer})\n\nReturn the minimum intensity. The optional positional argument greaterthan allows you to  specify a threshold value; the returned minimum intensity will be greater than this  threshold. If no intensity exceeds the specified value, nothing is returned. The optional  keyword arguments scanindexrange and ionindexrange allow you to select a range of scans and ions from which the minimum intensity is determined.\n\nSee also AbstractChromMS, maxintensity, intensities,  intensity.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> minintensity(chrom)\n0\n\njulia> minintensity(chrom, 0)\n1\n\njulia> minintensity(chrom, scanindexrange=2:3)\n1\n\njulia> minintensity(chrom, ionindexrange=1:1)\n0\n\njulia> minintensity(chrom, scanindexrange=2:3, ionindexrange=1:1)\n23\n\njulia> minintensity(chrom, 25, scanindexrange=2:3, ionindexrange=1:1)\n34\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minion-Tuple{AbstractChromMS}","page":"Basics","title":"JuChrom.minion","text":"minion(chrom::AbstractChromMS)\n\nReturn the smallest ion.\n\nSee also AbstractChromMS, maxion, ions, ion,  ioncount.\n\nExample\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> minion(chrom)\n85\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.minscantime","page":"Basics","title":"JuChrom.minscantime","text":"minscantime(chrom::AbstractChromatogram[, scanindexrange::OrdinalRange{<:Integer, \n<:Integer}}]; timeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the minimum scan time. The optional second positional argument scanindexrange  allows you to specify a scan range for which the minimum scan time is returned. The  optional keyword argument timeunit lets you change the unit of the returned scan time.  All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also AbstractChromatogram, maxscantime, scantimes,  scantime, scancount.\n\nExamples\n\njulia> chrom = ChromMS([1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> minscantime(chrom)\n1.0 s\n\njulia> minscantime(chrom, timeunit=u\"minute\")\n0.016666666666666666 minute\n\njulia> minscantime(chrom, timeunit=u\"minute\", ustripped=true)\n0.016666666666666666\n\njulia> minscantime(chrom, 2:3)\n2.0 s\n\njulia> minscantime(chrom, 2:3, timeunit=u\"minute\", ustripped=true)\n0.03333333333333333\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.rimapper-Tuple{AbstractChromatogram}","page":"Basics","title":"JuChrom.rimapper","text":"rimapper(chrom::AbstractChromatogram)\n\nReturn the retention index mapper object. If no object is stored, the function returns  nothing.\n\nSee also AbstractChromatogram, AbstractRiMapper, RiMapper.\n\nExample\n\njulia> chrom = Chrom([1, 2, 3, 4, 5]u\"s\", [12, 956, 23, 45, 25]);\n\njulia> rimapper(chrom) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> chrom = Chrom([1, 2, 3, 4, 5]u\"s\", [12, 956, 23, 45, 25], rimapper=ld);\n\njulia> rimapper(chrom)\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.rimapper!-Tuple{AbstractChromatogram, AbstractRiMapper}","page":"Basics","title":"JuChrom.rimapper!","text":"rimapper!(chrom::AbstractChromatogram, rim::AbstractRiMapper)\n\nAssign an retention index mapper to the AbstractChromatogram object.\n\nSee also AbstractChromatogram, AbstractRiMapper, RiMapper.\n\nExample\n\njulia> chrom = Chrom([1, 2, 3, 4, 5]u\"s\", [12, 956, 23, 45, 25]);\n\njulia> rimapper(chrom) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> rimapper!(chrom, ld);\n\njulia> rimapper(chrom)\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\njulia> retentionindex(chrom, 2.2u\"minute\") ≈ 2200.0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#JuChrom.runduration","page":"Basics","title":"JuChrom.runduration","text":"runduration(chrom::AbstractChromatogram; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the duration of the run. The optional keyword argument timeunit lets you specify  the unit for the returned time interval. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include  the unit in the returned value.\n\nSee also AbstractChromatogram, scantimes, minscantime,  maxscantime, scancount.\n\nExamples\n\njulia> chrom = Chrom([30.1u\"minute\", 40.8u\"minute\", 51.5u\"minute\"], [12, 956, 23])\nChrom {scan times: Float64, intensities: Int64}\n3 scans; scan times: 30.1 minute, 40.8 minute, 51.5 minute\nintensity range: 12 - 956\nmetadata: 0 entries\n\njulia> runduration(chrom)\n21.4 minute\n\njulia> runduration(chrom, timeunit=u\"s\")\n1284.0 s\n\njulia> runduration(chrom, timeunit=u\"s\", ustripped=true)\n1284.0\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scancount","page":"Basics","title":"JuChrom.scancount","text":"scancount(chrom::AbstractChromatogram) -> Int\n\nReturn the number of scans.\n\nSee also AbstractChromatogram, scantimes.\n\nExample\n\njulia> chrom = Chrom([1, 2, 3]u\"s\", [12, 956, 23]);\n\njulia> scancount(chrom)\n3\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scanduration","page":"Basics","title":"JuChrom.scanduration","text":"scanduration(chrom::AbstractChromatogram; error::Real=0.01, \ntimeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nCalculates the periodicity with which the scans were recorded over time. The optional  keyword argument error allows you to specify the maximum allowable deviation of the  time interval between consecutive scans from the average scan time, as a fraction of  the average scan time. The optional keyword argument timeunit lets you specify the unit  for the returned value. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether the unit is  include in the returned value.\n\nSee also AbstractChromatogram, scantimes, minscantime,  maxscantime, scancount, runduration.\n\nExamples\n\njulia> chrom = Chrom([1.0, 2.0, 3.0]u\"s\", [12, 956, 1]);\n\njulia> scanduration(chrom)\n1.0 s\n\njulia> scanduration(chrom, timeunit=u\"minute\")\n0.016666666666666666 minute\n\njulia> scanduration(chrom, timeunit=u\"minute\", ustripped=true)\n0.016666666666666666\n\njulia> scanduration(Chrom([1.0, 1.99, 3.0]u\"s\", [12, 956, 1]))\nERROR: ArgumentError: maximum scan duration variation above threshold: 0.010000000000000009 > 0.01\n[...]\n\njulia> scanduration(Chrom([1.0, 1.99, 3.0]u\"s\", [12, 956, 1]), error=0.02)\n1.0 s\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scantime","page":"Basics","title":"JuChrom.scantime","text":"scantime(chrom::AbstractChromatogram, scanindex::Integer; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the scan time for a given scanindex. The optional parameter timeunit lets you  specify the unit for the returned scan time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether the unit is  included in the returned value.\n\nSee also AbstractChromatogram, scantimes, minscantime,  maxscantime, scancount, ionscantime.\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> scantime(chrom, 2)\n2 s\n\njulia> scantime(chrom, 2, timeunit=u\"minute\")\n1//30 minute\n\njulia> scantime(chrom, 2, timeunit=u\"minute\", ustripped=true)\n1//30\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scantimeindex","page":"Basics","title":"JuChrom.scantimeindex","text":"scantimeindex(chrom::AbstractChromatogram, time::Unitful.Time; \nprecisetime::Bool=false) -> Int\n\nReturn the index of the scan time closest to time in the scan times. All time units  defined in the package Unitful.jl (e.g.,  u\"s\", u\"minute\") are supported. In case of a tie, the larger scan time is returned. If  the optional parameter precisetime is set to true, the specified time must exactly match  a scan time value; otherwise, an error is thrown.\n\nSee also AbstractChromatogram, scantimes, scantime,  minscantime, maxscantime, scancount, ionindex.\n\nExamples\n\njulia> chrom = ChromMS([1.1f0, 2.1f0, 3.1f0]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Float32, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.1f0 s, 2.1f0 s, 3.1f0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> scantimeindex(chrom, 1.1f0u\"s\", precisetime=true)\n1\n\njulia> scantimeindex(chrom, 2.1u\"s\", precisetime=true)\n2\n\njulia> scantimeindex(chrom, 2.2u\"s\", precisetime=true)\nERROR: ArgumentError: scantime 2.2 s does not exist\n[...]\n\njulia> scantimeindex(chrom, 2.2u\"s\")\n2\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.scantimes","page":"Basics","title":"JuChrom.scantimes","text":"scantimes(chrom::AbstractChromatogram[, scanindexrange::OrdinalRange{<:Integer, \n<:Integer}]; timeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the scan times. The optional second positional argument allows you to specify a  range of scan indices. The optional keyword argument timeunit lets you change the unit of  the returned scan times. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned values. Note: If no time unit conversion is applied and the unit is  not stripped, the function returns a reference to or a view into the data structure.\n\nSee also AbstractChromatogram, scantime, minscantime,  maxscantime, scancount.\n\nIn the following example, the type of scantimes is explicitely annotated to demonstrate  that the ChromMS object preserves this type.\n\nExample\n\njulia> chrom = ChromMS(Float32[1.0, 2.0, 3.0]u\"s\", [85, 100], [0 12; 34 956; 23 1]);\n\njulia> scantimes(chrom)  # reference to the data structure\n3-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 1.0f0 s\n 2.0f0 s\n 3.0f0 s\n\njulia> scantimes(chrom, timeunit=u\"minute\")\n3-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 0.016666668f0 minute\n 0.033333335f0 minute\n 0.050000004f0 minute\n\njulia> scantimes(chrom, timeunit=u\"minute\", ustripped=true)\n3-element Vector{Float32}:\n 0.016666668\n 0.033333335\n 0.050000004\n\njulia> scantimes(chrom, 2:3)  # view into the data structure\n2-element view(::Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}, 2:3) with eltype Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}:\n 2.0f0 s\n 3.0f0 s\n\njulia> scantimes(chrom, 2:3)[:]  # a copy of these values\n2-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 2.0f0 s\n 3.0f0 s\n\njulia> scantimes(chrom, 2:3, timeunit=u\"minute\", ustripped=true)\n2-element Vector{Float32}:\n 0.033333335\n 0.050000004\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#JuChrom.totalionchromatogram","page":"Basics","title":"JuChrom.totalionchromatogram","text":"totalionchromatogram(chrom::ChromMS)\n\nCompute the total ion chromatrogram.\n\nSee also ChromMS, scantimes, intensities, metadata.\n\nIn the following example, the type of the intensities is explicitely annotated to  demonstrate that the returned Chrom object preserves this type.\n\nExample\n\njulia> chrom = ChromMS((1.1f0:3.1f0)u\"s\", [85, 100], Int64[0 12; 34 956; 23 1])\nChromMS {scan times: Float32, ions: Int64, intensities: Int64}\n3 scans; scan times: 1.1f0 s, 2.1f0 s, 3.1f0 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> tic = totalionchromatogram(chrom)\nChrom {scan times: Float32, intensities: Int64}\n3 scans; scan times: 1.1f0 s, 2.1f0 s, 3.1f0 s\nintensity range: 12 - 990\nmetadata: 0 entries\n\njulia> intensities(tic)\n3-element Vector{Int64}:\n  12\n 990\n  24\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#Base","page":"Base","title":"Base","text":"","category":"section"},{"location":"internals/base/","page":"Base","title":"Base","text":"JuChrom.bsplineinterpolation\nJuChrom.piecewiselinearinterpolation\nJuChrom.copy_with_eltype\nJuChrom.findclosest\nJuChrom.invert\nJuChrom.name\nJuChrom.rt2ri","category":"page"},{"location":"internals/base/#JuChrom.bsplineinterpolation","page":"Base","title":"JuChrom.bsplineinterpolation","text":"bsplineinterpolation(retentiontimes::AbstractVector{<:Unitful.Time}, \nretentionindices::AbstractVector{<:Real}; extrapolation::Bool=false, force::Bool=false)\n\nReturn a function that maps retention time to a retention index. The function uses a  B-spline for interpolation calculated from a vector of retention times and a corresponding  vector of retention indices. For retention time values outside the range used to  compute the B-spline, the function employs linear extrapolation to estimate a retention  index. However, an optional keyword argument, extrapolation, can be used to disable  extrapolation, in which case the function returns nothing for values outside the retention  time range. The function will raise an error if the resulting mapping function does not  produce continuously increasing values. However, by setting the force keyword argument to  true, the function will return a mapping function even if it does not yield continuously  increasing values. This can be useful for identifying problematic or erroneous calibration  points.\n\nSee also scantimes, retentionindices.\n\nExamples\n\njulia> rts, ris = (1:8)*u\"s\", [1000, 1800, 3050, 3800, 5500, 6600, 6900, 7400];\n\njulia> rt2ri = JuChrom.bsplineinterpolation(rts, ris);\n\njulia> rt2ri(1u\"s\") ≈ 1000.0\ntrue\n\njulia> rt2ri(1.5u\"s\") ≈ 1333.7469941600825\ntrue\n\njulia> rt2ri((1//30)u\"minute\") ≈ 1800.0\ntrue\n\njulia> rt2ri(9.1u\"s\") ≈ 7950.0\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> rt2ri = JuChrom.bsplineinterpolation(rts, ris; extrapolation=true);\n\njulia> rt2ri(9.1u\"s\") ≈ 8053.1226382686355\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.piecewiselinearinterpolation","page":"Base","title":"JuChrom.piecewiselinearinterpolation","text":"piecewiselinearinterpolation(retentiontimes::AbstractVector{<:Unitful.Time}, \nretentionindices::AbstractVector{<:Real}; extrapolation::Bool=false) -> Float64\n\nReturn a function that maps retention time to retention index using piecewise linear  interpolation based on a vector of retention times and a corresponding vector of retention  indices. For retention time values outside the interpolation range, the function applies  linear extrapolation to estimate the retention index. However, an optional extrapolation  keyword can disable extrapolation, in which case the function will raise an error for  values outside the retention time range.\n\nSee also scantimes, retentionindices.\n\nExamples\n\njulia> rts, ris = (1:8)*u\"s\", [1000, 1800, 3050, 3800, 5500, 6600, 6900, 7400];\n\njulia> rt2ri = JuChrom.piecewiselinearinterpolation(rts, ris);\n\njulia> rt2ri(1u\"s\") ≈ 1000.0\ntrue\n\njulia> rt2ri(1.5u\"s\") ≈ 1400.0\ntrue\n\njulia> rt2ri((1//30)u\"minute\") ≈ 1800.0\ntrue\n\njulia> rt2ri(9.1u\"s\")\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> rt2ri = JuChrom.piecewiselinearinterpolation(rts, ris; extrapolation=true);\n\njulia> rt2ri(9.1u\"s\") ≈ 7950.0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.copy_with_eltype","page":"Base","title":"JuChrom.copy_with_eltype","text":"JuChrom.copy_with_eltype(array::AbstractArray, elementtype::Type)\n\nCreate a mutable copy of the array with the type of its elements converted to  elementtype.\n\nExamples\n\njulia> JuChrom.copy_with_eltype(Int[1, 2, 3, 4, 5, 6], Float64)\n6-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n 5.0\n 6.0\n\njulia> JuChrom.copy_with_eltype(Float64[1, 2, 3, 4, 5, 6], Int32)\n6-element Vector{Int32}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> JuChrom.copy_with_eltype(Float64[1.1, 2, 3, 4, 5, 6], Int32)\nERROR: InexactError: Int32(1.1)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.findclosest","page":"Base","title":"JuChrom.findclosest","text":"JuChrom.findclosest(A::AbstractVector{<:Number}, x::Number) -> Int\n\nReturn the index of the number closest to x in a list A of numbers sorted in ascending  order. If case of a tie, the index of the larger number is returned.\n\nExamples\n\njulia> JuChrom.findclosest([-2, -1, 0, 1, 2, 3, 4, 5], 0)\n3\n\njulia> JuChrom.findclosest([-2, -1, 0, 1, 2, 3, 4, 5], 1.5)\n5\n\njulia> JuChrom.findclosest([-2, -1, 0, 1, 2, 3, 4, 5], -1.5)\n2\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.invert","page":"Base","title":"JuChrom.invert","text":"JuChrom.invert(dictionary::Dict)\n\nReturn a dictionary where the values from the input dictionary become the keys. Each key  in the returned dictionary maps to a list of all original keys from dictionary that were  associated with that value.\n\nExample\n\njulia> d = Dict(:a => 1.0, :b => 2.0, :c => 2.0, :d => 1.0)\nDict{Symbol, Float64} with 4 entries:\n  :a => 1.0\n  :b => 2.0\n  :d => 1.0\n  :c => 2.0\n\njulia> JuChrom.invert(d)\nDict{Float64, Vector{Symbol}} with 2 entries:\n  2.0 => [:b, :c]\n  1.0 => [:a, :d]\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.name","page":"Base","title":"JuChrom.name","text":"JuChrom.name(::Type)\n\nReturn the name of the type.\n\nExample\n\njulia> chrom = ChromMS(Int32[1, 2, 3]u\"s\", Int64[85, 100], Int32[0 12; 34 956; 23 1]);\n\njulia> JuChrom.name(typeof(chrom))\nChromMS\n\n\n\n\n\n","category":"function"},{"location":"internals/base/#JuChrom.rt2ri","page":"Base","title":"JuChrom.rt2ri","text":"JuChrom.rt2ri(mapper::RiMapper)\n\nReturn the function that maps a retention time to its corresponding retention index.  Note that direct use of this function is discouraged; users are encouraged to use the  more versatile function retentionindex instead.\n\nSee also RiMapper, retentionindex.\n\nExample\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> JuChrom.rt2ri(ld)(1.5u\"minute\") ≈ 1260.5733082706768\ntrue\n\njulia> JuChrom.rt2ri(ld)(1u\"minute\") ≈ 821.4487832484438\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/export/#Data-Export","page":"Data Export","title":"Data Export","text":"","category":"section"},{"location":"man/export/","page":"Data Export","title":"Data Export","text":"DelimitedText\nExcel\nexportdata(::AbstractChrom, ::AbstractString, ::FileFormat; ::Unitful.TimeUnits, ::Bool)\nexportdata(::AbstractChromMS, ::AbstractString, ::FileFormat; ::Unitful.TimeUnits, ::Bool)","category":"page"},{"location":"man/export/#JuChrom.InputOutput.DelimitedTextWriter.DelimitedText","page":"Data Export","title":"JuChrom.InputOutput.DelimitedTextWriter.DelimitedText","text":"DelimitedText(; delim::Union{AbstractChar, AbstractString}=\"\\t\") <: Fileformat\n\nReturn a DelimitedText file format object. The optional delim keyword argument allows  you to specify the column delimiter, which can be either a single character or a string.  If the provided filename lacks a suffix, an appropriate one will be automatically appended.\n\nSee also FileFormat, exportdata.\n\nExamples\n\njulia> DelimitedText()\nDelimitedText{String}(\"\t\")\n\njulia> DelimitedText(delim=';')\nDelimitedText{Char}(';')\n\n\n\n\n\n","category":"type"},{"location":"man/export/#JuChrom.InputOutput.ExcelWriter.Excel","page":"Data Export","title":"JuChrom.InputOutput.ExcelWriter.Excel","text":"Excel(; sheetname::AbstractString) <: FileFormat\n\nReturns an Excel file format object. The optional keyword argument sheetname allows you  to specify the name of the sheet to operate on.\n\nSee also FileFormat, exportdata.\n\nExamples\n\njulia> Excel()\nExcel{Nothing}(nothing)\n\njulia> Excel(sheetname=\"TIC\")\nExcel{String}(\"TIC\")\n\n\n\n\n\n","category":"type"},{"location":"man/export/#JuChrom.InputOutput.exportdata-Tuple{AbstractChrom, AbstractString, FileFormat}","page":"Data Export","title":"JuChrom.InputOutput.exportdata","text":"exportdata(chrom::AbstractChrom, file::AbstractString, fileformat::FileFormat; \ntimeunit::Unitful.TimeUnits, overwrite::Bool=false)\n\nExport the scan times and corresponding intensity values from the AbstractChrom object to a  file in the specified format. If the AbstractChrom object includes a RiMapper, it will also  export retention indices to the file. The optional timeunit parameter allows you to  define the unit of measurement for the scan times in the output. All time units supported  by the package Unitful.jl (e.g., u\"s\",  u\"minute\") can be used. Additionally, the optional overwrite keyword argument specifies  whether an existing target file should be overwritten.\n\nSee also AbstractChrom, DelimitedText, Excel.\n\nExamples\n\njulia> chrom = Chrom((1:3)u\"minute\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 minute, 2 minute, 3 minute\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> exportdata(chrom, \"./delimtest\", DelimitedText());\n\njulia> exportdata(chrom, \"./exceltest\", Excel(sheetname=\"TIC\"));\n\n\n\n\n\n\n","category":"method"},{"location":"man/export/#JuChrom.InputOutput.exportdata-Tuple{AbstractChromMS, AbstractString, FileFormat}","page":"Data Export","title":"JuChrom.InputOutput.exportdata","text":"exportdata(chrom::AbstractChromMS, file::AbstractString, fileformat::FileFormat; \ntimeunit::Unitful.TimeUnits, overwrite::Bool=false)\n\nExport the scan times, ions, and corresponding intensity values from the AbstractChromMS  object to a file in the specified format. If the AbstractChromMS object includes a  RiMapper, it will also export retention indices to the file. The optional timeunit  parameter allows you to define the unit of measurement for the scan times in the output.  All time units supported by the package  Unitful.jl (e.g., u\"s\", u\"minute\") can be  used. Additionally, the optional overwrite keyword argument specifies whether an existing  target file should be overwritten.\n\nSee also AbstractChromMS, DelimitedText, Excel.\n\nExamples\n\njulia> chrom = Chrom((1:3)u\"minute\", [123, 224, 103])\nChrom {scan times: Int64, intensities: Int64}\n3 scans; scan times: 1 minute, 2 minute, 3 minute\nintensity range: 103 - 224\nmetadata: 0 entries\n\njulia> exportdata(chrom, \"./delimtest\", DelimitedText());\n\njulia> exportdata(chrom, \"./exceltest\", Excel(sheetname=\"GCMS\"));\n\n\n\n\n\n\n","category":"method"},{"location":"man/import/#Data-Import","page":"Data Import","title":"Data Import","text":"","category":"section"},{"location":"man/import/","page":"Data Import","title":"Data Import","text":"FileFormat\nAgilentFID\nANDI\nChemStationMS\nMassHunterMS\nShimadzuMS\nimportdata","category":"page"},{"location":"man/import/#JuChrom.InputOutput.FileFormat","page":"Data Import","title":"JuChrom.InputOutput.FileFormat","text":"FileFormat\n\nSupertype of all FileFormat implementations.\n\nSee also AgilentFID, ANDI, ChemStationMS,  MassHunterMS.\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.AgilentFIDReaders.AgilentFID","page":"Data Import","title":"JuChrom.InputOutput.AgilentFIDReaders.AgilentFID","text":"AgilentFID(; datafilename::AbstractString=\"FID1A.ch\")\n\nReturns an object representing the AgilentFID file format. The optional keyword argument,  datafilename, allows you to specify a different name for the data file to be read,  instead of the default FID1A.ch. Upper and lower case are not considered when specifying  the data file name. Note that when using the function importdata, the AgilentFID data  reader expects the Agilent .D folder as the source location, with the specified data file  located at the top level of the .D folder. However, you can also provide the full pathname  of the data file directly when using the function importdata, in which case the  datafilename entry in the AgilentFID object is ignored.\n\nSee also FileFormat, importdata.\n\nExamples\n\njulia> AgilentFID()\nAgilentFID{String}(\"FID1A.ch\")\n\njulia> AgilentFID(datafilename=\"fid_data_20240611.ch\")\nAgilentFID{String}(\"fid_data_20240611.ch\")\n\njulia> dfolder = joinpath(JuChrom.agilent, \"ZK_ONUBE_Mix1_11.D\");\n\njulia> chrom = importdata(dfolder, AgilentFID())\nChrom {scan times: Float32, intensities: Float64}\n4151 scans; scan time range: 0.437f0 ms - 830000.44f0 ms\nintensity range: 0.0 - 1.0738316309895832e6\nmetadata: 10 entries\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.ANDIReaders.ANDI","page":"Data Import","title":"JuChrom.InputOutput.ANDIReaders.ANDI","text":"ANDI(; scantimetype::Union{AbstractFloat, Nothing}=Nothing, iontype::Union{\nAbstractFloat, Nothing}=Nothing, intensitytype::Union{AbstractFloat, Nothing}=Nothing)\n\nReturns an object representing the ANDI file format. When using the importdata function,  the ANDI data reader expects the source location to be a netCDF file, which typically has  a .CDF file extension. The keyword arguments scantimetype, iontype, and intensitytype  are provided to address cases where ANDI files may store data as Float64 even though it  was originally collected as Float32. The default type Nothing indicates that no conversion  takes place and the type in which the data is stored is returned. Background: When decimal  numbers are converted to binary floats, they are rounded to the nearest binary fraction  rather than a decimal fraction. This rounding can cause slight changes in the values. If  the data were initially recorded as Float32 and are then converted to Float64, these  changes can become visible. However, the changes can usually be ignored. If one wishes to  convert the float types, the optional scantimetype keyword argument allows the scan times  to be converted to a specified float type. Similarly, the optional keyword arguments  iontype and intensitytype allow the conversion of mass-to-charge ratio values and  intensity values, respectively, to a desired float type. \n\nSee also FileFormat, importdata.\n\nExample\n\njulia> ANDI()\nANDI{Nothing, Nothing, Nothing}(Nothing, Nothing, Nothing)\n\njulia> cdffile = joinpath(JuChrom.andi, \"C7-C40_13_Nov_1.CDF\");\n\njulia> chrom = importdata(cdffile, ANDI())\nChromMS {scan times: Float64, ions: Float32, intensities: Float32}\n5221 scans; scan time range: 191.942 s - 3898.719 s\n5248 ions; range: m/z 29.0 - 562.9\nintensity range: 0.0 - 1.051136e6\nmetadata: 2 entries\n\njulia> scantimes(chrom)[9:11]\n3-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 197.623 s\n 198.33300000000003 s\n 199.043 s\n\njulia> chrom = importdata(cdffile, ANDI(scantimetype=Float32))\nChromMS {scan times: Float32, ions: Float32, intensities: Float32}\n5221 scans; scan time range: 191.942f0 s - 3898.719f0 s\n5248 ions; range: m/z 29.0 - 562.9\nintensity range: 0.0 - 1.051136e6\nmetadata: 2 entries\n\njulia> scantimes(chrom)[9:11]\n3-element Vector{Quantity{Float32, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n 197.623f0 s\n 198.333f0 s\n 199.043f0 s\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.ChemStationMSReaders.ChemStationMS","page":"Data Import","title":"JuChrom.InputOutput.ChemStationMSReaders.ChemStationMS","text":"ChemStationMS(; datafilename::AbstractString=\"data.ms\")\n\nReturns an object representing the ChemStationMS file format. The optional keyword  argument, datafilename, allows you to specify a different name for the data file to be  read, instead of the default data.ms (e.g., datasim.ms). Upper and lower case are not  considered when specifying the data file name. Note that when using the function  importdata, the ChemStationMS data reader expects the Agilent .D folder as the source  location, with the specified data file located at the top level of the .D folder.  However, you can also provide the full pathname of the data file directly when using  the function importdata, in which case the datafilename entry in the ChemStationMS  object is ignored.\n\nSee also FileFormat, importdata.\n\nExamples\n\njulia> ChemStationMS()\nChemStationMS{String}(\"data.ms\")\n\njulia> ChemStationMS(datafilename=\"DATASIM.MS\")\nChemStationMS{String}(\"DATASIM.MS\")\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D\");\n\njulia> chrom = importdata(dfolder, ChemStationMS())\nChromMS {scan times: Float32, ions: Float32, intensities: Int32}\n2405 scans; scan time range: 191941.0f0 ms - 1.899047f6 ms\n5176 ions; range: m/z 29.0 - 562.9\nintensity range: 0 - 1186816\nmetadata: 10 entries\n\njulia> datafile = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D/data.ms\");\n\njulia> chrom = importdata(datafile, ChemStationMS())\nChromMS {scan times: Float32, ions: Float32, intensities: Int32}\n2405 scans; scan time range: 191941.0f0 ms - 1.899047f6 ms\n5176 ions; range: m/z 29.0 - 562.9\nintensity range: 0 - 1186816\nmetadata: 10 entries\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.MassHunterMSReaders.MassHunterMS","page":"Data Import","title":"JuChrom.InputOutput.MassHunterMSReaders.MassHunterMS","text":"MassHunterMS(; scanmethodid::Integer=1, \nscantimetype::Union{AbstractFloat, Nothing}=Nothing, \niontype::Union{AbstractFloat, Nothing}=Nothing, \nintensitytype::Union{AbstractFloat, Nothing}=Nothing\n\nReturn an object representing the MassHunterMS file format. When using the importdata  function, the MassHunterMS data reader expects the source location to be the Agilent .D  folder. The optional scanmethodid keyword argument allows you to specify which scan  method ID data to read, which is particularly useful when multiple scan methods have been  applied simultaneously. The :ScanMethodID and :ScanMethodIDs metadata entries indicate  which scan method ID data was extracted and which scan method IDs are available for a given  run. The keyword arguments scantimetype, iontype, and intensitytype are provided to  address cases where MassHunter files may store data as Float64 even though it was  originally collected as Float32. The default type Nothing indicates that no conversion  takes place and the type in which the data is stored is returned. Background: When decimal  numbers are converted to binary floats, they are rounded to the nearest binary fraction  rather than a decimal fraction. This rounding can cause slight changes in the values. If  the data were initially recorded as Float32 and are then converted to Float64, these  changes can become visible. However, the changes can usually be ignored. If one wishes to  convert the float types, the optional scantimetype keyword argument allows the scan times  to be converted to a specified float type. Similarly, the optional keyword arguments  iontype and intensitytype allow the conversion of mass-to-charge ratio values and  intensity values, respectively, to a desired float type.\n\nSee also FileFormat, importdata, JuChrom.binions.\n\nExamples\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_MassHunterMS.D\");\n\njulia> chrom = importdata(dfolder, MassHunterMS())\nChromMS {scan times: Float64, ions: Float64, intensities: Float64}\n2405 scans; scan time range: 191.941 s - 1899.047 s\n50275 ions; range: m/z 29.020000457763672 - 562.8900146484375\nintensity range: 0.0 - 1.1872475e6\nmetadata: 2 entries\n\njulia> ions(chrom)[1:3]  # ion decimal digits suggest Float32\n3-element Vector{Float64}:\n 29.020000457763672\n 29.030000686645508\n 29.040000915527344\n\njulia> chrom = importdata(dfolder, MassHunterMS(; iontype=Float32))\nChromMS {scan times: Float64, ions: Float32, intensities: Float64}\n2405 scans; scan time range: 191.941 s - 1899.047 s\n50275 ions; range: m/z 29.02 - 562.89\nintensity range: 0.0 - 1.1872475e6\nmetadata: 2 entries\n\njulia> ions(chrom)[1:3]\n3-element Vector{Float32}:\n 29.02\n 29.03\n 29.04\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.ShimadzuMSReaders.ShimadzuMS","page":"Data Import","title":"JuChrom.InputOutput.ShimadzuMSReaders.ShimadzuMS","text":"ShimadzuMS()\n\nReturns an object representing the ShimadzuMS file format. When using the importdata function, the ShimadzuMS data reader expects the source to be a .qgd file.\n\nSee also FileFormat, importdata.\n\nExample\n\njulia> ShimadzuMS()\nShimadzuMS()\n\njulia> qgdfile = joinpath(JuChrom.shimadzu, \"AR190311.qgd\");\n\njulia> chrom = importdata(qgdfile, ShimadzuMS())\nChromMS {scan times: Int32, ions: Float64, intensities: UInt32}\n9210 scans; scan time range: 183000 ms - 2024800 ms\n3620 ions; range: m/z 34.9 - 600.4\nintensity range: 0 - 924954\nmetadata: 0 entries\n\n\n\n\n\n","category":"type"},{"location":"man/import/#JuChrom.InputOutput.importdata","page":"Data Import","title":"JuChrom.InputOutput.importdata","text":"importdata(source::AbstractString, fileformat::FileFormat)\n\nRead data from the specified source using the appropriate file format reader. The source  may be a file or a directory path, depending on the requirements of the chosen file format  reader.\n\nSee also AgilentFID, ANDI, ChemStationMS,  MassHunterMS.\n\nExamples\n\njulia> dfolder = joinpath(JuChrom.agilent, \"C7-C40_ChemStationMS.D\");\n\njulia> chrom = importdata(dfolder, ChemStationMS())\nChromMS {scan times: Float32, ions: Float32, intensities: Int32}\n2405 scans; scan time range: 191941.0f0 ms - 1.899047f6 ms\n5176 ions; range: m/z 29.0 - 562.9\nintensity range: 0 - 1186816\nmetadata: 10 entries\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#Retention-Indices","page":"Retention Indices","title":"Retention Indices","text":"","category":"section"},{"location":"man/retentionindices/","page":"Retention Indices","title":"Retention Indices","text":"PolationMethod\nLinear\nPiecewiseLinear\nNaturalCubicBSpline\nAbstractRiMapper\nRiMapper\nextrapolationmethod\ninterpolationmethod\nmaxretentionindex\nmaxretentiontime\nmetadata(::AbstractRiMapper)\nminretentionindex\nminretentiontime\nretentionindex(::RiMapper, ::Unitful.Time; ::Bool)\nretentionindex(::AbstractChromatogram, ::Unitful.Time; ::Bool)\nretentionindexname(::RiMapper)\nretentionindices\nretentiontimes","category":"page"},{"location":"man/retentionindices/#JuChrom.PolationMethod","page":"Retention Indices","title":"JuChrom.PolationMethod","text":"PolationMethod\n\nSupertype for all data interpolation and extrapolation methods implemented for mapping  retention times to retention indices, and potentially vice versa.\n\nSee also Linear, NaturalCubicBSpline, RiMapper.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.Linear","page":"Retention Indices","title":"JuChrom.Linear","text":"Linear() <: PolationMethod\n\nPolationMethod type that specifies data is linearly extrapolated using the slope  calculated by the applied interpolator at the nearest retention time–retention index  calibration point.\n\nSee also PolationMethod, NaturalCubicBSpline, RiMapper.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.PiecewiseLinear","page":"Retention Indices","title":"JuChrom.PiecewiseLinear","text":"PiecewiseLinear() <: PolationMethod\n\nPolationMethod type that specifies data is interpolated using a piecewise linear approach.\n\nSee also PolationMethod, NaturalCubicBSpline, RiMapper.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.NaturalCubicBSpline","page":"Retention Indices","title":"JuChrom.NaturalCubicBSpline","text":"NaturalCubicBSpline(; force::Bool=false) <: PolationMethod\n\nPolationMethod type that specifies data is interpolated using a natural cubic B-spline.  Application of this type will raise an error if the resulting mapping function does not  produce continuously increasing values. However, by setting the force keyword argument to  true, a mapping function will be returned even if it does not yield continuously increasing  values. This can be useful for identifying problematic or erroneous calibration points.\n\nSee also PolationMethod, NaturalCubicBSpline, RiMapper.\n\nExamples\n\njulia> NaturalCubicBSpline()\nNaturalCubicBSpline(false)\n\njulia> NaturalCubicBSpline(; force=true)\nNaturalCubicBSpline(true)\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.AbstractRiMapper","page":"Retention Indices","title":"JuChrom.AbstractRiMapper","text":"AbstractRiMapper\n\nSupertype for all retention index mapper implementations. All subtypes (e.g., RiMapper)  have fields to store the retention index name and metadata.\n\nSee also RiMapper, retentionindexname, metadata.\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.RiMapper","page":"Retention Indices","title":"JuChrom.RiMapper","text":"RiMapper(retentionindexname::AbstractString, \nretentiontimes::AbstractVector{<:Unitful.Time},\nretentionindices::AbstractVector{<:Real};\ninterpolationmethod::PolationMethod=NaturalCubicBSpline(), \nextrapolationmethod::Union{Nothing, <:PolationMethod}=nothing,\nmetadata::Dict=Dict())\n\nCreate an RiMapper object to map retention times to retention indices using  interpolation, and extrapolation by default. The optional keyword arguments  interpolationmethod and extrapolationmethod allow you to explicitly specify the  methods used. Currently, the available interpolators are NaturalCubicBSpline() (default)  and PiecewiseLinear(). The only available extrapolator is Linear(). If  extrapolationmethod is set to nothing (default), the function will raise an error for  retention time values outside the calibration range. Note that both retention times and  retention indices must be provided in ascending order. Additionally, the optional  metadata keyword argument allows you to associate metadata with the mapper.\n\nSee also AbstractRiMapper, retentionindexname, Linear,  NaturalCubicBSpline, PiecewiseLinear, retentionindices,  retentiontimes, interpolationmethod, extrapolationmethod,  rt2ri, metadata, retentionindex.\n\nExamples\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000)\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\njulia> retentionindex(ld, 1u\"minute\") ≈ 1000.0\ntrue\n\njulia> retentionindex(ld, 1.5u\"minute\") ≈ 1500.0\ntrue\n\njulia> retentionindex(ld, 11u\"minute\") ≈ 11000.0\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> retentionindices(ld)\n1000:1000:5000\n\njulia> retentiontimes(ld)\n(1:5) minute\n\njulia> interpolationmethod(ld)\nNaturalCubicBSpline(false)\n\njulia> extrapolationmethod(ld) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000, extrapolationmethod=Linear())\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: Linear()\nmetadata: 0 entries\n\njulia> retentionindex(ld, 11u\"minute\") === 11000.000000000011\ntrue\n\njulia> extrapolationmethod(ld)\nLinear()\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"s\", 10:10:50, interpolationmethod=PiecewiseLinear())\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 s, 2 s, 3 s, 4 s, 5 s\nretention indices: 10, 20, 30, 40, 50\ninterpolation method: PiecewiseLinear()\nextrapolation method: nothing\nmetadata: 0 entries\n\n\n\n\n\n","category":"type"},{"location":"man/retentionindices/#JuChrom.extrapolationmethod","page":"Retention Indices","title":"JuChrom.extrapolationmethod","text":"extrapolationmethod(mapper::RiMapper)\n\nReturn the name of the extrapolation method. If no extrapolation is applied, the function  returns nothing.\n\nSee also RiMapper, interpolationmethod, retentionindex.\n\nExample\n\njulia> rts, ris = (1:5)u\"minute\", 1000:1000:5000;\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> extrapolationmethod(ld) === nothing\ntrue\n\njulia> ld = RiMapper(\"Kovats\", rts, ris, extrapolationmethod=Linear());\n\njulia> extrapolationmethod(ld)\nLinear()\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.interpolationmethod","page":"Retention Indices","title":"JuChrom.interpolationmethod","text":"interpolationmethod(mapper::RiMapper)\n\nReturn the name of the applied interpolation method.\n\nSee also RiMapper, extrapolationmethod, retentionindex.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> interpolationmethod(ld)\nNaturalCubicBSpline(false)\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.maxretentionindex","page":"Retention Indices","title":"JuChrom.maxretentionindex","text":"maxretentionindex(mapper::RiMapper)\n\nReturn the highest retention index used to construct the retention index mapper.\n\nSee also RiMapper, minretentionindex, retentionindices.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> maxretentionindex(ld)\n5000\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.maxretentiontime","page":"Retention Indices","title":"JuChrom.maxretentiontime","text":"maxretentiontime(chrom::AbstractChromatogram; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the highest retention time used to construct the retention index mapper. The  optional keyword argument timeunit lets you change the unit of the returned retention  time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also RiMapper, maxretentiontime, retentiontimes.\n\nExamples\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> maxretentiontime(ld) ≈ 5u\"minute\"\ntrue\n\njulia> maxretentiontime(ld, timeunit=u\"s\") ≈ 300u\"s\"\ntrue\n\njulia> maxretentiontime(ld, timeunit=u\"s\", ustripped=true) ≈ 300\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.metadata-Tuple{AbstractRiMapper}","page":"Retention Indices","title":"JuChrom.metadata","text":"metadata(mapper::AbstractRiMapper)\n\nReturn the metadata.\n\nSee also AbstractRiMapper, RiMapper.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000, metadata=Dict(:id => 7))\nRiMapper {index name: Kovats, calibration points: 5}\nretention times: 1 minute, 2 minute, 3 minute, 4 minute, 5 minute\nretention indices: 1000, 2000, 3000, 4000, 5000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 1 entry\n\njulia> metadata(ld)\nDict{Any, Any} with 1 entry:\n  :id => 7\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.minretentionindex","page":"Retention Indices","title":"JuChrom.minretentionindex","text":"minretentionindex(mapper::RiMapper)\n\nReturn the lowest retention index used to construct the retention index mapper.\n\nSee also RiMapper, maxretentionindex, retentionindices.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> maxretentionindex(ld)\n5000\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.minretentiontime","page":"Retention Indices","title":"JuChrom.minretentiontime","text":"minretentiontime(chrom::AbstractChromatogram; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the lowest retention time used to construct the retention index mapper. The optional  keyword argument timeunit lets you change the unit of the returned retention time. All  time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also RiMapper, maxretentiontime, retentiontimes.\n\nExamples\n\njulia> ld = RiMapper(\"Kovats\", (1:5)u\"minute\", 1000:1000:5000);\n\njulia> minretentiontime(ld) ≈ 1u\"minute\"\ntrue\n\njulia> minretentiontime(ld, timeunit=u\"s\") ≈ 60u\"s\"\ntrue\n\njulia> minretentiontime(ld, timeunit=u\"s\", ustripped=true) ≈ 60\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.retentionindex-Tuple{RiMapper, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Retention Indices","title":"JuChrom.retentionindex","text":"retentionindex(mapper::RiMapper, retentiontime::Unitful.Time)\n\nReturn the retention index associated with a given retention time.\n\nSee also RiMapper, retentionindices, maxretentionindex,  minretentionindex.\n\nExamples\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris)\nRiMapper {index name: Kovats, calibration points: 4}\nretention times: 1.2 minute, 2.4 minute, 3.8 minute, 5.0 minute\nretention indices: 1000, 2000, 3000, 4000\ninterpolation method: NaturalCubicBSpline(false)\nextrapolation method: nothing\nmetadata: 0 entries\n\njulia> retentionindex(ld, 1.8u\"minute\") ≈ 1516.9172932330828\ntrue\n\njulia> retentionindex(ld, 1.1u\"minute\") ≈ 913.9194139194141\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> ris = retentionindex.(ld, [2, 3]u\"minute\");  # broadcasting across multiple RT values\n\njulia> ris ≈ [1683.3751044277362, 2430.719656283566]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.retentionindex-Tuple{AbstractChromatogram, Union{Quantity{T, 𝐓, U}, Level{L, S, Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Retention Indices","title":"JuChrom.retentionindex","text":"retentionindex(chrom::AbstractChromatogram, retentiontime::Unitful.Time; \ninfo::Bool=false)\n\nReturn the retention index corresponding to a given retention time.\n\nSee also RiMapper, retentionindices, maxretentionindex,  minretentionindex.\n\nExamples\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> chrom = Chrom(Int64[1, 2, 3]u\"s\", Int32[12, 956, 1], rimapper=ld);\n\njulia> retentionindex(chrom, 1.8u\"minute\") ≈ 1516.9172932330828\ntrue\n\njulia> retentionindex(chrom, 1.1u\"minute\") ≈ 913.9194139194141\nERROR: ArgumentError: retention time outside range for calculating retention index\n[...]\n\njulia> ris = retentionindex.(chrom, [2, 3]u\"minute\");  # broadcasting across multiple RT values\n\njulia> ris ≈ [1683.3751044277362, 2430.719656283566]\ntrue\n\njulia> chrom = Chrom(Int64[1, 2, 3]u\"s\", Int32[12, 956, 1]);\n\njulia> retentionindex(chrom, 120u\"s\")\nERROR: ArgumentError: no retention index mapper implemented\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.retentionindexname-Tuple{RiMapper}","page":"Retention Indices","title":"JuChrom.retentionindexname","text":"retentionindexname(mapper::RiMapper)\n\nReturn the retention index name.\n\nSee also AbstractRiMapper, RiMapper.\n\nExample\n\njulia> ld = RiMapper(\"Kovats\", (1:10)u\"minute\", 1000:1000:10000);\n\njulia> retentionindexname(ld)\n\"Kovats\"\n\n\n\n\n\n","category":"method"},{"location":"man/retentionindices/#JuChrom.retentionindices","page":"Retention Indices","title":"JuChrom.retentionindices","text":"retentionindices(mapper::RiMapper)\n\nReturn the retention indices used to construct the retention index mapper. Note: the  function returns a reference to the data structure.\n\nSee also RiMapper, maxretentionindex, minretentionindex,  retentiontimes.\n\nExample\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> retentionindices(ld)  # reference to the data structure\n4-element Vector{Int64}:\n 1000\n 2000\n 3000\n 4000\n\njulia> retentionindices(ld)[:]  # a copy of these values\n4-element Vector{Int64}:\n 1000\n 2000\n 3000\n 4000\n\n\n\n\n\n","category":"function"},{"location":"man/retentionindices/#JuChrom.retentiontimes","page":"Retention Indices","title":"JuChrom.retentiontimes","text":"retentiontimes(mapper::RiMapper; timeunit::Unitful.TimeUnits, ustripped::Bool=false)\n\nReturn the retention times used to construct the retention index mapper. The optional  keyword argument timeunit lets you change the unit of the returned retention times. All  time units defined in the package Unitful.jl  (e.g., u\"s\", u\"minute\") are supported. The optional keyword argument ustripped lets  you choose whether to include the unit in the returned values. Note: If no time unit  conversion is applied and the unit is not stripped, the function returns a reference to the  data structure.\n\nSee also RiMapper, maxretentiontime, minretentiontime,  retentionindices.\n\nExample\n\njulia> rts, ris = [1.2, 2.4, 3.8, 5.0]u\"minute\", [1000, 2000, 3000, 4000];\n\njulia> ld = RiMapper(\"Kovats\", rts, ris);\n\njulia> retentiontimes(ld)  # reference to the data structure\n4-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 1.2 minute\n 2.4 minute\n 3.8 minute\n 5.0 minute\n\njulia> retentiontimes(ld)[:]  # a copy of these values\n4-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(minute,), 𝐓, nothing}}}:\n 1.2 minute\n 2.4 minute\n 3.8 minute\n 5.0 minute\n\njulia> retentiontimes(ld, timeunit=u\"s\")\n4-element Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}:\n  72.0 s\n 144.0 s\n 228.0 s\n 300.0 s\n\njulia> retentiontimes(ld, timeunit=u\"s\", ustripped=true)\n4-element Vector{Float64}:\n  72.0\n 144.0\n 228.0\n 300.0\n\n\n\n\n\n","category":"function"},{"location":"#JuChrom.jl","page":"Home","title":"JuChrom.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for JuChrom.jl","category":"page"},{"location":"man/massspectra/#Mass-Spectra","page":"Mass Spectra","title":"Mass Spectra","text":"","category":"section"},{"location":"man/massspectra/","page":"Mass Spectra","title":"Mass Spectra","text":"AbstractMassSpectrum\nMassSpectrum\ncosine\nintensities(::AbstractMassSpectrum)\nintensity(::AbstractMassSpectrum, ::Integer)\nintensitydifferences\nintensitysums\nion(::AbstractMassSpectrum, ::Integer)\nionindex(::AbstractMassSpectrum, ::Real)\nions(::AbstractMassSpectrum)\nioncount(::AbstractMassSpectrum)\nmassspectrum\nmaxintensity(::AbstractMassSpectrum)\nmaxion(::AbstractMassSpectrum)\nmeanintensities\nmetadata(::AbstractMassSpectrum) \nminintensity(::AbstractMassSpectrum)\nminion(::AbstractMassSpectrum)\nretentionindex(::AbstractMassSpectrum)\nretentionindexname(::AbstractMassSpectrum)\nretentiontime\nsharedions\nsimilarity","category":"page"},{"location":"man/massspectra/#JuChrom.AbstractMassSpectrum","page":"Mass Spectra","title":"JuChrom.AbstractMassSpectrum","text":"AbstractMassSpectrum\n\nSupertype for all mass spectrum implementations. All subtypes (e.g., MassSpectrum)  include fields to store ions, their associated intensities, and optionally, retention time,  retention index, and metadata.\n\nSee also MassSpectrum.\n\n\n\n\n\n","category":"type"},{"location":"man/massspectra/#JuChrom.MassSpectrum","page":"Mass Spectra","title":"JuChrom.MassSpectrum","text":"MassSpectrum(ions::AbstractVector{<:Real}, intensities::AbstractVector{<:Real};\nretentiontime::Union{Unitful.Time, Nothing}=nothing,\nretentionindexname::Union{AbstractString, Nothing}=nothing,\nretentionindex::Union{<:Real, Nothing}=nothing, metadata::Dict=Dict())\n\nConstruct a ChromMS object that includes scantimes, ions, intensities, and  metadata. Note that scantimes and ions must be in ascending order, and intensities  must not contain any values less than zero. The retentiontime must include a time unit.  All time units supported by the  Unitful.jl package(e.g., u\"s\", u\"minute\")  are accepted.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum),  retentiontime(::AbstractMassSpectrum; ::Unitful.TimeUnits, ::Bool),  retentionindexname(::AbstractMassSpectrum),  retentionindex(::AbstractMassSpectrum),  metadata(::AbstractMassSpectrum),  sharedions,  similarity.\n\nExamples\n\njulia> MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67])\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67], retentiontime=3.2u\"minute\")\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nretention time: 3.2 minute\nmetadata: 0 entries\n\njulia> MassSpectrum([1.2, 2.1], [1.1, 8.1], retentionindex=131, retentionindexname=\"Kovats\")\nMassSpectrum {ions: Float64, intensities: Float64}\n2 ions: m/z 1.2, 2.1\nintensity range: 1.1 - 8.1\nretention index: 131 (Kovats)\nmetadata: 0 entries\n\njulia> MassSpectrum([85.1, 112.2, 124.1], [13.0, 0.0, 67.0], metadata=Dict(:name=>\"Hexane\"))\nMassSpectrum {ions: Float64, intensities: Float64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0.0 - 67.0\nmetadata: 1 entry\n\n\n\n\n\n","category":"type"},{"location":"man/massspectra/#JuChrom.cosine","page":"Mass Spectra","title":"JuChrom.cosine","text":"cosine(x::AbstractVector{<:Real}, y::AbstractVector{<:Real})\n\nReturn the angle between two non-zero vectors, which can be considered a measure of the similarity (i.e., cosine similarity) between the two vectors.\n\nSee also similarity.\n\nExamples\n\njulia> cosine([100, 500, 250], [200, 1000, 0]) ≈ 0.8978872704229618\ntrue\n\njulia> cosine([100, 0, 50], [0, 20, 0]) ≈ 0.0\ntrue\n\njulia> cosine([10, 50, 25], [100, 500, 250]) ≈ 1.0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.intensities-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.intensities","text":"intensities(ms::AbstractMassSpectrum)\n\nReturn the intensities.\n\nSee also AbstractMassSpectrum,  intensity(::AbstractMassSpectrum, ::Integer),  maxintensity(::AbstractMassSpectrum),  minintensity(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> intensities(ms)\n3-element Vector{Int64}:\n 13\n  0\n 67\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.intensity-Tuple{AbstractMassSpectrum, Integer}","page":"Mass Spectra","title":"JuChrom.intensity","text":"intensity(ms::AbstractMassSpectrum, ionindex::Integer)\n\nReturn the intensity for an ion by specifying its index.\n\nSee also AbstractMassSpectrum, intensities(::AbstractMassSpectrum),  maxintensity(::AbstractMassSpectrum),  minintensity(::AbstractMassSpectrum).\n\nExamples\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> intensity(ms, 1)\n13\n\njulia> intensity(ms, 2)\n0\n\njulia> intensity(ms, 4)\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\n[...]\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.intensitydifferences","page":"Mass Spectra","title":"JuChrom.intensitydifferences","text":"intensitydifferences(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum)\n\nReturn the intensity difference for each ion in ms₁ and ms₂, with any negative results set  to zero. This function assumes both mass spectra contain data for the same set of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum), intensitysums,  meanintensities.\n\nExamples\n\njulia> ms₁ = MassSpectrum([80, 85, 90], [10, 80, 5]);\n\njulia> ms₂ = MassSpectrum([80, 85, 90], [0, 10, 0]);\n\njulia> intensitydifferences(ms₁, ms₂)\n3-element Vector{Int64}:\n 10\n 70\n  5\n\njulia> intensitydifferences(ms₂, ms₁)\n3-element Vector{Int64}:\n 0\n 0\n 0\n\njulia> ms₃ = MassSpectrum([80, 85, 90], [5.5, 20.1, 5]);\n\njulia> intensitydifferences(ms₁, ms₃) ≈ [4.5, 59.9, 0.0]\ntrue\n\njulia> intensitydifferences(MassSpectrum([80], [5]), MassSpectrum([81], [5]))\nERROR: ArgumentError: mass spectra differ in ions\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.intensitysums","page":"Mass Spectra","title":"JuChrom.intensitysums","text":"intensitysums(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum)\n\nReturn the intensity sums for each ion in ms₁ and ms₂. This function assumes that both mass  spectra contain data for the same set of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum), meanintensities.\n\nExamples\n\njulia> ms₁ = MassSpectrum([80, 85, 90], Int64[0, 10, 0]);\n\njulia> ms₂ = MassSpectrum([80, 85, 90], Int64[10, 80, 5]);\n\njulia> intensitysums(ms₁, ms₂)\n3-element Vector{Int64}:\n 10\n 90\n  5\n\njulia> ms₃ = MassSpectrum([80, 85, 90], Float64[10, 80, 5]);\n\njulia> intensitysums(ms₁, ms₃) ≈ [10.0, 90.0, 5.0]\ntrue\n\njulia> intensitysums(MassSpectrum([80], [5]), MassSpectrum([81], [5]))\nERROR: ArgumentError: mass spectra differ in ions\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.ion-Tuple{AbstractMassSpectrum, Integer}","page":"Mass Spectra","title":"JuChrom.ion","text":"ion(ms::AbstractMassSpectrum, ionindex::Integer)\n\nReturn the ion at the specified ionindex.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), minion(::AbstractMassSpectrum),  ioncount(::AbstractMassSpectrum), ionindex(::AbstractMassSpectrum, ::Real),  sharedions.\n\nExamples\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ion(ms, 1)\n85\n\njulia> ion(ms, 2)\n112\n\njulia> ion(ms, 3)\n124\n\njulia> ion(ms, 4)\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\n[...]\n\njulia> ion.(ms, 1:2)  # broadcasting across multiple ion indices\n2-element Vector{Int64}:\n  85\n 112\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  ionindex(::AbstractMassSpectrum, ::Real),  minion(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum).\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.ionindex-Tuple{AbstractMassSpectrum, Real}","page":"Mass Spectra","title":"JuChrom.ionindex","text":"ionindex(ms::AbstractMassSpectrum, ion::Real) -> Int\n\nReturn the index of the ion. If the ion is not present in the mass spectrum, an error  is raised.\n\nSee also AbstractMassSpectrum, ion(::AbstractMassSpectrum, ::Integer),  ions(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), minion(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum([85.1, 112.0, 124.2], Int64[13, 0, 67])\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.0, 124.2\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ionindex(ms, 124.2)\n3\n\njulia> ionindex(ms, 124)\nERROR: ArgumentError: ion 124 does not exist\n[...]\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer), minion(::AbstractMassSpectrum),  maxion(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum).\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.ions-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.ions","text":"ions(ms::AbstractMassSpectrum)\n\nReturn the ions.\n\nSee also AbstractMassSpectrum, ion(::AbstractMassSpectrum, ::Integer),  maxion(::AbstractMassSpectrum), minion(::AbstractMassSpectrum),  ioncount(::AbstractMassSpectrum),  ionindex(::AbstractMassSpectrum, ::Real),  sharedions.\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ions(ms)\n3-element Vector{Int64}:\n  85\n 112\n 124\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.ioncount-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.ioncount","text":"ioncount(ms::AbstractMassSpectrum) -> Int\n\nReturn the number of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer), ionindex(::AbstractMassSpectrum, ::Real),  minion(::AbstractMassSpectrum), maxion(::AbstractMassSpectrum), sharedions.\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> ioncount(ms)\n3\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.massspectrum","page":"Mass Spectra","title":"JuChrom.massspectrum","text":"massspectrum(chrom::AbstractChromMS, scanindex::Integer; \nretentionindexname::Union{AbstractString, Nothing}=nothing,\nretentionindex::Union{Real, Nothing}=nothing, metadata::Dict=Dict())\n\nReturns a MassSpectrum containing the intensity values for all ions at the specified  scan index. The optional keyword arguments, retentionindexname and retentionindex,  allow the mass spectrum to be associated with a retention index. Note that both  retentionindexname and retentionindex must always be provided together. The optional  keyword argument metadata allows the mass spectrum to be associated with additional  metadata.\n\nSee also AbstractChromMS, MassSpectrum,  ions(::AbstractMassSpectrum), intensities(::AbstractMassSpectrum),  retentiontime(::AbstractMassSpectrum; ::Unitful.TimeUnits, ::Bool).\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2)\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2, retentionindexname=\"Kovats\", retentionindex=123.21)\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nretention index: 123.21 (Kovats)\nmetadata: 0 entries\n\njulia> ms = massspectrum(chrom, 2, metadata=Dict(:compound => \"hexane\"))\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nmetadata: 1 entry\n\njulia> metadata(ms)\nDict{Any, Any} with 1 entry:\n  :compound => \"hexane\"\n\n\n\n\n\nmassspectrum(chrom::AbstractChromMS, time::Unitful.Time; precisetime::Bool=false, \nretentionindexname::Union{AbstractString, Nothing}=nothing,\nretentionindex::Union{Real, Nothing}=nothing, metadata::Dict=Dict())\n\nReturn a MassSpectrum containing the intensity values for all ions in the scan with a  scan time closest to the specified time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. In case of a tie, the larger scan time is selected. If the optional parameter  precisetime is set to true, the specified time must match exactly, otherwise an error  will be thrown. The optional keyword arguments, retentionindexname and retentionindex,  allow the mass spectrum to be associated with a retention index. Note that both  retentionindexname and retentionindex must always be provided together. The optional  keyword argument metadata allows the mass spectrum to be associated with additional  metadata.\n\nSee also AbstractChromMS, MassSpectrum,  ions(::AbstractMassSpectrum), intensities(::AbstractMassSpectrum),  retentiontime(::AbstractMassSpectrum; ::Unitful.TimeUnits, ::Bool).\n\nExamples\n\njulia> chrom = ChromMS([1, 2, 3]u\"s\", [85, 100], [0 12; 34 956; 23 1])\nChromMS {scan times: Int64, ions: Int64, intensities: Int64}\n3 scans; scan times: 1 s, 2 s, 3 s\n2 ions: m/z 85, 100\nintensity range: 0 - 956\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2u\"s\")\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 34 - 956\nretention time: 2 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2.5u\"s\")\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 3.5u\"s\")\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nmetadata: 0 entries\n\njulia> massspectrum(chrom, 2.1u\"s\", precisetime=true)\nERROR: ArgumentError: scantime 2.1 s does not exist\n[...]\n\njulia> massspectrum(chrom, 2.5u\"s\", retentionindexname=\"Kovats\", retentionindex=123.21)\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nretention index: 123.21 (Kovats)\nmetadata: 0 entries\n\njulia> ms = massspectrum(chrom, 2.5u\"s\", metadata=Dict(:compound => \"hexane\"))\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 85, 100\nintensity range: 1 - 23\nretention time: 3 s\nmetadata: 1 entry\n\njulia> metadata(ms)\nDict{Any, Any} with 1 entry:\n  :compound => \"hexane\"\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.maxintensity-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.maxintensity","text":"maxintensity(ms::AbstractMassSpectrum)\n\nReturn the maximum intensity.\n\nSee also AbstractMassSpectrum, minintensity(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum),  intensity(::AbstractMassSpectrum, ::Integer)`](@ref).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> maxintensity(ms)\n67\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.maxion-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.maxion","text":"maxion(ms::AbstractMassSpectrum)\n\nReturn the largest ion.\n\nSee also AbstractMassSpectrum, minion(::AbstractMassSpectrum),  ions(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer),  ionindex(::AbstractMassSpectrum, ::Real).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> maxion(ms)\n124\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.meanintensities","page":"Mass Spectra","title":"JuChrom.meanintensities","text":"meanintensities(mss::AbstractVector{<:AbstractMassSpectrum}) -> Vector{Float64}\n\nReturn a vector of the average intensities for all ions in the provided mass spectra. This  function assumes that each mass spectrum contains data for the same set of ions.\n\nSee also AbstractMassSpectrum, ions(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum), intensitydifferences,  intensitysums.\n\nExample\n\njulia> ms₁ = MassSpectrum([80, 85, 90], [0, 10, 0]);\n\njulia> ms₂ = MassSpectrum([80, 85, 90], [10, 80, 5]);\n\njulia> meanintensities([ms₁, ms₂]) ≈ Float64[5.0, 45.0, 2.5]\ntrue\n\njulia> meanintensities([MassSpectrum([80], [5]), MassSpectrum([81], [5])])\nERROR: ArgumentError: mass spectra differ in ions\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.metadata-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.metadata","text":"metadata(ms::AbstractMassSpectrum) -> Dict{Any, Any}\n\nReturn the metadata.\n\nSee also AbstractMassSpectrum.\n\nExamples\n\njulia> ms = MassSpectrum([85.1], [13.0], metadata=Dict(:name=>\"unknown\"))\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 1 entry\n\njulia> metadata(ms)\nDict{Any, Any} with 1 entry:\n  :name => \"unknown\"\n\njulia> ms = MassSpectrum([85.1], [13.0])\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 0 entries\n\njulia> metadata(ms)\nDict{Any, Any}()\n\njulia> metadata(ms)[:species] = \"Polistes dominula\"\n\"Polistes dominula\"\n\njulia> metadata(ms)[:id] = 123\n123\n\njulia> metadata(ms)\nDict{Any, Any} with 2 entries:\n  :species => \"Polistes dominula\"\n  :id      => 123\n\njulia> ms\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 2 entries\n\njulia> delete!(metadata(ms), :species)\nDict{Any, Any} with 1 entry:\n  :id => 123\n\njulia> ms\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 85.1\nintensity: 13.0\nmetadata: 1 entry\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.minintensity-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.minintensity","text":"minintensity(ms::AbstractMassSpectrum)\n\nReturn the minimum intensity.\n\nSee also AbstractMassSpectrum, maxintensity(::AbstractMassSpectrum),  intensities(::AbstractMassSpectrum),  intensity(::AbstractMassSpectrum, ::Integer)`](@ref).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> minintensity(ms)\n0\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.minion-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.minion","text":"minion(ms::AbstractMassSpectrum)\n\nReturn the smallest ion.\n\nSee also AbstractMassSpectrum, maxion(::AbstractMassSpectrum),  ions(::AbstractMassSpectrum), ioncount(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer),  ionindex(::AbstractMassSpectrum, ::Real).\n\nExample\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> minion(ms)\n85\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.retentionindex-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.retentionindex","text":"retentionindex(ms::AbstractMassSpectrum)\n\nReturn the retention index. If no retention index is associated with the mass spectrum, the  function returns the value nothing.\n\nSee also AbstractMassSpectrum,  retentionindexname(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum([1.2], [1.1], retentionindex=131.1, retentionindexname=\"Kovats\")\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 1.2\nintensity: 1.1\nretention index: 131.1 (Kovats)\nmetadata: 0 entries\n\njulia> retentionindex(ms) ≈ 131.1\ntrue\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> retentionindex(ms) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.retentionindexname-Tuple{AbstractMassSpectrum}","page":"Mass Spectra","title":"JuChrom.retentionindexname","text":"retentionindexname(ms::AbstractMassSpectrum)\n\nReturn the retention index name. If the mass spectrum has no associated retention index,  the function returns the value nothing.\n\nSee also AbstractMassSpectrum, retentionindex(::AbstractMassSpectrum).\n\nExample\n\njulia> ms = MassSpectrum([1.2], [1.1], retentionindex=131.1, retentionindexname=\"Kovats\")\nMassSpectrum {ions: Float64, intensities: Float64}\n1 ion: m/z 1.2\nintensity: 1.1\nretention index: 131.1 (Kovats)\nmetadata: 0 entries\n\njulia> retentionindexname(ms)\n\"Kovats\"\n\njulia> ms = MassSpectrum(Int64[85, 112, 124], Int64[13, 0, 67])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 85, 112, 124\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> retentionindexname(ms) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/massspectra/#JuChrom.retentiontime","page":"Mass Spectra","title":"JuChrom.retentiontime","text":"retentiontime(ms::AbstractMassSpectrum; timeunit::Unitful.TimeUnits, \nustripped::Bool=false)\n\nReturn the retention time. If no retention time is associated with the mass spectrum, the  function returns the value nothing. The optional keyword argument timeunit lets you  change the unit of the returned scan time. All time units defined in the package  Unitful.jl (e.g., u\"s\", u\"minute\") are  supported. The optional keyword argument ustripped lets you choose whether to include the  unit in the returned value.\n\nSee also AbstractMassSpectrum, massspectrum.\n\nExamples\n\njulia> ms = MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67], retentiontime=3.2u\"minute\")\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nretention time: 3.2 minute\nmetadata: 0 entries\n\njulia> retentiontime(ms) ≈ 3.2u\"minute\"\ntrue\n\njulia> retentiontime(ms, timeunit=u\"s\") ≈ 192.0u\"s\"\ntrue\n\njulia> retentiontime(ms, timeunit=u\"s\", ustripped=true) ≈ 192.0\ntrue\n\njulia> retentiontime(ms, ustripped=true) ≈ 3.2\ntrue\n\njulia> ms = MassSpectrum([85.1, 112.2, 124.1], Int64[13, 0, 67])\nMassSpectrum {ions: Float64, intensities: Int64}\n3 ions: m/z 85.1, 112.2, 124.1\nintensity range: 0 - 67\nmetadata: 0 entries\n\njulia> retentiontime(ms) === nothing\ntrue\n\njulia> retentiontime(ms, timeunit=u\"ms\", ustripped=true) === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.sharedions","page":"Mass Spectra","title":"JuChrom.sharedions","text":"sharedions(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum)\n\nReturn the ions present in both mass spectra.\n\nSee also MassSpectrum, ions(::AbstractMassSpectrum),  ion(::AbstractMassSpectrum, ::Integer),  ioncount(::AbstractMassSpectrum).\n\nExample\n\njulia> ms₁ = MassSpectrum([80, 85, 90], [100, 500, 250])\nMassSpectrum {ions: Int64, intensities: Int64}\n3 ions: m/z 80, 85, 90\nintensity range: 100 - 500\nmetadata: 0 entries\n\njulia> ms₂ = MassSpectrum([80, 85], [100, 500])\nMassSpectrum {ions: Int64, intensities: Int64}\n2 ions: m/z 80, 85\nintensity range: 100 - 500\nmetadata: 0 entries\n\njulia> sharedions(ms₁, ms₂)\n2-element Vector{Int64}:\n 80\n 85\n\n\n\n\n\n","category":"function"},{"location":"man/massspectra/#JuChrom.similarity","page":"Mass Spectra","title":"JuChrom.similarity","text":"similarity(ms₁::AbstractMassSpectrum, ms₂::AbstractMassSpectrum, f::Function)\n\nCompute the similarity between the two mass spectra by applying the similarity function f  (e.g., cosine) to the intensity values of the ions shared between ms₁ and ms₂.\n\nSee also AbstractMassSpectrum, cosine,  sharedions,  ions(::AbstractMassSpectrum), intensities(::AbstractMassSpectrum).\n\nExamples\n\njulia> ms₁ = MassSpectrum(Int64[80, 85, 90], Int64[100, 500, 250]);\n\njulia> ms₂ = MassSpectrum(Int32[80, 85], Int32[200, 1000]);\n\njulia> similarity(ms₁, ms₂, cosine) ≈ 1.0\ntrue\n\njulia> ms₁ = MassSpectrum(Float64[80, 85, 90], Float32[100, 500, 250]);\n\njulia> ms₂ = MassSpectrum(Int64[80, 85, 90], Int32[200, 1000, 0]);\n\njulia> similarity(ms₁, ms₂, cosine) ≈ 0.8978873122816586\ntrue\n\n\n\n\n\n","category":"function"}]
}
